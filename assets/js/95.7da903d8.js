(window.webpackJsonp=window.webpackJsonp||[]).push([[95],{701:function(t,n,i){"use strict";i.r(n);var e=i(7),r=Object(e.a)({},(function(){var t=this,n=t.$createElement,i=t._self._c||n;return i("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[i("h2",{attrs:{id:"一、核心类差异"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#一、核心类差异"}},[t._v("#")]),t._v(" 一、核心类差异")]),t._v(" "),i("ol",[i("li",[t._v("Python3 对 Unicode 字符的原生支持。\nPython2 中使用 ASCII 码作为默认编码方式导致 string 有两种类型 str 和 unicode，Python3 只\n支持 unicode 的 string。Python2 和 Python3 字节和字符对应关系为：")]),t._v(" "),i("li",[t._v("Python3 采用的是绝对路径的方式进行 import\nPython2 中相对路径的 import 会导致标准库导入变得困难（想象一下，同一目录下有 file.py，如\n何同时导入这个文件和标准库 file）。Python3 中这一点将被修改，如果还需要导入同一目录的文件必须使用绝对路径，否则只能使用相关导入的方式来进行导入。")]),t._v(" "),i("li",[t._v("Python2 中存在老式类和新式类的区别，Python3 统一采用新式类。新式类声明要求继承 object，\n必须用新式类应用多重继承。")]),t._v(" "),i("li",[t._v("Python3 使用更加严格的缩进。Python2 的缩进机制中，1 个 tab 和 8 个 space 是等价的，所\n以在缩进中可以同时允许 tab 和 space 在代码中共存。这种等价机制会导致部分 IDE 使用存在问题。\nPython3 中 1 个 tab 只能找另外一个 tab 替代，因此 tab 和 space 共存会导致报错：TabError:\ninconsistent use of tabs and spaces in indentation.")])]),t._v(" "),i("h2",{attrs:{id:"二、废弃类差异"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#二、废弃类差异"}},[t._v("#")]),t._v(" 二、废弃类差异")]),t._v(" "),i("ol",[i("li",[t._v("print 语句被 Python3 废弃，统一使用 print 函数")]),t._v(" "),i("li",[t._v("exec 语句被 python3 废弃，统一使用 exec 函数")]),t._v(" "),i("li",[t._v('execfile 语句被 Python3 废弃，推荐使用 exec(open("./filename").read())')]),t._v(" "),i("li",[t._v('不相等操作符"<>"被 Python3 废弃，统一使用"!="')]),t._v(" "),i("li",[t._v("long 整数类型被 Python3 废弃，统一使用 int")]),t._v(" "),i("li",[t._v("xrange 函数被 Python3 废弃，统一使用 range，Python3 中 range 的机制也进行修改并提高\n了大数据集生成效率")]),t._v(" "),i("li",[t._v("Python3 中这些方法再不再返回 list 对象：dictionary 关联的 keys()、values()、items()，zip()，\nmap()，filter()，但是可以通过 list 强行转换：")]),t._v(" "),i("li",[t._v('mydict={"a":1,"b":2,"c":3}')]),t._v(" "),i("li",[t._v("mydict.keys() #<built-in method keys of dict object at 0x000000000040B4C8>")]),t._v(" "),i("li",[t._v("list(mydict.keys()) #['a', 'c', 'b']")]),t._v(" "),i("li",[t._v("迭代器 iterator 的 next()函数被 Python3 废弃，统一使用 next(iterator)")]),t._v(" "),i("li",[t._v("raw_input 函数被 Python3 废弃，统一使用 input 函数")]),t._v(" "),i("li",[t._v("字典变量的 has_key 函数被 Python 废弃，统一使用 in 关键词")]),t._v(" "),i("li",[t._v("file 函数被 Python3 废弃，统一使用 open 来处理文件，可以通过 io.IOBase 检查文件类型")]),t._v(" "),i("li",[t._v("apply 函数被 Python3 废弃")]),t._v(" "),i("li",[t._v("异常 StandardError 被 Python3 废弃，统一使用 Exception")])]),t._v(" "),i("h2",{attrs:{id:"三-、修改类差异"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#三-、修改类差异"}},[t._v("#")]),t._v(" 三 、修改类差异")]),t._v(" "),i("ol",[i("li",[t._v('浮点数除法操作符“/”和“//”的区别\n“ / ”：\nPython2：若为两个整形数进行运算，结果为整形，但若两个数中有一个为浮点数，则结果为\n浮点数；\nPython3:为真除法，运算结果不再根据参加运算的数的类型。\n“//”：\nPython2：返回小于除法运算结果的最大整数；从类型上讲，与"/"运算符返回类型逻辑一致。\nPython3：和 Python2 运算结果一样。')]),t._v(" "),i("li",[t._v("异常抛出和捕捉机制区别\nPython2")]),t._v(" "),i("li",[t._v('raise IOError, "file error" #抛出异常')]),t._v(" "),i("li",[t._v("except NameError, err: #捕捉异常\nPython3")]),t._v(" "),i("li",[t._v('raise IOError("file error") #抛出异常')]),t._v(" "),i("li",[t._v("except NameError as err: #捕捉异常")]),t._v(" "),i("li",[t._v("for 循环中变量值区别\nPython2，for 循环会修改外部相同名称变量的值")]),t._v(" "),i("li",[t._v("i = 1")]),t._v(" "),i("li",[t._v("print （'comprehension: ', [i for i in range(5)]）")]),t._v(" "),i("li",[t._v("print （'after: i =', i ） #i=4\nPython3，for 循环不会修改外部相同名称变量的值")]),t._v(" "),i("li",[t._v("i = 1")]),t._v(" "),i("li",[t._v("print （'comprehension: ', [i for i in range(5)]）")]),t._v(" "),i("li",[t._v("print （'after: i =', i ） #i=1")]),t._v(" "),i("li",[t._v("round 函数返回值区别\nPython2，round 函数返回 float 类型值")]),t._v(" "),i("li",[t._v("isinstance(round(15.5),int) #True\nPython3，round 函数返回 int 类型值")]),t._v(" "),i("li",[t._v("isinstance(round(15.5),float) #True")]),t._v(" "),i("li",[t._v("比较操作符区别\nPython2 中任意两个对象都可以比较")]),t._v(" "),i("li",[t._v("11 < 'test' #True\nPython3 中只有同一数据类型的对象可以比较")]),t._v(" "),i("li",[t._v("11 < 'test' # TypeError: unorderable types: int() < str()")])])])}),[],!1,null,null,null);n.default=r.exports}}]);