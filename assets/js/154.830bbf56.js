(window.webpackJsonp=window.webpackJsonp||[]).push([[154],{772:function(n,t,e){"use strict";e.r(t);var i=e(7),l=Object(i.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("ol",[e("li",[n._v("基础能力")])]),n._v(" "),e("ul",[e("li",[n._v("css单位区别\npx\t绝对像素，1px表示屏幕上的一个物理像素点\nem\t基于父元素的font-size计算，嵌套时会逐层计算\nrem\t基于根元素(html)的font-size(默认16px)全局统一\nvh\t可视区域高度的1%\nvw\t可视区域宽度的1%")])]),n._v(" "),e("p",[n._v("常见问题：\nQ1: 在 Retina 屏（如 iPhone）中，1px 的 CSS 像素会被渲染为 2~3 个物理像素，导致边框看起来比设计稿更粗，如何实现移动端 1px 边框？\n.border {\nborder: 1px solid #000;\ntransform: scaleY(0.5); /* 物理像素缩放 */\n}\nQ2: vw 和百分比（%）的区别？")]),n._v(" "),e("ul",[e("li",[e("p",[n._v("vw 相对于视口宽度，% 相对于父元素宽度。")])]),n._v(" "),e("li",[e("p",[n._v("html元素动态尺寸\n通过 JS 的 HTMLElement 对象可获取以下动态尺寸（记忆口诀：Client、Offset、Scroll 三大家族）：\nclientWidth\twidth + padding\noffsetWidth\twidth + padding + border\nscrollWidth\t内容总宽度(包括隐藏部分)")])]),n._v(" "),e("li",[e("p",[n._v('伪元素和伪类\n特性\t伪类\t伪元素\n作用对象\t元素的特定状态\t算数的特定部分如首行\n语法\t：单冒号\n:hover, :active,\n:focus,:nth-child(2)\t：：双冒号\n::before, ::after,\n::first-line,\n::first-letter,\n::placeholder,\nDOM影响\t不创建新元素\t创建虚拟的DOM节点\n面试常见问题：\nQ1: 如何通过伪元素实现一个三角形？\n.triangle::before {\ncontent: "";\ndisplay: block;\nwidth: 0;\nheight: 0;\nborder: 10px solid transparent;\nborder-top-color: red;\n}')])]),n._v(" "),e("li",[e("p",[n._v("css盒模型\n定义了html元素的占位方式，分为四层：")])])]),n._v(" "),e("ol",[e("li",[n._v("内容区域content：width/height设置")]),n._v(" "),e("li",[n._v("内边距padding：padding-top/right/bottom/left设置")]),n._v(" "),e("li",[n._v("边框border：border-width/style/color设置")]),n._v(" "),e("li",[n._v("外边距margin：margin-top/right/bottom/left设置\n两种盒模型（content-box，border-box）")]),n._v(" "),e("li",[n._v("标准盒模型（box-sizing: content-box）")])]),n._v(" "),e("ul",[e("li",[n._v("默认模式，width/height 仅控制content区域大小。")]),n._v(" "),e("li",[n._v("总宽度 = width + padding + border + margin")])]),n._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[n._v("怪异盒模型(box-sizing: border-box)")])]),n._v(" "),e("ul",[e("li",[e("p",[n._v("width/height 包含 content + padding + border。")])]),n._v(" "),e("li",[e("p",[n._v("总宽度 = width（已含 padding 和 border） + margin")])]),n._v(" "),e("li",[e("p",[n._v("js事件循环\nJavaScript 是单线程语言，但通过事件循环实现了异步编程。它的核心是 调用栈（Call Stack）、任务队列（Task Queue）和微任务队列（Microtask Queue） 的协同工作。\n调用栈：同步代码\n微任务队列：Promise.then / catch / finally / queueMicrotask\n宏任务队列：setTimeout / setInterval / I/O / DOM事件(点击、滚动)\n事件循环执行流程：")])])]),n._v(" "),e("ol",[e("li",[n._v("执行同步代码（调用栈）")]),n._v(" "),e("li",[n._v("执行所有微任务")]),n._v(" "),e("li",[n._v("从任务队列中取出一个任务，执行它（每次循环只执行一个宏任务）")]),n._v(" "),e("li",[n._v("重复上述步骤\n总结：\n概念\t示例\t执行时机\n同步代码\tConsole.log\t直接执行\n微任务\tPromise.then\t调用栈清空后，立即全部执行\n宏任务\tsetTimeout/DOM事件\t每次事件循环执行一个")])]),n._v(" "),e("ul",[e("li",[n._v("闭包")])]),n._v(" "),e("ol",[e("li",[n._v("什么是闭包？\n闭包（Closure） 是指 能够访问并记住其外部函数作用域的函数，即使外部函数已经执行完毕。")]),n._v(" "),e("li",[n._v("形成条件：")])]),n._v(" "),e("ul",[e("li",[n._v("嵌套：一个函数（内部函数）定义在另一个函数（外部函数）内部。")]),n._v(" "),e("li",[n._v("函数引用外部变量：内部函数使用了外部函数的变量或参数。")]),n._v(" "),e("li",[n._v("函数被暴露：内部函数通过 return、回调或赋值给全局变量等方式逃逸到外部作用域。\n示例：\nfunction outer() {\nlet count = 0; // 外部函数变量\nfunction inner() {\ncount++;     // 内部函数引用外部变量\nconsole.log(count);\n}\nreturn inner;  // 返回内部函数\n}")])]),n._v(" "),e("p",[n._v("const counter = outer(); // outer() 执行完毕，但 count 未被销毁\ncounter(); // 输出 1（仍能访问 count）\ncounter(); // 输出 2（闭包保留了 count 的状态）\n3.\t核心特征")]),n._v(" "),e("ul",[e("li",[n._v("持久化作用域：外部函数的变量不会被垃圾回收，即使外部函数已执行完毕。")]),n._v(" "),e("li",[n._v("私有性：外部变量只能通过闭包访问，形成“私有变量”。")]),n._v(" "),e("li",[n._v("动态性：每次调用外部函数，会生成独立的闭包（变量状态隔离）。\n示例：多个闭包独立\nconst counter1 = outer(); // 闭包1，count 初始为 0\nconst counter2 = outer(); // 闭包2，count 初始为 0\ncounter1(); // 1（闭包1的count）\ncounter2(); // 1（闭包2的count，与闭包1无关）")])]),n._v(" "),e("ol",{attrs:{start:"4"}},[e("li",[n._v("闭包可能会导致内存泄漏，如何解决？\n手动解除引用（如 counter = null）")]),n._v(" "),e("li",[n._v("闭包的应用（防抖和节流）\n防抖（防止抖动，等停下来即最后一次触发后，延迟执行），常用于输入框联想搜索，窗口resize\nfunction debounce(fn, delay) {\nlet timer = null; // ✅ 闭包保存 timer\nreturn function(...args) {\nclearTimeout(timer); // 清除上次的计时\ntimer = setTimeout(() => {\nfn.apply(this, args); // 延迟执行\n}, delay);\n};\n}\n节流（限制流量，固定时间间隔内只执行一次，稀释执行频率），常用于滚动加载，按钮高频点击\nfunction throttle(fn, delay) {\nlet lastTime = 0; // ✅ 闭包保存上次执行时间\nreturn function(...args) {\nconst now = Date.now();\nif (now - lastTime >= delay) { // 时间间隔达标\nfn.apply(this, args);\nlastTime = now; // 更新最后执行时间\n}\n};\n}\n关键区别：\n防抖： 事件触发 → ⏳ 延时重置 → 最终执行"),e("br"),n._v("\n节流： 事件触发 → 🕒 固定间隔 → 执行（无视中间触发）")])]),n._v(" "),e("ul",[e("li",[n._v("this指向")])]),n._v(" "),e("ol",[e("li",[n._v("在全局上下文中，this 引用全局对象。在浏览器中，全局对象是 window。在 Node.js 环境中，全局对象是 global。")]),n._v(" "),e("li",[n._v("在普通函数中（非严格模式下），this 引用全局对象；严格模式下为 undefined。")]),n._v(" "),e("li",[n._v("在对象的方法中，this 引用该对象。")]),n._v(" "),e("li",[n._v("在构造函数中，this 引用新创建的对象。")]),n._v(" "),e("li",[n._v("在类的方法中，this 指向类的实例。")]),n._v(" "),e("li",[n._v("在箭头函数中，this 继承自外层作用域。")]),n._v(" "),e("li",[n._v("可以使用 call、apply 和 bind 显式设置 this。")])]),n._v(" "),e("ul",[e("li",[n._v("改变this指向\n可以使用 bind()、call() 和 apply()")])]),n._v(" "),e("ol",[e("li",[n._v("call()立即调用，参数逐个传递\n语法：\nfunc.call(thisArg, arg1, arg2, ...)\n示例：\nfunction greet(message) {\nconsole.log("),e("code",[n._v("${message}, ${this.name}!")]),n._v(");\n}")])]),n._v(" "),e("p",[n._v("const user = { name: 'Alice' };\ngreet.call(user, 'Hello');\n// 输出: \"Hello, Alice!\"\n2.\tapply()立即调用，参数数组传递\n语法：\nfunc.apply(thisArg, [argsArray])\n示例：\nfunction introduce(city, age) {\nconsole.log("),e("code",[n._v("${this.name} is ${age} years old, from ${city}.")]),n._v(");\n}")]),n._v(" "),e("p",[n._v("const user = { name: 'Bob' };\nintroduce.apply(user, ['Beijing', 25]);\n// 输出: \"Bob is 25 years old, from Beijing.\"\n3.\tbind()返回新函数，延迟执行\n语法：\nconst boundFunc = func.bind(thisArg, arg1, arg2, ...)\n示例：\nfunction sayHello() {\nconsole.log("),e("code",[n._v("Hello, ${this.name}!")]),n._v(");\n}")]),n._v(" "),e("p",[n._v("const person = { name: 'Alice' };\nconst sayHelloToAlice = sayHello.bind(person);\nsayHelloToAlice();\n// 输出：Hello, Alice!")]),n._v(" "),e("ul",[e("li",[n._v("Promise.all()和Promise.race() 的区别")]),n._v(" "),e("li",[n._v("all：只有当数组中的所有Promise都成功完成（即状态变为fulfilled）时，返回的Promise才会成功完成，并将所有Promise的结果作为一个数组返回")]),n._v(" "),e("li",[n._v("race：以第一个完成（无论是成功还是失败）的Promise的结果作为其结果")])]),n._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[n._v("框架原理")])]),n._v(" "),e("ul",[e("li",[n._v("Vue2/3响应式原理\n特性\tVue2\tVue3\n实现方式\tObject.defineProperty\tProxy\n核心机制\n对象监听：递归遍历对象的每个属性，用 getter/setter 拦截读写操作。\n数组监听：重写数组的 7 个方法（push, pop, shift, unshift, splice, sort, reverse）。\tProxy：拦截对象的整个操作（包括新增/删除属性、数组索引变化）。\nReflect：提供安全的对象操作（替代 Object 方法）。\n新增/删除属性\t需要用Vue.set/delete\t直接操作\n性能\t递归便利对象，初始化慢\t惰性代理，按需触发\n依赖收集和更新触发\tDep 类：每个属性有一个 Dep 实例，存储依赖（Watcher）。\nWatcher：在 getter 中收集依赖，在 setter 中通知更新。\teffect 函数：通过 track（收集依赖）和 trigger（触发更新）实现。\nWeakMap 结构：更高效地管理依赖关系。\n优缺点\t缺陷：\n1.无法检测新增/删除属性\n2.数组索引和长度变化无法监听\n3.递归初始化性能较差\t优势：\n1.全面监听：支持对象、数组的所有操作。\n2.惰性代理：只有访问到的属性才会被代理，性能更好。\n3.简化 API：无需 Vue.set/Vue.delete。\n面试常见问题：\nQ1: Vue 2 为什么不能检测数组索引变化？\nObject.defineProperty 无法拦截数组的索引赋值（如 arr[0] = 1）和 length 修改。\nQ2: Vue 3 的 Proxy 有什么缺点？\n兼容性：不兼容 IE11（但 Vue 3 已放弃 IE 支持）。\n性能：Proxy 本身比 Object.defineProperty 稍慢，但整体更高效。\nQ3: Vue 3 如何处理嵌套对象的响应式？\n惰性代理：只有在访问嵌套对象时才递归代理，减少初始化开销。")]),n._v(" "),e("li",[n._v("hooks优缺点\nHooks的本质是让函数组件拥有“记忆能力”的工具。\n缺点\t优点\n需要理解闭包和依赖数组\t拆分复杂逻辑，共享逻辑\n不能条件调用hooks，必须顶层调用\t消除类组件的样板代码\n过度使用可能导致性能问题\t函数组件无需this")])]),n._v(" "),e("ol",{attrs:{start:"3"}},[e("li",[n._v("工程实践")])]),n._v(" "),e("ul",[e("li",[n._v("webpack优化手段\nWebpack 优化主要围绕 构建速度 和 产出体积 两大核心目标。\n构建速度")])]),n._v(" "),e("ol",[e("li",[n._v("多进程构建")]),n._v(" "),e("li",[n._v("缓存机制")]),n._v(" "),e("li",[n._v("DLL 预编译\n产出体积")]),n._v(" "),e("li",[n._v("代码分割")]),n._v(" "),e("li",[n._v("图片压缩")]),n._v(" "),e("li",[n._v("Gzip 压缩\n场景\t推荐方案\n开发环境构建慢\tcache-loader + thread-loader\n生产包体积过大\tTree Shaking + Code Splitting\n图片资源过多\timage-webpack-loader")])]),n._v(" "),e("ul",[e("li",[n._v("webpack常用loader和plugin\nLoader 用于“加载”各种类型的资源文件（JS、CSS、图片等），本质上是对模块的转换。")])]),n._v(" "),e("p",[n._v("Plugin 是在 Webpack 编译生命周期中执行各种任务的插件，比如压缩、注入环境变量、输出优化等。\n常用 loader：\nBabel-loader\tES6+转换为 ES5\nTs-loader\t编译 ts 文件\nSass-loader\t编译 sass 或less 为 css\nCss-loader\t解析@import 和 url()依赖\n常用 plugin：\nTerserPlugin\t压缩 js\nCssMinimizerPlugin\t压缩 css\nDefinePlugin\t定义环境变量")]),n._v(" "),e("ul",[e("li",[n._v("微前端方案\n简单场景：iframe（快速但功能受限）\nReact 技术栈：Module Federation（最优性能）\n混合框架：Qiankun（开箱即用 + 完善生态）")]),n._v(" "),e("li",[n._v("qiankun微前端框架\n如何通信？\n如何沙箱隔离？\nQiankun 是一个基于 Single-SPA 的企业级微前端解决方案，由蚂蚁金服团队开源。它通过 路由劫持 和 沙箱隔离 技术，实现多个独立前端应用的动态加载和协同运行。\n特性\t说明\n技术栈无关\t支持 React、Vue、Angular、jQuery 等任意技术栈的子应用\nHTML Entry 接入\t子应用只需导出生命周期钩子，无需修改构建配置\n样式/JS 沙箱隔离\t\t通过 Proxy + Shadow DOM 实现运行时隔离，避免全局污染\n资源预加载\t提前加载子应用静态资源，提升用户体验\n通信机制\t提供 initGlobalState 方法实现主子应用间状态共享\n子应用嵌套\t支持多层微应用嵌套\n实现原理：\n1.应用加载流程")])]),n._v(" "),e("p",[n._v("2.沙箱隔离机制：\nJS 沙箱：")]),n._v(" "),e("ul",[e("li",[e("p",[n._v("快照沙箱：子应用挂载时记录全局状态，卸载时恢复（兼容性更好）。")])]),n._v(" "),e("li",[e("p",[n._v("Proxy 沙箱：通过 Proxy 拦截 window 操作，实现动态隔离（性能更优）。\nCSS 隔离：")])]),n._v(" "),e("li",[e("p",[n._v("Shadow DOM：严格隔离样式（需子应用适配）。")])]),n._v(" "),e("li",[e("p",[n._v("动态样式表：卸载子应用时自动移除其样式标签（默认方案）。\n3.路由劫持")])]),n._v(" "),e("li",[e("p",[n._v("主应用监听路由变化，根据配置的 activeRule 匹配子应用。")])]),n._v(" "),e("li",[e("p",[n._v("子应用的路由由主应用统一调度，避免冲突。")])]),n._v(" "),e("li",[e("p",[n._v("ssr实现\nSSR（服务端渲染，Server-Side Rendering）是指在服务端把 Vue、React 等前端框架生成的 HTML 页面结构渲染好，直接返回给浏览器，从而提升首屏加载速度、利于 SEO、改善用户体验。\nSSR 基本流程图\n1.浏览器请求页面\n2.服务端运行 JS（如 Vue/React 组件），生成 HTML\n3.服务端将 HTML 返回给浏览器\n4.浏览器渲染出完整页面\n5.前端框架在客户端“激活”（hydration），接管页面交互")])])]),n._v(" "),e("ol",{attrs:{start:"4"}},[e("li",[n._v("编程题")])]),n._v(" "),e("ul",[e("li",[e("p",[n._v("写一个立刻执行的防抖函数\nfunction debounce(func, delay, immediate = false) {\nlet timer;\nreturn function(...args) {\nclearTimeout(timer);\nif(immediate && !timer) func.apply(this, args)\ntimer = setTimeout(() => {\nfunc.apply(this, args);\n}, dalay);\n};\n}")])]),n._v(" "),e("li",[e("p",[n._v("节流函数\nfunction throttle(fn, delay) {\nlet lastTime = 0; // ✅ 闭包保存上次执行时间\nreturn function(...args) {\nconst now = Date.now();\nif (now - lastTime >= delay) { // 时间间隔达标\nfn.apply(this, args);\nlastTime = now; // 更新最后执行时间\n}\n};\n}")])]),n._v(" "),e("li",[e("p",[n._v("手动实现vue的发布订阅模式\nclass EventBus {\nconstructor() {\nthis.events = {};\n}")])])]),n._v(" "),e("p",[n._v("on(event, callback) {\nif (!this.events[event]) {\nthis.events[event] = [];\n}\nthis.events[event].push(callback);\n}")]),n._v(" "),e("p",[n._v("emit(event, ...args) {\nif (this.events[event]) {\nthis.events[event].forEach(callback => {\ncallback(...args);\n});\n}\n}")]),n._v(" "),e("p",[n._v("off(event, callback) {\nif (this.events[event]) {\nthis.events[event] = this.events[event].filter(h => h !== callback);\n}\n}\n}")]),n._v(" "),e("ul",[e("li",[e("p",[n._v("手动实现promise.all()\nfunction customPromiseAll(promises){\nreturn new Promise((resolve, reject) => {\nif(promises.length === 0) {\nresolve([]);\nreturn;\n}")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("const results = [];\nlet count = 0;\n\npromises.forEach((promise, index) => {\n    promise\n    .then( res => {\n        results[index] = res;\n        count++;\n\n        if(count === promise.length) {\n            return(results);\n        }\n    })\n    .catch(reject);\n});\n")])])]),e("p",[n._v("});\n}")])]),n._v(" "),e("li",[e("p",[n._v("快排\nfunction quickSort(arr: number[]): number[] {\nif(arr.length <= 1) {\nreturn arr;\n}\nconst pivot = arr[0];\nconst left = [];\nconst right = [];")]),n._v(" "),e("p",[n._v("for(let i = 1; i< arr.length; i++) {\nif(arr[i] < pivot) {\nleft.push(arr[i])\n} else {\nright.push(arr[i])\n}\n}\nreturn [...quickSort(left), pivot, ...quickSort(right)]\n}")])]),n._v(" "),e("li")])])}),[],!1,null,null,null);t.default=l.exports}}]);