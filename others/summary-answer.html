<!-- ssr.html -->
<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>项目&amp;其他主观 | Week.D.Awn</title>
    <meta name="generator" content="VuePress 1.8.2" />
    <link rel="icon" href="/vuepress/logo.png">
    <link rel="apple-touch-icon" href="/vuepress/logo.png">
    <script language="javascript" type="text/javascript" src="https://cdn.staticfile.org/jquery/1.7.2/jquery.min.js"></script>
    <script language="javascript" type="text/javascript" src="/js/MouseClickEffect.js"></script> <meta name="description" content="Things Aren't Always What You Seem">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    <meta name="renderer" content="webkit">
    <meta name="referrer" content="never">
    <meta data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">  <link rel="preload" href="/assets/css/0.styles.6811066e.css" as="style"><link rel="preload" href="/assets/js/app.1d990b48.js" as="script"><link rel="preload" href="/assets/js/4.f0018437.js" as="script"><link rel="preload" href="/assets/js/1.f3d9f98c.js" as="script"><link rel="preload" href="/assets/js/124.58bcc7ee.js" as="script"><link rel="preload" href="/assets/js/22.15f81ae7.js" as="script"><link rel="prefetch" href="/assets/js/10.3c7a4bf7.js"><link rel="prefetch" href="/assets/js/100.2c62af51.js"><link rel="prefetch" href="/assets/js/101.ccad46e3.js"><link rel="prefetch" href="/assets/js/102.f982a2a4.js"><link rel="prefetch" href="/assets/js/103.bc1d780c.js"><link rel="prefetch" href="/assets/js/104.716d922d.js"><link rel="prefetch" href="/assets/js/105.46c6a494.js"><link rel="prefetch" href="/assets/js/106.5b5a22c7.js"><link rel="prefetch" href="/assets/js/107.6a78d65c.js"><link rel="prefetch" href="/assets/js/108.1ef11779.js"><link rel="prefetch" href="/assets/js/109.94c8b1c3.js"><link rel="prefetch" href="/assets/js/11.1b2114bd.js"><link rel="prefetch" href="/assets/js/110.aef287ba.js"><link rel="prefetch" href="/assets/js/111.4634177c.js"><link rel="prefetch" href="/assets/js/112.e490fc67.js"><link rel="prefetch" href="/assets/js/113.ab94757c.js"><link rel="prefetch" href="/assets/js/114.92a51620.js"><link rel="prefetch" href="/assets/js/115.dfdfdf29.js"><link rel="prefetch" href="/assets/js/116.431a8c5b.js"><link rel="prefetch" href="/assets/js/117.0f3fee99.js"><link rel="prefetch" href="/assets/js/118.93074b41.js"><link rel="prefetch" href="/assets/js/119.993610aa.js"><link rel="prefetch" href="/assets/js/12.e30e1f19.js"><link rel="prefetch" href="/assets/js/120.2511673a.js"><link rel="prefetch" href="/assets/js/121.9b5e21f2.js"><link rel="prefetch" href="/assets/js/122.c1041dad.js"><link rel="prefetch" href="/assets/js/123.157e2e70.js"><link rel="prefetch" href="/assets/js/125.2f4e0558.js"><link rel="prefetch" href="/assets/js/126.3e72e06f.js"><link rel="prefetch" href="/assets/js/127.ed0bd5b4.js"><link rel="prefetch" href="/assets/js/128.4c9cd12b.js"><link rel="prefetch" href="/assets/js/129.1ce7f0fd.js"><link rel="prefetch" href="/assets/js/13.61aeeda6.js"><link rel="prefetch" href="/assets/js/130.99041e38.js"><link rel="prefetch" href="/assets/js/14.c185f836.js"><link rel="prefetch" href="/assets/js/15.d5bd70dc.js"><link rel="prefetch" href="/assets/js/16.e862a626.js"><link rel="prefetch" href="/assets/js/17.feac98b6.js"><link rel="prefetch" href="/assets/js/18.82aaba59.js"><link rel="prefetch" href="/assets/js/19.6b715f9b.js"><link rel="prefetch" href="/assets/js/2.9d85cfd9.js"><link rel="prefetch" href="/assets/js/20.58b647e8.js"><link rel="prefetch" href="/assets/js/21.73ce08db.js"><link rel="prefetch" href="/assets/js/23.65d4655a.js"><link rel="prefetch" href="/assets/js/24.fe61f461.js"><link rel="prefetch" href="/assets/js/25.9187dbd8.js"><link rel="prefetch" href="/assets/js/26.115589cf.js"><link rel="prefetch" href="/assets/js/27.9309eca1.js"><link rel="prefetch" href="/assets/js/28.3077c7aa.js"><link rel="prefetch" href="/assets/js/29.b387bbf0.js"><link rel="prefetch" href="/assets/js/30.e9acfd7c.js"><link rel="prefetch" href="/assets/js/31.1d3d6ab5.js"><link rel="prefetch" href="/assets/js/32.c4d6ee26.js"><link rel="prefetch" href="/assets/js/33.bce3ca74.js"><link rel="prefetch" href="/assets/js/34.5888b4b0.js"><link rel="prefetch" href="/assets/js/35.345f8b16.js"><link rel="prefetch" href="/assets/js/36.c1132833.js"><link rel="prefetch" href="/assets/js/37.e0586ab6.js"><link rel="prefetch" href="/assets/js/38.30e7396e.js"><link rel="prefetch" href="/assets/js/39.9aed2f7f.js"><link rel="prefetch" href="/assets/js/40.8a8cff6c.js"><link rel="prefetch" href="/assets/js/41.79551185.js"><link rel="prefetch" href="/assets/js/42.615293c1.js"><link rel="prefetch" href="/assets/js/43.45ea2ca4.js"><link rel="prefetch" href="/assets/js/44.66ca530f.js"><link rel="prefetch" href="/assets/js/45.d99effc5.js"><link rel="prefetch" href="/assets/js/46.bde52456.js"><link rel="prefetch" href="/assets/js/47.58281d5b.js"><link rel="prefetch" href="/assets/js/48.7566a9ab.js"><link rel="prefetch" href="/assets/js/49.f3814edc.js"><link rel="prefetch" href="/assets/js/5.8cf73ced.js"><link rel="prefetch" href="/assets/js/50.dc0d2659.js"><link rel="prefetch" href="/assets/js/51.e80c9e03.js"><link rel="prefetch" href="/assets/js/52.5f34f7eb.js"><link rel="prefetch" href="/assets/js/53.7c5649d7.js"><link rel="prefetch" href="/assets/js/54.03910851.js"><link rel="prefetch" href="/assets/js/55.14419f67.js"><link rel="prefetch" href="/assets/js/56.ec67537a.js"><link rel="prefetch" href="/assets/js/57.2dd8c953.js"><link rel="prefetch" href="/assets/js/58.95a4324a.js"><link rel="prefetch" href="/assets/js/59.4b573c62.js"><link rel="prefetch" href="/assets/js/6.2af16871.js"><link rel="prefetch" href="/assets/js/60.5318bf97.js"><link rel="prefetch" href="/assets/js/61.59c0b2e8.js"><link rel="prefetch" href="/assets/js/62.783234c5.js"><link rel="prefetch" href="/assets/js/63.228ebab9.js"><link rel="prefetch" href="/assets/js/64.1c9af594.js"><link rel="prefetch" href="/assets/js/65.31ed69fb.js"><link rel="prefetch" href="/assets/js/66.01173beb.js"><link rel="prefetch" href="/assets/js/67.17a56d56.js"><link rel="prefetch" href="/assets/js/68.13d84e96.js"><link rel="prefetch" href="/assets/js/69.19d4abf0.js"><link rel="prefetch" href="/assets/js/7.56c364fd.js"><link rel="prefetch" href="/assets/js/70.c750bdf2.js"><link rel="prefetch" href="/assets/js/71.2762599a.js"><link rel="prefetch" href="/assets/js/72.e9e87533.js"><link rel="prefetch" href="/assets/js/73.ce5a0c8f.js"><link rel="prefetch" href="/assets/js/74.d43753c7.js"><link rel="prefetch" href="/assets/js/75.9d71c45d.js"><link rel="prefetch" href="/assets/js/76.ba7cae59.js"><link rel="prefetch" href="/assets/js/77.dc461251.js"><link rel="prefetch" href="/assets/js/78.7c330554.js"><link rel="prefetch" href="/assets/js/79.38dfcb32.js"><link rel="prefetch" href="/assets/js/8.7dd23328.js"><link rel="prefetch" href="/assets/js/80.6bab481a.js"><link rel="prefetch" href="/assets/js/81.b1f415ad.js"><link rel="prefetch" href="/assets/js/82.5956254b.js"><link rel="prefetch" href="/assets/js/83.d19458c5.js"><link rel="prefetch" href="/assets/js/84.e7ce6fe8.js"><link rel="prefetch" href="/assets/js/85.3cf379ad.js"><link rel="prefetch" href="/assets/js/86.3a1410eb.js"><link rel="prefetch" href="/assets/js/87.6963de0a.js"><link rel="prefetch" href="/assets/js/88.7704af10.js"><link rel="prefetch" href="/assets/js/89.4edbe9ad.js"><link rel="prefetch" href="/assets/js/9.60d349e8.js"><link rel="prefetch" href="/assets/js/90.7acf81d3.js"><link rel="prefetch" href="/assets/js/91.cc8b9bd1.js"><link rel="prefetch" href="/assets/js/92.bd7ee947.js"><link rel="prefetch" href="/assets/js/93.47bcf657.js"><link rel="prefetch" href="/assets/js/94.350e1df2.js"><link rel="prefetch" href="/assets/js/95.6050b2d7.js"><link rel="prefetch" href="/assets/js/96.5ae6e6a0.js"><link rel="prefetch" href="/assets/js/97.44a8d9e3.js"><link rel="prefetch" href="/assets/js/98.9cf496eb.js"><link rel="prefetch" href="/assets/js/99.1c841696.js"> <link rel="stylesheet" href="/assets/css/0.styles.6811066e.css">
    <script type="text/javascript">
      window.addEventListener("load", function () {
        var isMobile =
          !!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
            navigator.userAgent
          );
        // PC端显示 3D 地球
        if (!isMobile) document.getElementById("maps").style.display = "inline";
      });
    </script>
  </head>

  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-4f9c9c87><div data-v-4f9c9c87><div class="password-shadow password-wrapper-out" style="display:none;" data-v-06dbc5d6 data-v-4f9c9c87 data-v-4f9c9c87><h3 class="title" data-v-06dbc5d6 data-v-06dbc5d6>Week.D.Awn</h3> <p class="description" data-v-06dbc5d6 data-v-06dbc5d6>Things Aren't Always What You Seem</p> <label id="box" class="inputBox" data-v-06dbc5d6 data-v-06dbc5d6><input type="password" value="" data-v-06dbc5d6> <span data-v-06dbc5d6>Konck! Knock!</span> <button data-v-06dbc5d6>OK</button></label> <div class="footer" data-v-06dbc5d6 data-v-06dbc5d6><span data-v-06dbc5d6><i class="iconfont reco-theme" data-v-06dbc5d6></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-06dbc5d6>vuePress-theme-reco</a></span> <span data-v-06dbc5d6><i class="iconfont reco-copyright" data-v-06dbc5d6></i> <a data-v-06dbc5d6><span data-v-06dbc5d6>Week.D.Awn</span>
            
          <span data-v-06dbc5d6>2022 - </span>
          2023
        </a></span></div></div> <div class="hide" data-v-4f9c9c87><header class="navbar" data-v-4f9c9c87><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/vuepress/head.jpg" alt="Week.D.Awn" class="logo"> <span class="site-name">Week.D.Awn</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-blog"></i>
      领域
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>专业</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blogs/前端/" class="nav-link"><i class="iconfont reco-api"></i>
  前端
</a></li><li class="dropdown-subitem"><a href="/blogs/后端/" class="nav-link"><i class="iconfont reco-api"></i>
  后端
</a></li><li class="dropdown-subitem"><a href="/blogs/wiki/" class="nav-link"><i class="iconfont reco-other"></i>
  wiki
</a></li></ul></li></ul></div></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间线
</a></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-account"></i>
      开往
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://www.travellings.cn/go.html" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-api"></i>
  开往
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="/others/chatgpt.html" class="nav-link"><i class="iconfont reco-api"></i>
  My Chatgpt
</a></li><li class="dropdown-item"><h4>Week.D.Awn の Server</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="https://weekdawn-memos.tocmcc.cn" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-api"></i>
  memos
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://weekdawn-wiznote.tocmcc.cn" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-api"></i>
  为知笔记
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://weekdawn-cook.tocmcc.cn" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-api"></i>
  今天吃什么
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://weekdawn-alist.tocmcc.cn" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-api"></i>
  alist
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://weekdawn-portainer.tocmcc.cn" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-api"></i>
  portainer
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://www.ddnsto.com/app/#/files" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-api"></i>
  ddnsto
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li><li class="dropdown-item"><h4>Week.D.Awn の Notes</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="https://chat.openai.com/chat" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-api"></i>
  chatgpt
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="/others/jsontool.html" class="nav-link"><i class="iconfont reco-api"></i>
  jsonTool
</a></li><li class="dropdown-subitem"><a href="https://github.com/Fndroid/clash_for_windows_pkg/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-api"></i>
  Clash for Windows
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://portal.shadowsocks.au" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-api"></i>
  ss
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://github.com/weekdawn" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-api"></i>
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="/others/projects.html" class="nav-link"><i class="iconfont reco-api"></i>
  github starts
</a></li></ul></li></ul></div></div><div class="nav-item"><a href="/bookmarks/常用/常用网址.html" class="nav-link"><i class="iconfont reco-tag"></i>
  收藏
</a></div><div class="nav-item"><a href="/about/" class="nav-link"><i class="iconfont reco-account"></i>
  关于我
</a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-4f9c9c87></div> <aside class="sidebar" data-v-4f9c9c87><div class="personal-info-wrapper" data-v-ad235a34 data-v-4f9c9c87><img src="/vuepress/head.jpg" alt="author-avatar" class="personal-img" data-v-ad235a34> <h3 class="name" data-v-ad235a34>
    Week.D.Awn
  </h3> <div class="num" data-v-ad235a34><div data-v-ad235a34><h3 data-v-ad235a34>83</h3> <h6 data-v-ad235a34>Articles</h6></div> <div data-v-ad235a34><h3 data-v-ad235a34>87</h3> <h6 data-v-ad235a34>Tags</h6></div></div> <ul class="social-links" data-v-ad235a34></ul> <hr data-v-ad235a34></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-blog"></i>
      领域
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>专业</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blogs/前端/" class="nav-link"><i class="iconfont reco-api"></i>
  前端
</a></li><li class="dropdown-subitem"><a href="/blogs/后端/" class="nav-link"><i class="iconfont reco-api"></i>
  后端
</a></li><li class="dropdown-subitem"><a href="/blogs/wiki/" class="nav-link"><i class="iconfont reco-other"></i>
  wiki
</a></li></ul></li></ul></div></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间线
</a></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-account"></i>
      开往
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://www.travellings.cn/go.html" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-api"></i>
  开往
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="/others/chatgpt.html" class="nav-link"><i class="iconfont reco-api"></i>
  My Chatgpt
</a></li><li class="dropdown-item"><h4>Week.D.Awn の Server</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="https://weekdawn-memos.tocmcc.cn" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-api"></i>
  memos
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://weekdawn-wiznote.tocmcc.cn" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-api"></i>
  为知笔记
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://weekdawn-cook.tocmcc.cn" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-api"></i>
  今天吃什么
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://weekdawn-alist.tocmcc.cn" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-api"></i>
  alist
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://weekdawn-portainer.tocmcc.cn" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-api"></i>
  portainer
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://www.ddnsto.com/app/#/files" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-api"></i>
  ddnsto
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li><li class="dropdown-item"><h4>Week.D.Awn の Notes</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="https://chat.openai.com/chat" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-api"></i>
  chatgpt
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="/others/jsontool.html" class="nav-link"><i class="iconfont reco-api"></i>
  jsonTool
</a></li><li class="dropdown-subitem"><a href="https://github.com/Fndroid/clash_for_windows_pkg/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-api"></i>
  Clash for Windows
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://portal.shadowsocks.au" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-api"></i>
  ss
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://github.com/weekdawn" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-api"></i>
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="/others/projects.html" class="nav-link"><i class="iconfont reco-api"></i>
  github starts
</a></li></ul></li></ul></div></div><div class="nav-item"><a href="/bookmarks/常用/常用网址.html" class="nav-link"><i class="iconfont reco-tag"></i>
  收藏
</a></div><div class="nav-item"><a href="/about/" class="nav-link"><i class="iconfont reco-account"></i>
  关于我
</a></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-06dbc5d6 data-v-4f9c9c87><h3 class="title" data-v-06dbc5d6 data-v-06dbc5d6></h3> <!----> <label id="box" class="inputBox" data-v-06dbc5d6 data-v-06dbc5d6><input type="password" value="" data-v-06dbc5d6> <span data-v-06dbc5d6>Konck! Knock!</span> <button data-v-06dbc5d6>OK</button></label> <div class="footer" data-v-06dbc5d6 data-v-06dbc5d6><span data-v-06dbc5d6><i class="iconfont reco-theme" data-v-06dbc5d6></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-06dbc5d6>vuePress-theme-reco</a></span> <span data-v-06dbc5d6><i class="iconfont reco-copyright" data-v-06dbc5d6></i> <a data-v-06dbc5d6><span data-v-06dbc5d6>Week.D.Awn</span>
            
          <span data-v-06dbc5d6>2022 - </span>
          2023
        </a></span></div></div> <div data-v-4f9c9c87><main class="page"><section><div class="page-title"><h1 class="title">项目&amp;其他主观</h1> <div data-v-da1c0c82><i class="iconfont reco-account" data-v-da1c0c82><span data-v-da1c0c82>Week.D.Awn</span></i> <!----> <i class="iconfont reco-eye" data-v-da1c0c82><span id="/others/summary-answer.html" data-flag-title="Your Article Title" class="leancloud-visitors" data-v-da1c0c82><a class="leancloud-visitors-count" style="font-size:.9rem;font-weight:normal;color:#999;"></a></span></i> <!----></div></div> <div class="theme-reco-content content__default"><h2 id="项目-其他主观"><a href="#项目-其他主观" class="header-anchor">#</a> 项目&amp;其他主观</h2> <h3 id="工作中遇到的最难的问题是什么-如何解决的"><a href="#工作中遇到的最难的问题是什么-如何解决的" class="header-anchor">#</a> 工作中遇到的最难的问题是什么？如何解决的？</h3> <ol><li>相似的主题页面过多，</li></ol> <ul><li>解决办法采用数据驱动页面的模式来进行模块化开发，数据与视图分开</li></ul> <ol start="2"><li>动态主题切换：
<ul><li>放到public里面，用json进行配置，看选择ccb还是ccbft来进行文字和主题的切换</li></ul></li> <li>涉密题目的安全问题
<ul><li>题目进行第一次base64编码</li> <li>所有题目组成的字典对象再进行一次base64编码</li></ul></li></ol> <h3 id="项目中遇到的难点以及收获"><a href="#项目中遇到的难点以及收获" class="header-anchor">#</a> 项目中遇到的难点以及收获？</h3> <h3 id="遇到过长时间没解决的问题吗"><a href="#遇到过长时间没解决的问题吗" class="header-anchor">#</a> 遇到过长时间没解决的问题吗？</h3> <p>本地共享线上环境cookie，进行本地调试的方法</p> <h3 id="如果你的同事出现工作上情绪的问题-你如何调节"><a href="#如果你的同事出现工作上情绪的问题-你如何调节" class="header-anchor">#</a> 如果你的同事出现工作上情绪的问题，你如何调节？</h3> <p>当同事出现工作上的情绪问题时，作为一个团队成员或领导者，采取适当的方法来帮助他们调节情绪是非常重要的。以下是一些建议的步骤和方法：</p> <ul><li>倾听：首先，给予他们充分的关注和倾听。让他们知道你在乎他们的感受，并愿意为他们提供支持。</li> <li>提供安全的环境：确保他们知道与你交谈是安全的，你不会随意传播或误解他们的情感。</li> <li>避免立即给出建议：在他们分享完感受之前，尽量不要打断或立即给出建议。有时，人们只是需要一个倾诉的对象。</li> <li>询问原因：尝试了解导致情绪问题的具体原因。这可以帮助你更好地理解他们的处境，并提供更有针对性的支持。</li> <li>展现同情和理解：表达你理解他们的感受，并告诉他们每个人都会有不好的时候。</li> <li>提供实际的帮助：如果可能的话，考虑提供实际的帮助，如分担一些工作、提供资源或建议等。</li> <li>鼓励他们寻求专业帮助：如果情绪问题持续存在或很严重，建议他们考虑寻求专业的心理健康支持。</li> <li>与上级或人力资源部门沟通：如果你认为情况需要进一步的干预或支持，可以考虑与上级或人力资源部门沟通，以确保同事得到适当的帮助。</li> <li>关心他们的身体健康：情绪问题有时与身体健康有关。鼓励他们保持健康的生活方式，如规律的作息、健康饮食和适量的锻炼。</li> <li>定期关心：在事件发生后的一段时间内，定期询问他们的情况，确保他们知道你仍然关心他们。</li></ul> <p>最后，每个人的情况都是独特的，所以最重要的是展现出真正的关心和理解，以及愿意为他们提供支持的态度。</p> <h3 id="你之前的项目是怎么做线上发布的"><a href="#你之前的项目是怎么做线上发布的" class="header-anchor">#</a> 你之前的项目是怎么做线上发布的？</h3> <ol><li>版本控制，合并特征分支到投产分支</li> <li>编写dockerfile</li> <li>配置流水线
<ol><li>获取仓库代码</li> <li>node环境构建和代码打包</li> <li>代码扫描</li> <li>构建镜像</li></ol></li> <li>打开云桌面，登录测试服务器，修改yml文件的版本号，或者修改弹性伸缩</li></ol> <h3 id="有尝试不用-vuecli-搭建过项目吗"><a href="#有尝试不用-vuecli-搭建过项目吗" class="header-anchor">#</a> 有尝试不用 vueCli 搭建过项目吗？</h3> <p>没有</p> <h3 id="你是怎么理解软件研发的生命周期的"><a href="#你是怎么理解软件研发的生命周期的" class="header-anchor">#</a> 你是怎么理解软件研发的生命周期的？</h3> <ol><li>产品-需求收集和分析</li> <li>架构师-系统设计</li> <li>需求评审和技术评审会议</li> <li>开发阶段</li> <li>测试阶段</li> <li>部署上线</li> <li>维护和支持</li></ol> <h3 id="接触过什么前端前沿技术"><a href="#接触过什么前端前沿技术" class="header-anchor">#</a> 接触过什么前端前沿技术？</h3> <p>微前端qiankun，qiankun 起源于蚂蚁金服基于微前端架构的统一前端平台。</p> <ul><li>简单：由于主应用和子应用可以独立于技术栈，qiankun 对用户来说只是一个类似于 jQuery 的库。您只需调用几个 qiankun API 即可完成应用的微前端转换。</li> <li>解耦/技术中立：微前端的核心目标是将单一应用拆解为一系列松散耦合的微应用，所有的 qiankun 设计都遵循这一原则。</li> <li>基于 single-spa：提供更多开箱即用的API。</li> <li>技术中立：任何 JavaScript 框架都可以使用/集成，无论是 React、Vue、Angular、JQuery 还是其他框架。</li> <li>HTML 入口访问模式：让您像使用 iframe 一样简单地访问子应用。</li> <li>样式隔离：确保样式不会相互干扰。</li> <li>JS 沙箱：确保子应用之间的全局变量/事件不冲突。</li> <li>预取资产：在浏览器空闲时间预取未打开的子应用资产，以加速子应用的打开速度。</li></ul> <h3 id="最近学习的技术点"><a href="#最近学习的技术点" class="header-anchor">#</a> 最近学习的技术点？</h3> <p>自建脚手架</p> <h2 id="计算机网络"><a href="#计算机网络" class="header-anchor">#</a> 计算机网络</h2> <h3 id="http-的-get-和-post-请求有什么区别"><a href="#http-的-get-和-post-请求有什么区别" class="header-anchor">#</a> http 的 GET 和 POST 请求有什么区别？</h3> <p>HTTP 是一种用于传输数据的协议，其中 GET 和 POST 是两种常见的请求方法。它们有以下区别：</p> <ol><li>数据位置：</li></ol> <ul><li>GET：将数据附加在 URL 的查询字符串中，即在 URL 后面使用 ? 和参数键值对来传递数据。例如：http://example.com/api?param1=value1&amp;param2=value2</li> <li>POST：将数据放在请求体中，不会显示在 URL 中。数据作为请求体的一部分被发送到服务器。</li></ul> <ol start="2"><li>请求体：</li></ol> <ul><li>GET：没有请求体，所有数据都是通过 URL 传递的。</li> <li>POST：有请求体，可以在请求体中包含更多的数据，不仅限于键值对。</li></ul> <ol start="3"><li>数据长度限制：</li></ol> <ul><li>GET：受 URL 长度的限制，不适合传输大量数据。（不同浏览器有不同的限制，通常在 2KB 到 8KB 之间。）</li> <li>POST：没有固定的长度限制，适合传输大量数据。（一般来说，服务器和网关可能有更大的容忍度，但浏览器通常会有较小的限制，一般在 2MB 到 8MB 之间。）</li></ul> <ol start="4"><li>安全性：</li></ol> <ul><li>GET：数据通过 URL 传递，容易被拦截，不适合传输敏感信息。</li> <li>POST：数据放在请求体中，相对更安全，适合传输敏感信息。</li></ul> <ol start="5"><li>缓存：</li></ol> <ul><li>GET：可以被浏览器缓存，对相同的请求会返回缓存的结果。</li> <li>POST：不会被浏览器缓存，每次请求都会向服务器发送请求。</li></ul> <ol start="6"><li>幂等性：</li></ol> <ul><li>GET：是幂等的，多次相同的 GET 请求会返回相同的结果。</li> <li>POST：不一定是幂等的，多次相同的 POST 请求可能会引起不同的结果，特别是在服务端进行了数据的新增操作。</li></ul> <ol start="7"><li>用途：</li></ol> <ul><li>GET：用于获取资源，对服务器数据不会产生影响，只读操作。</li> <li>POST：用于提交数据，可能会对服务器数据进行修改、新增等操作。
总之，GET 和 POST 请求的主要区别在于数据传递的方式、数据的安全性、适用场景以及对服务器的影响。根据具体的需求和情况，选择合适的请求方法可以更好地满足应用的需求。</li></ul> <h3 id="为什么post会有两次请求"><a href="#为什么post会有两次请求" class="header-anchor">#</a> 为什么post会有两次请求</h3> <p>在某些情况下，可能会出现 POST 请求发起两次的情况。以下是一些可能导致这种情况发生的原因：</p> <ol><li>浏览器预加载： 一些浏览器会进行预加载，以提高页面加载速度。在预加载阶段，浏览器可能会发送一个 OPTIONS 请求（预检请求）来检查实际的请求是否安全，然后再发送真正的 POST 请求。这可能导致看起来像是两次请求，但实际上只有一次是真正的 POST 请求。</li> <li>重定向： 如果服务器在接收到 POST 请求后执行了重定向操作，浏览器可能会先发送一次 POST 请求，然后在重定向的响应中再次发起 POST 请求。</li></ol> <h3 id="http的请求头和请求体"><a href="#http的请求头和请求体" class="header-anchor">#</a> http的请求头和请求体</h3> <p>HTTP 请求由请求头（Headers）和请求体（Body）两部分组成。它们包含了客户端向服务器发送请求时的各种信息，包括请求的方式、目标资源、附加数据等。下面分别介绍一下请求头和请求体的内容：</p> <p><strong>1. 请求头（Headers）：</strong>
HTTP 请求头是一组键值对，用于携带请求的元信息和控制信息。请求头位于 HTTP 请求的起始行之后，每个键值对以换行符分隔。以下是常见的请求头字段：</p> <ul><li>Host：指定请求的目标主机名和端口号。</li> <li>User-Agent：发送请求的用户代理（通常是浏览器）的标识信息。</li> <li>Accept：告诉服务器可以接受的响应内容类型。</li> <li>Content-Type：指定请求体中的数据的类型，例如 application/json。</li> <li>Authorization：用于身份验证，包含用户凭证信息。</li> <li>Referer：指示请求是从哪个页面发起的，常用于防止 CSRF 攻击。</li> <li>Cookie：包含用户的会话信息。</li></ul> <p><strong>2. 请求体（Body）：</strong>
HTTP 请求体是可选的，用于在 POST 或其他需要发送数据的请求方法中传递数据。请求体的格式取决于 Content-Type 请求头的值。常见的数据类型包括：</p> <ul><li>application/x-www-form-urlencoded：表单数据，如 key1=value1&amp;key2=value2。</li> <li>multipart/form-data：用于上传文件，通常用于文件上传。</li> <li>application/json：JSON 格式的数据。</li> <li>text/plain：纯文本数据。
请求体中的数据通常用于向服务器传递信息，比如表单数据、JSON 数据、上传的文件等。</li></ul> <h3 id="http请求头的属性有什么"><a href="#http请求头的属性有什么" class="header-anchor">#</a> http请求头的属性有什么</h3> <p>HTTP 头部（Header）是 HTTP 请求和响应中用来传递附加信息的部分，它可以包含多个字段，用来描述消息的属性、控制缓存、身份验证等。以下是一些常见的 HTTP 头部：</p> <ul><li>User-Agent： 标识浏览器或客户端的用户代理信息。</li> <li>Host： 表示服务器的域名和端口号。</li> <li>Accept： 指定客户端能够处理的响应内容类型。</li> <li>Content-Type： 表示请求或响应的实体内容类型。</li> <li>Authorization： 包含身份验证凭证，用于身份验证。</li> <li>Cookie： 包含客户端发送到服务器的 Cookie 信息。</li> <li>Set-Cookie： 服务器用来设置 Cookie 的响应头。</li> <li>Content-Length： 表示请求或响应体的长度。</li> <li>Cache-Control： 控制缓存的行为，如缓存过期时间、是否使用缓存等。</li> <li>If-Modified-Since： 用于条件请求，表示如果资源在指定时间后有更新才返回内容。</li> <li>Location： 用于重定向，表示新的请求地址。</li> <li>Referer： 表示请求的来源 URL，用于统计和防盗链等。</li> <li>User-Agent： 表示客户端的用户代理信息，用于服务器判断请求的设备和浏览器。</li> <li>ETag： 表示资源的实体标签，用于缓存验证。</li> <li>Last-Modified： 表示资源的最后修改时间，用于缓存验证。</li> <li>Origin： 表示请求的来源地址，用于跨域请求的安全限制。</li> <li>Access-Control-Allow-Origin： 用于跨域请求，表示允许的源地址。</li></ul> <h3 id="跟缓存相关的http请求头"><a href="#跟缓存相关的http请求头" class="header-anchor">#</a> 跟缓存相关的http请求头</h3> <p>HTTP 请求头中与缓存相关的主要字段有以下几个：</p> <ol><li>Cache-Control： 该字段控制缓存的行为。常用的值包括：</li></ol> <ul><li>no-cache：强制缓存服务器重新验证缓存项，但仍可以缓存。</li> <li>no-store：禁止缓存，不应将响应存储在缓存中。</li> <li>max-age=<seconds>：指定缓存的最大有效时间（秒）。</seconds></li> <li>s-maxage=<seconds>：覆盖 max-age，只适用于共享缓存（如 CDN）。</seconds></li> <li>public：允许任何缓存存储响应，包括客户端和共享缓存。</li> <li>private：只允许客户端缓存存储响应，不允许共享缓存。</li></ul> <ol start="2"><li>Expires： 定义响应的到期时间，是一个绝对时间点。如果与 Cache-Control 同时存在，Cache-Control 优先级更高。</li> <li>Last-Modified 和 If-Modified-Since： Last-Modified 是服务器返回的资源的最后修改时间，If-Modified-Since 是客户端发送的时间。通过比较这两个值，服务器可以判断资源是否在指定时间后发生了变化，如果没有变化，可以返回 304 Not Modified，客户端从缓存中加载资源。</li> <li>ETag 和 If-None-Match： ETag 是服务器生成的资源唯一标识符（通常是哈希值），If-None-Match 是客户端发送的标识符。服务器可以通过比较这两个值判断资源是否发生了变化，如果没有变化，返回 304 Not Modified。</li></ol> <h3 id="http1-1、http2-0的区别-http2-0相对于http1-1有哪些改进"><a href="#http1-1、http2-0的区别-http2-0相对于http1-1有哪些改进" class="header-anchor">#</a> http1.1、http2.0的区别？http2.0相对于http1.1有哪些改进</h3> <p>HTTP/1.1 和 HTTP/2.0 是 HTTP 协议的两个主要版本，它们在很多方面有着显著的区别。以下是 HTTP/1.1 和 HTTP/2.0 的一些主要区别：
<strong>1. 多路复用（Multiplexing）：</strong></p> <ul><li>HTTP/1.1：每个请求需要使用一个单独的 TCP 连接，在同一时间内只能处理一个请求，因此存在队头阻塞问题。</li> <li>HTTP/2.0：使用多路复用，可以在一个连接上同时传输多个请求和响应，解决了队头阻塞问题，提高了并发性能。
<strong>2. 二进制分帧（Binary Framing）：</strong></li> <li>HTTP/1.1：使用文本格式传输数据，Header 和数据以文本形式发送。</li> <li>HTTP/2.0：将请求和响应数据分割成二进制帧（frames），每个帧都有帧头，以二进制形式传输，提高了传输效率和解析速度。
<strong>3. Header 压缩：</strong></li> <li>HTTP/1.1：Header 信息在每个请求和响应中都会被发送，造成冗余传输。</li> <li>HTTP/2.0：使用 HPACK 压缩算法对 Header 进行压缩，减少了头部大小，降低了数据传输量，提高了性能。
<strong>4. 服务器推送（Server Push）：</strong></li> <li>HTTP/1.1：客户端必须发送请求来获取所需的资源，存在额外的往返时间。</li> <li>HTTP/2.0：服务器可以在客户端请求之前主动推送资源，减少了等待时间，提高了页面加载速度。
<strong>5. 流量优先级（Priority）：</strong></li> <li>HTTP/1.1：无法明确指定请求的优先级，可能导致重要资源被阻塞。</li> <li>HTTP/2.0：允许客户端设置请求的优先级，服务器可以根据优先级进行数据传输，确保重要资源优先加载。
<strong>6. 头部处理：</strong></li> <li>HTTP/1.1：每个请求和响应都会带有完整的 Header，可能会造成冗余。</li> <li>HTTP/2.0：Header 可以在一个连接上共享，减少了冗余传输，提高了性能。
<strong>7. 兼容性：</strong></li> <li>HTTP/1.1：与之前的版本兼容，但存在一些性能问题。</li> <li>HTTP/2.0：通过现有的基础设施进行升级，可以在现有的网络架构上实现。</li></ul> <h3 id="https和http区别"><a href="#https和http区别" class="header-anchor">#</a> https和http区别</h3> <p>HTTP（Hypertext Transfer Protocol）和 HTTPS（Hypertext Transfer Protocol Secure）是用于在互联网上传输数据的两种协议，它们之间有一些关键的区别：</p> <ol><li>安全性：</li></ol> <ul><li>HTTP：传输的数据是明文的，不加密，容易被中间人窃取或篡改。</li> <li>HTTPS：传输的数据经过加密，使用 SSL/TLS 协议确保数据的保密性和完整性，更安全。</li></ul> <ol start="2"><li>端口：</li></ol> <ul><li>HTTP：默认端口是 80。</li> <li>HTTPS：默认端口是 443。</li></ul> <ol start="3"><li>证书：</li></ol> <ul><li>HTTP：不需要证书。</li> <li>HTTPS：需要 SSL 证书，用于验证服务器身份。</li></ul> <ol start="4"><li>性能：</li></ol> <ul><li>HTTP：无加密过程，传输速度相对较快。</li> <li>HTTPS：加密解密过程会增加一些开销，传输速度可能稍慢。</li></ul> <ol start="5"><li>SEO 影响：</li></ol> <ul><li>HTTP：某些搜索引擎可能会将 HTTP 站点标记为不安全。</li> <li>HTTPS：HTTPS 站点更受搜索引擎青睐，有助于提高搜索排名。</li></ul> <ol start="6"><li>使用场景：</li></ol> <ul><li>HTTP：适用于不需要保密性和数据完整性的情况，如一般的网页浏览。</li> <li>HTTPS：适用于需要保护用户隐私和数据安全的场景，如登录、支付等敏感操作。</li></ul> <h3 id="https用到了非对称加密-用最通俗的语言-即便是父母也能听懂的方式-讲一下什么是非对称加密"><a href="#https用到了非对称加密-用最通俗的语言-即便是父母也能听懂的方式-讲一下什么是非对称加密" class="header-anchor">#</a> https用到了非对称加密，用最通俗的语言（即便是父母也能听懂的方式）讲一下什么是非对称加密</h3> <p>当我们谈论非对称加密时，可以将其比喻为一把特殊的锁和一把匹配的钥匙。想象一下，你有一把锁，可以锁住一个盒子，但只有特殊的钥匙才能打开这个锁。这个特殊的钥匙是非对称加密中的“私钥”。
现在，如果你想要给朋友一个保密的礼物，你可以拿到他的锁，锁住礼物盒，然后把这个锁交给朋友。只有他拥有匹配的钥匙，也就是“公钥”，才能打开这个锁，看到礼物。
所以，非对称加密就像是用特殊的锁来锁住信息，只有拥有匹配的钥匙才能解锁。这使得信息在传输过程中保持安全，因为只有拥有正确钥匙的人才能解读信息，其他人无法窥探。</p> <h3 id="https能保证传输绝对安全吗"><a href="#https能保证传输绝对安全吗" class="header-anchor">#</a> https能保证传输绝对安全吗?</h3> <p>虽然 HTTPS（Hypertext Transfer Protocol Secure）可以提供更高的数据传输安全性，但它也不能保证绝对的安全。以下是一些 HTTPS 仍然面临的挑战和限制：</p> <ol><li>证书信任问题： HTTPS 的安全性依赖于 SSL/TLS 证书，这些证书由可信的证书颁发机构（CA）签发。如果证书被不当使用或泄露，或者用户信任了一个恶意证书颁发机构，就有可能存在安全风险。</li> <li>中间人攻击： 尽管 HTTPS 使用加密来保护数据传输，但中间人攻击仍然可能发生。攻击者可能尝试劫持通信，伪造一个有效的证书，并在通信的两端之间进行数据交换。</li> <li>漏洞和弱点： 即使使用 HTTPS，仍然可能存在服务器端或客户端的漏洞，黑客可以利用这些漏洞来入侵系统或获取敏感信息。</li> <li>依赖于密钥管理： HTTPS 使用公钥和私钥进行加密和解密，如果密钥管理不当，私钥可能会泄露，导致数据被窃取。</li> <li>不包括端到端加密： HTTPS 只在数据传输的过程中提供加密保护，但在发送端和接收端之间的数据仍然可能会被泄露。</li></ol> <h3 id="如何实现从http升级到https"><a href="#如何实现从http升级到https" class="header-anchor">#</a> 如何实现从http升级到https</h3> <p>将网站从 HTTP 升级到 HTTPS 需要一些步骤和配置。以下是一般的升级过程：</p> <ol><li>获取 SSL/TLS 证书： 要使用 HTTPS，首先需要获得有效的 SSL/TLS 证书。你可以通过自签名、免费的证书颁发机构（如 Let's Encrypt）或商业证书颁发机构获得证书。</li> <li>安装证书： 将获得的证书安装到你的服务器上。这可能需要将证书文件（包括私钥、公钥和中间证书）放在服务器特定的位置。</li> <li>配置服务器： 修改服务器配置，以启用 HTTPS。在 Web 服务器配置文件中，通常需要指定 SSL 证书文件路径、监听的端口号（默认为 443）等。</li> <li>重定向： 配置 HTTP 到 HTTPS 的重定向。这可以确保用户访问你的网站时自动跳转到安全的 HTTPS 版本。</li> <li>更新网站链接和资源： 更新网站中所有引用的链接和资源，将 HTTP 链接替换为 HTTPS 链接，以避免浏览器出现混合内容的警告。</li> <li>更新搜索引擎和链接： 如果你的网站被索引了，确保更新搜索引擎索引中的链接为 HTTPS。同时，如果你的网站被其他网站引用，通知这些网站更新链接。</li> <li>测试和监控： 在升级完成后，测试整个网站以确保 HTTPS 正常工作。同时，监控网站的性能和安全性，确保证书的到期时间等。</li> <li>HSTS 配置（可选）： HSTS（HTTP Strict Transport Security）是一种安全机制，可以强制客户端将所有请求都使用 HTTPS，以防止中间人攻击。</li></ol> <h3 id="详细说https建立的流程"><a href="#详细说https建立的流程" class="header-anchor">#</a> 详细说HTTPS建立的流程？</h3> <p>HTTPS 的建立是基于传输层安全性协议 (TLS, 之前称为 SSL) 的，它提供了一种保护在应用层和传输层之间的数据的方式。以下是 HTTPS 连接建立的详细流程，也被称为 TLS 握手过程：
<strong>1. 客户端Hello (ClientHello):</strong></p> <ul><li>客户端开始握手过程，发送一个ClientHello消息到服务器。这个消息会包含：
<ul><li>客户端支持的 TLS 版本。</li> <li>客户端支持的加密套件列表（例如 AES、ChaCha20、RSA、ECDHE等）。</li> <li>一个随机生成的数，称为ClientRandom。</li> <li>一个可选的会话ID，用于会话复用。
<strong>2. 服务器Hello (ServerHello):</strong></li></ul></li> <li>服务器响应，发送一个ServerHello消息到客户端。这个消息会包含：
<ul><li>服务器选择使用的 TLS 版本。</li> <li>从客户端的列表中选择的加密套件。</li> <li>一个随机生成的数，称为ServerRandom。</li> <li>如果适用的话，确认的会话ID。
<strong>3. 服务器证书 (Server Certificate):</strong></li></ul></li> <li>服务器发送其证书到客户端。证书中包含了公钥和一些身份信息，并且它由一个可信的证书颁发机构 (CA) 签名。</li> <li>对于某些加密套件，服务器可能还会发送额外的关键信息。
<strong>4. 密钥交换 (Key Exchange):</strong></li> <li>这一步的确切流程取决于所选择的加密套件。例如，如果使用 Diffie-Hellman 密钥交换，则此时客户端和服务器会交换密钥信息来共同生成一个预主密钥 (PreMaster Secret)。</li> <li>在 RSA 密钥交换中，客户端会生成预主密钥并使用服务器的公钥加密它，然后发送给服务器。服务器使用其私钥解密并获取预主密钥。
<strong>5. 计算主密钥 (Master Secret):</strong></li> <li>一旦预主密钥被确定，客户端和服务器都会使用它、ClientRandom 和 ServerRandom 来计算主密钥 (Master Secret)。
<strong>6. 客户端发送结束 (Finished) 消息:</strong></li> <li>客户端发送一个加密的Finished消息给服务器，该消息包含此前所有交换的消息的一个散列值，确保整个握手过程的完整性。
<strong>7. 服务器发送结束 (Finished) 消息:</strong></li> <li>服务器回复一个加密的Finished消息给客户端，同样包含一个散列值。
<strong>8. 加密数据传输:</strong></li> <li>一旦握手完成，客户端和服务器就开始使用约定的加密套件和主密钥来加密和传输数据</li></ul> <h3 id="ssl加密的细节"><a href="#ssl加密的细节" class="header-anchor">#</a> ssl加密的细节</h3> <p>SSL（Secure Socket Layer）是一个过时的安全协议，已经被现代的传输层安全性（TLS）协议取代。但是，由于历史原因，人们常常用SSL和TLS来交替引用。我们可以从早期的SSL协议版本开始，详细说明其加密细节，但请注意，由于安全隐患，SSL的使用现已不推荐。
<strong>以下是SSL的加密流程的概述：</strong></p> <ol><li>协议开始:</li></ol> <ul><li>客户端发起请求并发送ClientHello消息，其中包含支持的SSL版本、密码套件列表、一个随机数(ClientRandom)等。</li> <li>服务器响应ServerHello消息，选择一个客户端支持的密码套件和另一个随机数(ServerRandom)。</li></ul> <ol><li>服务器证书和密钥交换:</li></ol> <ul><li>服务器向客户端发送其由CA（证书颁发机构）签名的公开证书。</li> <li>如果使用RSA密钥交换，客户端会生成一个预主密钥(Pre-Master Secret)，使用服务器的公钥加密并发送给服务器。服务器接收到消息后使用其私钥进行解密，从而获取到预主密钥。</li></ul> <ol><li>计算主密钥:</li></ol> <ul><li>客户端和服务器都使用ClientRandom、ServerRandom和预主密钥来派生出主密钥(Master Secret)。</li> <li>主密钥再用来派生出其他几个密钥：客户端写密钥、服务器写密钥、客户端MAC密钥和服务器MAC密钥。</li></ul> <ol><li>客户端和服务器确认:</li></ol> <ul><li>客户端和服务器都发送加密的Finished消息，确认密钥正在正常工作，并且握手过程没有被篡改。</li></ul> <ol><li>数据传输:</li></ol> <ul><li>使用派生的加密密钥对数据进行加密，然后进行传输。同时使用MAC密钥来确保数据的完整性。</li></ul> <ol><li>连接结束:</li></ol> <ul><li>当双方完成数据交换时，它们会发送close_notify警报以安全地结束会话。</li> <li>其中，SSL的核心加密过程在于使用对称和非对称加密的组合。非对称加密（例如RSA）在握手过程中用于安全地交换密钥，而对称加密（例如AES或3DES）用于数据的实际传输，因为它更快。</li></ul> <p>然而，SSL 2.0和SSL 3.0都存在多个已知的安全问题，使它们容易受到攻击。现代的Web服务器和浏览器已经放弃了这些协议版本，改用TLS（特别是TLS 1.2和1.3）。</p> <h3 id="对称加密和非对称加密"><a href="#对称加密和非对称加密" class="header-anchor">#</a> 对称加密和非对称加密</h3> <p><strong>- 对称加密</strong></p> <ol><li>定义: 对称加密使用同一把密钥进行数据的加密和解密。</li> <li>密钥管理:</li></ol> <ul><li>只有一个密钥，必须保密。</li> <li>密钥的分发和管理是对称加密的主要挑战，因为双方（发送方和接收方）都需要这个密钥，并且在安全的情况下交换密钥是困难的。</li></ul> <ol start="3"><li>速度和效率: 通常，对称加密算法的速度较快，更适合大量数据的加密。</li> <li>常见的对称加密算法:</li></ol> <ul><li>AES (Advanced Encryption Standard)</li> <li>DES (Data Encryption Standard)</li> <li>3DES (Triple DES)</li> <li>RC4, RC5, RC6</li> <li>Blowfish</li> <li>Twofish</li></ul> <ol start="5"><li>使用场景: 对大数据流或块的加密，如文件加密、数据库加密、或TLS/SSL的数据传输阶段。</li></ol> <p><strong>- 非对称加密</strong></p> <ol><li>定义: 非对称加密使用一对密钥：一个公钥和一个私钥。公钥用于加密数据，私钥用于解密数据。</li> <li>密钥管理:</li></ol> <ul><li>公钥可以公开，但私钥必须保密。</li> <li>由于公钥可以被公开，因此解决了密钥分发的问题。接收方只需将其公钥发送给发送方，而私钥不必在网络上传输。</li></ul> <ol start="3"><li>速度和效率: 非对称加密算法通常比对称加密算法慢，因此不适合直接加密大量数据。</li> <li>常见的非对称加密算法:</li></ol> <ul><li>RSA</li> <li>DSA (Digital Signature Algorithm)</li> <li>ECDSA (Elliptic Curve Digital Signature Algorithm)</li> <li>ElGamal</li> <li>Diffie-Hellman</li></ul> <ol start="5"><li>使用场景: 在安全通信中进行密钥交换、数字签名、证书验证等。</li></ol> <p><strong>总结</strong>：</p> <ul><li>对称加密：一个密钥，速度快，适用于大数据流或数据块的加密。</li> <li>非对称加密：两个密钥（公钥和私钥），速度相对较慢，适用于密钥交换、数字签名和证书验证。</li></ul> <h3 id="加密的过程有了解过吗"><a href="#加密的过程有了解过吗" class="header-anchor">#</a> 加密的过程有了解过吗</h3> <p><strong>对称加密的过程：</strong></p> <ol><li>选择密钥：在通信开始之前，发送方和接收方都需要获取同一个密钥，这通常称为共享密钥。</li> <li>加密：</li></ol> <ul><li>发送方使用选定的对称加密算法（例如AES）和共享密钥将明文加密为密文。</li> <li>为了加强加密，还可以使用不同的模式（例如CBC、ECB等）和初始化向量(IV)。</li></ul> <ol start="3"><li>传输：加密后的密文可以通过不安全的通道（如互联网）传输，因为没有密钥，攻击者不能轻易解密内容。</li> <li>解密：接收方使用相同的加密算法和共享密钥将密文解密回明文。</li></ol> <p><strong>非对称加密的过程：</strong></p> <ol><li>密钥对生成：使用非对称加密算法生成一对密钥，一个公钥和一个私钥。</li> <li>加密：</li></ol> <ul><li>发送方使用接收方的公钥将明文加密为密文。这样，只有持有相应私钥的接收方才能解密这个密文。</li></ul> <ol start="3"><li>传输：同样，加密后的密文可以通过不安全的通道传输。</li> <li>解密：接收方使用其私钥解密密文回明文。</li></ol> <p><strong>注意点：</strong></p> <ul><li>对称加密在传输大量数据时非常有效，但其主要挑战在于如何安全地传输或共享密钥。</li> <li>非对称加密解决了密钥分发的问题，但由于计算复杂性，直接加密大量数据时会比对称加密慢得多。</li> <li>在实际应用中，这两种加密经常结合使用。例如，在TLS握手中，非对称加密用于交换对称密钥，然后使用这个对称密钥来加密实际的数据传输。</li></ul> <h3 id="ca机构有了解吗"><a href="#ca机构有了解吗" class="header-anchor">#</a> CA机构有了解吗</h3> <ul><li>CA（Certificate Authority，证书颁发机构）是负责发行和管理数字证书的组织。这些数字证书用于在网络上建立安全连接，验证网站、个人或设备的身份，并加密数据。</li></ul> <p><strong>主要职责</strong></p> <ul><li>身份验证：在颁发数字证书之前，CA首先验证请求者的身份。对于网站SSL/TLS证书，这通常涉及验证域名的所有权；对于个人或组织的证书，可能需要更详细的背景检查。</li> <li>颁发证书：一旦完成身份验证，CA就会创建一个数字证书，然后用CA的私钥对其进行签名。这使得任何人都可以使用CA的公钥验证证书的真实性和完整性。</li> <li>证书吊销和续期：证书有固定的有效期。如果证书在其有效期内被认为是不安全的（例如，相关的私钥被泄露），则CA可以吊销该证书。CA还管理证书的续期。</li> <li>维护证书吊销列表（CRL）：CA提供一个更新的列表，列出所有被吊销的证书。用户和应用程序可以查询这个列表来确认证书的有效性。</li> <li>在线证书状态协议（OCSP）：这是另一种验证证书状态的方式。与查询CRL不同，OCSP客户端可以询问CA证书的状态，并得到实时响应。</li></ul> <p><strong>一些知名的CA：</strong></p> <ul><li>Let's Encrypt：一个免费、自动化和开放的CA，由Internet Security Research Group（ISRG）运营。</li> <li>DigiCert</li> <li>GlobalSign</li> <li>Comodo</li> <li>GoDaddy</li> <li>Symantec：已被DigiCert收购。</li></ul> <h2 id="浏览器原理"><a href="#浏览器原理" class="header-anchor">#</a> 浏览器原理</h2> <h3 id="浏览器输入url网址到网页显示的全过程"><a href="#浏览器输入url网址到网页显示的全过程" class="header-anchor">#</a> 浏览器输入url网址到网页显示的全过程</h3> <ol><li><p><strong>URL解析</strong></p> <ul><li>浏览器首先检查URL是否为完整的URL或仅为搜索查询。</li> <li>如果是搜索查询，浏览器将使用默认的搜索引擎生成一个查询URL。</li></ul></li> <li><p><strong>缓存检查</strong></p> <ul><li>浏览器检查其缓存（内存缓存、磁盘缓存、Service Worker 缓存等）。</li> <li>如果找到了匹配的资源，浏览器可能会直接从缓存中加载。</li></ul></li> <li><p><strong>DNS解析</strong></p> <ul><li>浏览器解析URL中的域名以找到对应的IP地址。</li> <li>这涉及查询DNS记录。</li></ul></li> <li><p><strong>建立TCP连接</strong></p> <ul><li>得到IP地址后，浏览器会与服务器建立一个TCP连接。</li> <li>这涉及到TCP三次握手过程。</li></ul></li> <li><p><strong>发送HTTP请求</strong></p> <ul><li>一旦TCP连接建立，浏览器发送HTTP请求到服务器。</li></ul></li> <li><p><strong>HTTPS与TLS/SSL</strong></p> <ul><li>如果网站使用HTTPS，浏览器和服务器会进行TLS/SSL握手。</li> <li>保证数据的安全传输。</li></ul></li> <li><p><strong>服务器处理</strong></p> <ul><li>服务器接收到HTTP请求后，可能进行数据库查询、模板渲染等。</li> <li>生成或获取所请求的资源。</li></ul></li> <li><p><strong>接收HTTP响应</strong></p> <ul><li>服务器发送一个HTTP响应。</li> <li>包括状态码、响应头和响应体。</li></ul></li> <li><p><strong>浏览器渲染</strong></p> <ul><li><strong>HTML解析</strong>：浏览器解析HTML，构建DOM树。</li> <li><strong>CSS解析</strong>：浏览器解析CSS，生成CSSOM树。</li> <li><strong>JavaScript处理</strong>：执行JavaScript，可能会修改DOM和CSSOM。</li> <li><strong>生成渲染树</strong>：结合DOM和CSSOM生成渲染树。</li> <li><strong>布局</strong>：计算每个节点的位置。</li> <li><strong>绘制</strong>：浏览器绘制每个节点。</li></ul></li> <li><p><strong>额外的资源加载</strong></p> <ul><li>HTML可能引用额外资源（如图片、CSS、JavaScript）。</li> <li>这些资源也需要进行加载和处理。</li></ul></li> <li><p><strong>页面显示</strong></p> <ul><li>所有步骤完成后，渲染的页面在浏览器中显示。</li></ul></li></ol> <h3 id="重排、重绘"><a href="#重排、重绘" class="header-anchor">#</a> 重排、重绘</h3> <h4 id="重绘-repaint"><a href="#重绘-repaint" class="header-anchor">#</a> 重绘（Repaint）</h4> <ul><li><strong>定义</strong>：
<ul><li>当页面中元素的外观（例如颜色、阴影或其他可视属性，但不包括布局）发生变化，但没有改变其在页面中的位置时，浏览器需要重新绘制这些元素。这个过程称为重绘。</li></ul></li> <li><strong>触发情况</strong>：
<ul><li>修改元素的<code>visibility</code>属性。</li> <li>修改元素的<code>outline</code>、<code>background</code>、<code>box-shadow</code>等不影响布局的属性。</li></ul></li></ul> <h4 id="重排-reflow"><a href="#重排-reflow" class="header-anchor">#</a> 重排（Reflow）</h4> <ul><li><strong>定义</strong>：
<ul><li>当因为某些原因导致元素的布局位置发生改变，浏览器需要重新计算元素的位置和尺寸并渲染出来。这个过程被称为重排。由于涉及更多的计算和渲染工作，重排通常比重绘更加昂贵。</li></ul></li> <li><strong>触发情况</strong>：
<ul><li>页面首次渲染。</li> <li>浏览器窗口大小改变。</li> <li>元素位置或尺寸改变（例如修改<code>width</code>、<code>height</code>、<code>margin</code>、<code>border</code>、<code>padding</code>等属性）。</li> <li>内容发生变化，如添加或删除可见的DOM元素。</li> <li>修改元素的字体大小。</li> <li>修改元素的<code>position</code>属性值。</li> <li>激活CSS伪类（如<code>:hover</code>）。</li></ul></li></ul> <h4 id="优化建议"><a href="#优化建议" class="header-anchor">#</a> 优化建议</h4> <ol><li><strong>避免频繁的DOM操作</strong>：</li></ol> <ul><li>使用<code>documentFragment</code>或离屏DOM来批量更新，然后一次性添加到页面上。</li></ul> <ol start="2"><li><strong>使用<code>transform</code>和<code>opacity</code>进行动画</strong>：</li></ol> <ul><li>这些属性可以由浏览器的合成线程处理，避免触发重排。</li></ul> <ol start="3"><li><strong>避免使用表格布局</strong>：</li></ol> <ul><li>因为整个表格会重新计算，即使是一个小的改动。</li></ul> <ol start="4"><li><strong>减少层的数量</strong>：</li></ol> <ul><li>减少页面中的层可以帮助浏览器更快地进行合成。</li></ul> <ol start="5"><li><strong>使用<code>window.requestAnimationFrame</code></strong>：</li></ol> <ul><li>对于动画或持续的视觉变化，使用<code>requestAnimationFrame</code>可以确保浏览器在合适的时间进行重绘。
理解和减少不必要的重排和重绘是前端优化中的关键步骤，有助于提供更流畅的用户体验。</li></ul> <h3 id="浏览器标签页之间怎么通信"><a href="#浏览器标签页之间怎么通信" class="header-anchor">#</a> 浏览器标签页之间怎么通信</h3> <ol><li><code>localStorage</code> 、<code>sessionStorage</code> 和事件监听：</li></ol> <ul><li>当一个标签页修改了localStorage或sessionStorage，其他的标签页可以通过监听storage事件来捕获这个变化。</li> <li>但是，这种方式的通信是单向的。触发变更的标签页不会接收到storage事件。</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code>window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'storage'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span>key <span class="token operator">==</span> <span class="token string">'myKey'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Data updated:'</span><span class="token punctuation">,</span> event<span class="token punctuation">.</span>newValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ol start="2"><li><code>BroadcastChannel</code> API：</li></ol> <ul><li>这是一个相对较新的API，允许来自同一源的多个窗口或页面之间进行双向通信。</li> <li>使用它创建一个命名的通道，任何页面都可以发送或接收消息。</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> channel <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BroadcastChannel</span><span class="token punctuation">(</span><span class="token string">'my_channel'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

channel<span class="token punctuation">.</span><span class="token function-variable function">onmessage</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Received:'</span><span class="token punctuation">,</span> event<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 在一个标签页中发送消息</span>
channel<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token string">'Hello other tabs!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ol start="3"><li>Window.postMessage()：</li></ol> <ul><li>使用window.open()打开的窗口与原始窗口之间可以通过postMessage()进行双向通信。</li> <li>安全地允许跨源通信。</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 发送消息</span>
otherWindow<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token string">'Hello'</span><span class="token punctuation">,</span> <span class="token string">'https://example.com'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 接收消息</span>
window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'message'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span>origin <span class="token operator">!==</span> <span class="token string">'https://example.com'</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Received:'</span><span class="token punctuation">,</span> event<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ol start="4"><li>共享Web Workers：</li></ol> <ul><li>Web Workers运行在后台线程中，不与主线程关联。</li> <li>多个标签页可以连接到同一个共享Web Worker并通过它进行通信。</li></ul> <ol start="5"><li><code>Server-sent Events</code> (SSE) 或<code>WebSockets</code>：</li></ol> <ul><li>虽然这不是直接的标签页间通信，但可以通过服务器作为中介来间接实现。</li> <li>一个标签页可以发送信息到服务器，然后服务器可以推送这个信息到其他标签页。</li></ul> <ol start="6"><li>使用Cookies：</li></ol> <ul><li>通过设置cookie在一个标签页，并在其他标签页定期检查cookie变化来通信。</li> <li>但这种方法可能不够高效，还可能受到浏览器隐私设置的限制。</li></ul> <ol start="7"><li>第三方库：</li></ol> <ul><li>一些第三方库（例如 Intercom 或 PubNub）提供了跨标签页通信的解决方案。
选择哪种方法取决于具体需求和浏览器兼容性。例如，如果要支持的浏览器不支持BroadcastChannel，则可能需要选择其他方法。</li></ul> <h3 id="浏览器本地存储的方式"><a href="#浏览器本地存储的方式" class="header-anchor">#</a> 浏览器本地存储的方式？</h3> <ol><li><strong>Cookie</strong>:</li></ol> <ul><li>由服务器设置，每次浏览器向该服务器发送请求时，相关的cookie也会被发送。</li> <li>大小受限，通常为4KB。</li> <li>有有效期，可以设置为会话cookie或持久cookie。</li> <li>适用于小量数据存储，常用于会话管理、个性化设置和用户追踪。</li></ul> <ol start="2"><li><strong>localStorage</strong>:</li></ol> <ul><li>键值对存储，没有过期时间。</li> <li>数据会持久存储，即使浏览器关闭后仍然存在。</li> <li>存储限制通常为5-10MB。</li> <li>与特定的源（协议、域名和端口）相关联。</li></ul> <ol start="3"><li><strong>sessionStorage</strong>:</li></ol> <ul><li>与<code>localStorage</code>类似，但是存储的数据只在一个浏览器会话期间持续。</li> <li>当浏览器标签或窗口关闭时，数据将被清除。</li> <li>与特定的源（协议、域名和端口）相关联。</li></ul> <ol start="4"><li><strong>IndexedDB</strong>:</li></ol> <ul><li>一个事务性的、基于索引的API，用于存储大量结构化数据。</li> <li>可以存储例如文件、BLOBs等复杂数据类型。</li> <li>没有明确的大小限制，但浏览器可能会提示用户对大的存储操作给予许可。</li> <li>支持高性能搜索和高级数据处理。</li></ul> <ol start="5"><li><strong>Web SQL</strong> (已废弃):</li></ol> <ul><li>一种保存结构化数据的客户端解决方案，使用SQL语言。</li> <li>已被W3C废弃，不建议使用，但某些旧版本的浏览器仍支持。</li></ul> <ol start="6"><li><strong>Cache API</strong>:</li></ol> <ul><li>用于缓存网络资源，使得web应用在离线时也能工作。</li> <li>通常与Service Workers结合使用，以提供离线功能。</li></ul> <ol start="7"><li><strong>FileSystem API</strong> (仅限某些浏览器):</li></ol> <ul><li>允许web应用读取或保存文件到客户端本地。</li> <li>主要在Chrome和其基于Chromium的浏览器中支持。</li></ul> <h3 id="cookie-localstorage-sessionstorage区别"><a href="#cookie-localstorage-sessionstorage区别" class="header-anchor">#</a> cookie，localStorage，sessionStorage区别？</h3> <h2 id="cookie、localstorage、sessionstorage-的区别"><a href="#cookie、localstorage、sessionstorage-的区别" class="header-anchor">#</a> cookie、localStorage、sessionStorage 的区别</h2> <ol><li><strong>Cookie</strong>:</li></ol> <ul><li><strong>存储大小</strong>: 通常限制为4KB。</li> <li><strong>生命周期</strong>: 可设置为会话cookie（关闭浏览器时失效）或持久cookie（有一个明确的过期时间）。</li> <li><strong>与服务器交互</strong>: 每次请求都会附带，可能影响到请求性能。</li> <li><strong>适用场景</strong>: 主要用于会话管理、个性化设置和用户追踪。</li></ul> <ol start="2"><li><strong>localStorage</strong>:</li></ol> <ul><li><strong>存储大小</strong>: 通常限制为5-10MB，取决于浏览器。</li> <li><strong>生命周期</strong>: 除非被清除，否则数据会永久存储。</li> <li><strong>与服务器交互</strong>: 默认情况下不会与服务器进行通信。</li> <li><strong>适用场景</strong>: 长时间存储键值对数据，如用户偏好设置。</li></ul> <ol start="3"><li><strong>sessionStorage</strong>:</li></ol> <ul><li><strong>存储大小</strong>: 通常限制为5-10MB，取决于浏览器。</li> <li><strong>生命周期</strong>: 数据只在一个浏览器会话期间持续。当浏览器标签或窗口关闭时，数据将被清除。</li> <li><strong>与服务器交互</strong>: 默认情况下不会与服务器进行通信。</li> <li><strong>适用场景</strong>: 会话期间存储数据，如购物车信息。</li></ul> <p><strong>总结:</strong></p> <ul><li><strong>大小限制</strong>: <code>cookie</code>的存储量是最小的，而<code>localStorage</code>和<code>sessionStorage</code>提供更大的存储空间。</li> <li><strong>生命周期</strong>: <code>cookie</code>和<code>localStorage</code>可以持久存储，而<code>sessionStorage</code>仅在会话期间。</li> <li><strong>与服务器的交互</strong>: 只有<code>cookie</code>会随每个请求自动发送到服务器。</li></ul> <h3 id="它们会把数据存在哪-受不受同源策略制约"><a href="#它们会把数据存在哪-受不受同源策略制约" class="header-anchor">#</a> 它们会把数据存在哪？受不受同源策略制约？</h3> <ol><li><strong>Cookie</strong>:</li></ol> <ul><li><strong>存储位置</strong>: 数据存储在用户的硬盘上，并且每次请求相同的服务器时都会附带。</li> <li><strong>同源策略</strong>: Cookie是受同源策略制约的。但通过设置<code>document.domain</code>和适当的响应头，可以在相同主域的不同子域之间共享Cookie。</li></ul> <ol start="2"><li><strong>localStorage</strong>:</li></ol> <ul><li><strong>存储位置</strong>: 数据存储在用户的硬盘上，在浏览器的专门区域为每个站点提供的文件夹中。它不会随请求发送到服务器。</li> <li><strong>同源策略</strong>: <code>localStorage</code>受到同源策略的严格限制。只有当协议、域名和端口号都相同的时候，才能读写访问它。</li></ul> <ol start="3"><li><strong>sessionStorage</strong>:</li></ol> <ul><li><strong>存储位置</strong>: 数据通常存储在用户的硬盘上，与<code>localStorage</code>的存储方式相似。但它的生命周期只限于浏览器会话。</li> <li><strong>同源策略</strong>: <code>sessionStorage</code>也受到同源策略的严格限制。只有当协议、域名和端口号都相同的时候，才能读写访问它。</li></ul> <p><strong>总结:</strong>
所有这些技术都受到同源策略的制约，这意味着在一个域中设置的数据在另一个域中是不可访问的。这是为了确保网站之间的数据隔离，提供用户数据的安全性和隐私性。</p> <h3 id="cookie常用的属性有哪些"><a href="#cookie常用的属性有哪些" class="header-anchor">#</a> cookie常用的属性有哪些？</h3> <ol><li><strong>Name</strong></li></ol> <ul><li><strong>描述</strong>: Cookie 的名称。与其值一起，这构成了 Cookie 的主要部分。</li> <li><strong>示例</strong>: <code>username=JohnDoe</code></li></ul> <ol start="2"><li><strong>Value</strong></li></ol> <ul><li><strong>描述</strong>: Cookie 的值，与其名称对应。</li> <li><strong>示例</strong>: <code>username=JohnDoe</code></li></ul> <ol start="3"><li><strong>Domain</strong></li></ol> <ul><li><strong>描述</strong>: 定义了哪些域可以接收 Cookie。</li> <li><strong>默认</strong>: 如果未设置，则默认为设置 Cookie 的域。</li> <li><strong>示例</strong>: <code>.example.com</code> 可以匹配 <code>sub.example.com</code> 和 <code>example.com</code></li></ul> <ol start="4"><li><strong>Path</strong></li></ol> <ul><li><strong>描述</strong>: 定义了域中的哪些路径可以接收 Cookie。</li> <li><strong>默认</strong>: 如果未设置，则默认为设置 Cookie 的路径。</li> <li><strong>示例</strong>: 如果路径为 <code>/blog</code>，则只有 <code>/blog</code> 下的页面可以访问该 Cookie。</li></ul> <ol start="5"><li><strong>Expires</strong></li></ol> <ul><li><strong>描述</strong>: 指定 Cookie 的过期日期和时间。</li> <li><strong>默认</strong>: 如果未设置，则 Cookie 会在浏览器会话结束时过期。</li> <li><strong>示例</strong>: <code>Fri, 31 Dec 2021 23:59:59 GMT</code></li></ul> <ol start="6"><li><strong>Max-Age</strong></li></ol> <ul><li><strong>描述</strong>: 定义从 Cookie 被设置或更新开始，Cookie 存活的秒数。</li> <li><strong>示例</strong>: <code>3600</code> 表示 Cookie 将在 1 小时后过期。</li></ul> <ol start="7"><li><strong>Secure</strong></li></ol> <ul><li><strong>描述</strong>: 该属性指示 Cookie 仅应通过 HTTPS 协议传输。</li> <li><strong>默认</strong>: 如果不设置，Cookie 可以在任何协议上被传输。</li> <li><strong>示例</strong>: <code>Secure</code></li></ul> <ol start="8"><li><strong>HttpOnly</strong></li></ol> <ul><li><strong>描述</strong>: 指示 Cookie 不应该通过客户端 JavaScript 被访问。</li> <li><strong>默认</strong>: 如果不设置，Cookie 可以通过 JavaScript 的 <code>document.cookie</code> 访问。</li> <li><strong>示例</strong>: <code>HttpOnly</code></li></ul> <ol start="9"><li><strong>SameSite</strong></li></ol> <ul><li><strong>描述</strong>: 允许服务器要求某个 Cookie 在跨站请求中不得随请求一同发送，这可以减少跨站请求伪造攻击。</li> <li><strong>值</strong>:
<ul><li><code>Strict</code>: Cookie 仅在同一站点请求中发送。</li> <li><code>Lax</code>: 与 &quot;Strict&quot; 类似，但允许从外部站点导航到目标站点时发送 Cookie。</li> <li><code>None</code>: Cookie 在所有内容下都会发送。</li></ul></li> <li><strong>示例</strong>: <code>SameSite=Lax</code></li></ul> <h3 id="cookie常用字段"><a href="#cookie常用字段" class="header-anchor">#</a> cookie常用字段</h3> <p><strong>Name</strong>:</p> <ul><li>描述: Cookie 的名称。与其值一起，这构成了 Cookie 的主要部分。</li> <li>示例: <code>username=JohnDoe</code></li></ul> <p><strong>Value</strong>:</p> <ul><li>描述: Cookie 的值，与其名称对应。</li> <li>示例: <code>username=JohnDoe</code></li></ul> <p><strong>Domain</strong>:</p> <ul><li>描述: 定义了哪些域可以接收 Cookie。</li> <li>默认: 如果未设置，则默认为设置 Cookie 的域。</li> <li>示例: <code>.example.com</code> 可以匹配 <code>sub.example.com</code> 和 <code>example.com</code></li></ul> <p><strong>Path</strong>:</p> <ul><li>描述: 定义了域中的哪些路径可以接收 Cookie。</li> <li>默认: 如果未设置，则默认为设置 Cookie 的路径。</li> <li>示例: 如果路径为 <code>/blog</code>，则只有 <code>/blog</code> 下的页面可以访问该 Cookie。</li></ul> <p><strong>Expires</strong>:</p> <ul><li>描述: 指定 Cookie 的过期日期和时间。</li> <li>默认: 如果未设置，则 Cookie 会在浏览器会话结束时过期。</li> <li>示例: <code>Fri, 31 Dec 2021 23:59:59 GMT</code></li></ul> <p><strong>Max-Age</strong>:</p> <ul><li>描述: 定义从 Cookie 被设置或更新开始，Cookie 存活的秒数。</li> <li>示例: <code>3600</code> 表示 Cookie 将在 1 小时后过期。</li></ul> <p><strong>Secure</strong>:</p> <ul><li>描述: 该属性指示 Cookie 仅应通过 HTTPS 协议传输。</li> <li>默认: 如果不设置，Cookie 可以在任何协议上被传输。</li> <li>示例: <code>Secure</code></li></ul> <p><strong>HttpOnly</strong>:</p> <ul><li>描述: 指示 Cookie 不应该通过客户端 JavaScript 被访问。</li> <li>默认: 如果不设置，Cookie 可以通过 JavaScript 的 <code>document.cookie</code> 访问。</li> <li>示例: <code>HttpOnly</code></li></ul> <p><strong>SameSite</strong>:</p> <ul><li>描述: 允许服务器要求某个 Cookie 在跨站请求中不得随请求一同发送，这可以减少跨站请求伪造攻击。</li> <li>值:
<ul><li><code>Strict</code>: Cookie 仅在同一站点请求中发送。</li> <li><code>Lax</code>: 与 &quot;Strict&quot; 类似，但允许从外部站点导航到目标站点时发送 Cookie。</li> <li><code>None</code>: Cookie 在所有内容下都会发送。</li></ul></li> <li>示例: <code>SameSite=Lax</code></li></ul> <h3 id="token和cookie怎么处理的"><a href="#token和cookie怎么处理的" class="header-anchor">#</a> token和cookie怎么处理的</h3> <p><strong>token处理</strong></p> <ul><li><strong>定义</strong>: Token是一种用于身份验证的简短、加密的字符串。</li> <li><strong>生成</strong>:
<ol><li>用户登录成功后，服务器会生成一个Token。</li> <li>通常会使用JWT (JSON Web Tokens) 或其他技术来生成Token。</li></ol></li> <li><strong>使用</strong>:
<ol><li>一旦Token生成，它将被发送回客户端。</li> <li>客户端将Token存储在localStorage、sessionStorage或cookies中。</li> <li>每次发送请求到需要身份验证的API时，客户端会将Token放在请求头中。</li></ol></li> <li><strong>安全性</strong>:
<ol><li>Token应该是短暂的，具有到期时间。</li> <li>HTTPS应始终用于传输Token以确保其安全性。</li></ol></li></ul> <p><strong>cookie</strong></p> <ul><li><strong>定义</strong>: Cookie是服务器发送到用户的浏览器并存储在浏览器上的一小块数据。</li> <li><strong>设置</strong>:
<ol><li>服务器可以使用HTTP响应中的'Set-Cookie'头来设置Cookie。</li> <li>例如: <code>Set-Cookie: key=value; path=/; domain=.example.com; expires=Wed, 09 Jun 2021 10:18:14 GMT</code></li></ol></li> <li><strong>读取</strong>:
<ol><li>浏览器会自动将Cookie发送到同一个服务器的每个请求中。</li> <li>服务器可以读取Cookie来获取之前设置的值。</li></ol></li> <li><strong>使用场景</strong>:
<ol><li>会话管理 (如用户登录状态)</li> <li>个性化设置 (如用户偏好)</li> <li>跟踪分析 (如分析cookies)</li></ol></li> <li><strong>安全性</strong>:
<ol><li>使用<code>HttpOnly</code>标志，使JavaScript无法读取Cookie。</li> <li>使用<code>Secure</code>标志确保Cookie只通过HTTPS传输。</li> <li>设置正确的<code>SameSite</code>策略可以防止跨站请求伪造。</li></ol></li></ul> <h3 id="跨域请求的方法"><a href="#跨域请求的方法" class="header-anchor">#</a> 跨域请求的方法</h3> <p><strong>跨域</strong>是一个浏览器为了安全性而实施的策略，它阻止从一个域上的web页面请求另一个域上的资源。为了解决跨域问题，有以下常用的方法：</p> <ol><li><p><strong>CORS (跨来源资源共享)</strong>:</p> <ul><li>服务器设置适当的HTTP头，例如<code>Access-Control-Allow-Origin</code>，允许特定的外部域访问资源。</li> <li>可以通过设置如下HTTP头来实现：<div class="language-http line-numbers-mode"><pre class="language-http"><code><span class="token header"><span class="token header-name keyword">Access-Control-Allow-Origin</span><span class="token punctuation">:</span> <span class="token header-value">*</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div>或<div class="language-http line-numbers-mode"><pre class="language-http"><code><span class="token header"><span class="token header-name keyword">Access-Control-Allow-Origin</span><span class="token punctuation">:</span> <span class="token header-value">http://specific.domain.com</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ul></li> <li><p><strong>JSONP (JSON with Padding)</strong>:</p> <ul><li>利用<code>&lt;script&gt;</code>标签不受同源策略限制的特性。</li> <li>服务器返回一个JavaScript回调函数，客户端执行这个回调函数。</li></ul></li> <li><p><strong>使用代理服务器</strong>:</p> <ul><li>在不支持CORS的情况下，可以设置一个服务器作为请求的中间代理。</li> <li>客户端向代理服务器发送请求，代理服务器向目标服务器发送请求，然后返回响应给客户端。</li></ul></li> <li><p><strong>Document.domain</strong>:</p> <ul><li>仅适用于子域问题。</li> <li>如果两个页面设置了相同的<code>document.domain</code>值，那么这两个页面之间就可以共享资源。</li></ul></li> <li><p><strong>PostMessage</strong>:</p> <ul><li>用于安全地实现跨文档消息传递。</li> <li>可以在两个窗口或iframe之间发送消息，不受同源策略限制。</li></ul></li> <li><p><strong>WebSockets</strong>:</p> <ul><li>WebSocket不受同源策略限制。</li> <li>可以使用WebSocket API与任何WebSocket服务器通信，而不必考虑跨域问题。</li></ul></li> <li><p><strong>CNAME</strong>:</p> <ul><li>使用CNAME记录，将API的子域重定向到主域。</li> <li>这样，API请求就不再是跨域的。</li></ul></li></ol> <h3 id="怎么解决做项目遇到跨域问题-nginx代理服务器为什么能解决问题"><a href="#怎么解决做项目遇到跨域问题-nginx代理服务器为什么能解决问题" class="header-anchor">#</a> 怎么解决做项目遇到跨域问题，nginx代理服务器为什么能解决问题</h3> <p>当您在项目中遇到跨域问题时，可以采用以下方法来解决：</p> <ol><li><p><strong>CORS (跨来源资源共享)</strong>:</p> <ul><li>在服务器端配置适当的CORS响应头。</li> <li>例如，通过设置<code>Access-Control-Allow-Origin</code>为特定域或<code>*</code>来允许跨域请求。</li></ul></li> <li><p><strong>使用代理服务器（如nginx）</strong>:</p> <ul><li>代理服务器可以接收来自前端的请求，然后代表前端向目标服务器发送请求。</li> <li>由于前端和代理服务器通常在同一域下，因此不会出现跨域问题。</li> <li>代理服务器与目标服务器之间的通信并不受浏览器同源策略的限制。</li></ul></li> <li><p><strong>其他方法</strong>:</p> <ul><li>JSONP、WebSockets、PostMessage等。</li> <li>这些方法可能适用于特定情境，但它们通常不如CORS或代理服务器方法通用或安全。
使用nginx代理服务器可以解决跨域问题的原理如下：</li></ul></li></ol> <ul><li><strong>浏览器的同源策略</strong>:
<ul><li>浏览器为了安全性，不允许不同源的页面执行某些类型的代码，特别是XMLHttpRequest。</li> <li>同源策略检查协议、域名和端口，所有三者必须相同，才被认为是同一来源。</li></ul></li> <li><strong>代理工作原理</strong>:
<ul><li>当使用nginx作为代理时，前端应用程序将请求发送到nginx。</li> <li>nginx然后向实际的后端服务器转发这些请求，并从后端服务器获取响应。</li> <li>nginx接收到响应后，再将其转发回前端应用程序。</li></ul></li> <li><strong>避免浏览器限制</strong>:
<ul><li>因为前端应用程序直接与nginx通信（它们通常在同一个源上），所以浏览器的同源策略不会阻止这种通信。</li> <li>由于nginx与后端服务器的通信不是在浏览器中进行的，所以它不受同源策略的影响。</li></ul></li> <li><strong>配置简化</strong>:
<ul><li>在nginx中，可以为不同的路径或端点设置不同的代理规则。</li> <li>这使得前端开发人员可以将所有请求发送到同一个域（即nginx），而不用担心跨域问题。
因此，通过上述方式，nginx代理成功地绕过了浏览器的同源策略，从而解决了跨域问题。</li></ul></li></ul> <h3 id="cors跨域原理-前后端需要做什么-通过设置字段来实现跨域"><a href="#cors跨域原理-前后端需要做什么-通过设置字段来实现跨域" class="header-anchor">#</a> cors跨域原理，前后端需要做什么？通过设置字段来实现跨域</h3> <p><strong>CORS原理</strong>:</p> <ul><li><strong>基本思路</strong>:
当浏览器需要执行跨域请求时，它会在请求头中添加一个<code>Origin</code>字段，表示请求来源。
服务器检查这个来源，并决定是否允许这个跨域请求。如果允许，服务器会在响应头中添加一个<code>Access-Control-Allow-Origin</code>字段。</li> <li><strong>简单请求与预检请求</strong>:
不是所有的跨域请求都相同。某些请求，如GET和HEAD，被认为是“简单请求”。它们不会触发预检请求。
而更复杂的请求，如POST或带有自定义头的请求，可能会首先发送一个预检请求（使用HTTP OPTIONS方法）来询问服务器是否允许该请求。</li></ul> <p><strong>前后端需要做什么</strong>:</p> <ol><li><strong>前端</strong>:</li></ol> <ul><li>当使用XMLHttpRequest或Fetch API进行跨域请求时，无需做特殊配置，浏览器会自动处理。</li> <li>如果需要处理带凭证的请求，如cookies或基本认证信息，必须设置<code>withCredentials</code>为<code>true</code>。</li> <li>例如，在XMLHttpRequest中：</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span>withCredentials <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ol start="2"><li><strong>后端</strong>:</li></ol> <ul><li>根据前端请求头中的<code>Origin</code>字段，决定是否允许跨域请求。</li> <li>在响应头中设置相应的CORS头。常见的CORS头有：
<ul><li><code>Access-Control-Allow-Origin</code>: 指定允许的源。</li> <li><code>Access-Control-Allow-Methods</code>: 指定允许的HTTP方法。</li> <li><code>Access-Control-Allow-Headers</code>: 指定允许的请求头字段。</li> <li><code>Access-Control-Allow-Credentials</code>: 表示是否允许发送Cookie。</li></ul></li> <li>例如，为所有来源允许跨域请求：</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code>Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Origin<span class="token operator">:</span> <span class="token operator">*</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>通过设置字段来实现跨域</strong>:</p> <ul><li><strong>指定允许的来源</strong>:
如果只想允许特定的来源进行跨域请求，可以指定<code>Access-Control-Allow-Origin</code>为特定的URL，而不是<code>*</code>。</li> <li><strong>处理预检请求</strong>:
对于需要预检的请求，服务器也必须响应OPTIONS请求，并在响应头中包含相应的CORS头。</li></ul> <p>请注意，只使用<code>Access-Control-Allow-Origin: *</code>可能存在安全风险，因为它允许任何来源的请求。最好只允许已知的、可信的源进行跨域请求。</p> <h3 id="http状态码"><a href="#http状态码" class="header-anchor">#</a> HTTP状态码</h3> <ol><li><strong>1xx (信息性)</strong>: 这类状态码表示请求已被接收，需要继续处理。
<ul><li><code>100</code> Continue</li> <li><code>101</code> Switching Protocols</li> <li><code>102</code> Processing (WebDAV)</li></ul></li> <li><strong>2xx (成功)</strong>: 这类状态码表示请求已成功被服务器接收、理解、并接受。
<ul><li><code>200</code> OK</li> <li><code>201</code> Created</li> <li><code>202</code> Accepted</li> <li><code>203</code> Non-Authoritative Information</li> <li><code>204</code> No Content</li> <li><code>205</code> Reset Content</li> <li><code>206</code> Partial Content</li> <li><code>207</code> Multi-Status (WebDAV)</li> <li><code>208</code> Already Reported (WebDAV)</li></ul></li> <li><strong>3xx (重定向)</strong>: 这类状态码表示需要进一步的操作来完成请求。
<ul><li><code>300</code> Multiple Choices</li> <li><code>301</code> Moved Permanently</li> <li><code>302</code> Found</li> <li><code>303</code> See Other</li> <li><code>304</code> Not Modified</li> <li><code>305</code> Use Proxy</li> <li><code>307</code> Temporary Redirect</li> <li><code>308</code> Permanent Redirect</li></ul></li> <li><strong>4xx (客户端错误)</strong>: 这类的状态码表示请求包含错误语法或不能被执行。
<ul><li><code>400</code> Bad Request</li> <li><code>401</code> Unauthorized</li> <li><code>402</code> Payment Required</li> <li><code>403</code> Forbidden</li> <li><code>404</code> Not Found</li> <li><code>405</code> Method Not Allowed</li> <li><code>406</code> Not Acceptable</li> <li><code>407</code> Proxy Authentication Required</li> <li><code>408</code> Request Timeout</li> <li><code>409</code> Conflict</li> <li><code>410</code> Gone</li> <li><code>411</code> Length Required</li> <li><code>412</code> Precondition Failed</li> <li><code>413</code> Payload Too Large</li> <li><code>414</code> URI Too Long</li> <li><code>415</code> Unsupported Media Type</li> <li><code>416</code> Range Not Satisfiable</li> <li><code>417</code> Expectation Failed</li> <li><code>418</code> I'm a teapot (RFC 2324 joke status)</li> <li><code>421</code> Misdirected Request</li> <li><code>422</code> Unprocessable Entity (WebDAV)</li> <li><code>423</code> Locked (WebDAV)</li> <li><code>424</code> Failed Dependency (WebDAV)</li> <li><code>426</code> Upgrade Required</li> <li><code>428</code> Precondition Required</li> <li><code>429</code> Too Many Requests</li> <li><code>431</code> Request Header Fields Too Large</li> <li><code>451</code> Unavailable For Legal Reasons</li></ul></li> <li><strong>5xx (服务器错误)</strong>: 这类状态码表示服务器在尝试处理请求时发生内部错误。
<ul><li><code>500</code> Internal Server Error</li> <li><code>501</code> Not Implemented</li> <li><code>502</code> Bad Gateway</li> <li><code>503</code> Service Unavailable</li> <li><code>504</code> Gateway Timeout</li> <li><code>505</code> HTTP Version Not Supported</li> <li><code>506</code> Variant Also Negotiates</li> <li><code>507</code> Insufficient Storage (WebDAV)</li> <li><code>508</code> Loop Detected (WebDAV)</li> <li><code>510</code> Not Extended</li> <li><code>511</code> Network Authentication Required</li></ul></li></ol> <h3 id="与缓存有关的状态码"><a href="#与缓存有关的状态码" class="header-anchor">#</a> 与缓存有关的状态码</h3> <ul><li><strong>200 OK</strong>
当客户端发送一个带有<code>If-Modified-Since</code>或<code>If-None-Match</code>头的请求，但内容已经更改时，服务器可能会返回一个完整的响应并附带<code>200 OK</code>状态码。</li> <li><strong>304 Not Modified</strong>
如果客户端之前已经请求过资源并保留了一个副本，并且现在它发送了一个带有<code>If-Modified-Since</code>或<code>If-None-Match</code>头的请求，如果资源自那时起没有更改，服务器将响应<code>304 Not Modified</code>，这告诉客户端可以使用其缓存的版本。</li> <li><strong>206 Partial Content</strong>
当客户端请求资源的一部分（例如，当执行断点续传或视频流）时，服务器可能返回<code>206 Partial Content</code>状态码和请求的数据部分。
此外，处理缓存的常见HTTP头包括：Cache-Control, ETag, Last-Modified, If-Modified-Since, If-None-Match, Expires, Pragma等。正确使用这些头可以帮助您优化缓存行为并提高应用程序的性能。</li></ul> <h3 id="http状态码-302、404、500、304"><a href="#http状态码-302、404、500、304" class="header-anchor">#</a> http状态码：302、404、500、304</h3> <ul><li><strong>302 Found (也经常被称为临时重定向)</strong>
这个状态码表示请求的资源已经临时被移动到了新的位置，并且未来可能会再次更改。浏览器通常会自动地重定向到新的位置，但是不会将这个新位置视为一个新的书签或链接。</li> <li><strong>304 Not Modified</strong>
这个状态码是在客户端使用条件请求头（如<code>If-None-Match</code>或<code>If-Modified-Since</code>）时返回的，表示自上次客户端请求资源以来，资源没有发生修改。浏览器会使用缓存中的版本，而不是重新下载资源。</li> <li><strong>404 Not Found</strong>
服务器无法找到所请求的资源。在Web上，这通常是指服务器无法找到所请求的页面。它是一个客户端的错误状态码，表示您尝试访问的页面不存在。</li> <li><strong>500 Internal Server Error</strong>
服务器遇到了一个未知的错误，导致无法完成客户端的请求。这是一个服务器错误状态码，表示服务器上发生了一些问题，但是无法具体地确定是什么问题。</li></ul> <h3 id="http的缓存机制"><a href="#http的缓存机制" class="header-anchor">#</a> HTTP的缓存机制</h3> <p>HTTP缓存是一种性能优化机制，通过存储资源的副本来避免不必要的数据传输和资源生成，从而提高网页加载速度和减少服务器负载。
<strong>1. 强缓存与协商缓存</strong></p> <ul><li><strong>强缓存</strong>:
浏览器直接使用本地缓存的资源，不与服务器进行通信。相关的HTTP头有：
<ul><li><code>Cache-Control</code>: 可以设置为<code>max-age</code> (指定资源可以被缓存的时间长度)。</li> <li><code>Expires</code>: 设置资源的过期日期和时间。</li></ul></li> <li><strong>协商缓存</strong>:
浏览器与服务器通信，判断资源是否发生变化，如果没有变化，服务器返回<code>304 Not Modified</code>状态码，浏览器使用本地缓存；否则，服务器返回新的资源和<code>200 OK</code>状态码。相关的HTTP头有：
<ul><li><code>Last-Modified</code>: 资源的最后修改时间。</li> <li><code>If-Modified-Since</code>: 客户端发送上次收到的<code>Last-Modified</code>值，服务器通过比较来决定资源是否已更改。</li> <li><code>ETag</code>: 资源的版本标记。</li> <li><code>If-None-Match</code>: 客户端发送上次收到的<code>ETag</code>值，服务器使用这个头来比较资源是否已更改。</li></ul></li></ul> <p><strong>2. Cache-Control指令</strong></p> <ul><li><code>public</code>: 资源可以被所有用户缓存，包括在中间代理服务器中。</li> <li><code>private</code>: 资源只为单个用户缓存，如在个人的浏览器中。</li> <li><code>no-cache</code>: 资源在缓存之前必须确认其有效性。</li> <li><code>no-store</code>: 不允许缓存资源。</li> <li><code>must-revalidate</code>: 一旦资源过期，缓存必须向服务器重新验证。</li></ul> <p><strong>3. 使用代理服务器的缓存</strong>
CDN（内容分发网络）和其他代理服务器也可以缓存内容。它们通常使用HTTP头如<code>Cache-Control</code>和<code>Expires</code>来决定如何缓存和重新验证资源。</p> <p><strong>4. Vary响应头</strong> <code>Vary</code>头部告诉缓存系统，响应内容是基于哪些请求头进行变化的。例如，响应可以基于用户代理或接受的语言进行变化。</p> <h3 id="http缓存-设置强缓存有效期"><a href="#http缓存-设置强缓存有效期" class="header-anchor">#</a> http缓存（设置强缓存有效期）</h3> <p>当服务器要设置强缓存有效期时，可以在HTTP响应头中添加Cache-Control字段来定义缓存策略。以下是一个示例：
假设服务器返回一个名为example.jpg的图片资源，并设置其缓存有效期为1小时：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>HTTP/1.1 200 OK
Content-Type: image/jpeg
Cache-Control: max-age=3600
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="浏览器本地缓存机制"><a href="#浏览器本地缓存机制" class="header-anchor">#</a> 浏览器本地缓存机制</h3> <p><strong>1. HTTP缓存</strong></p> <ul><li>浏览器根据响应头信息（如<code>Cache-Control</code>, <code>Expires</code>, <code>ETag</code>, <code>Last-Modified</code>）决定是否将资源缓存在本地。</li> <li>在下次请求这些资源时，如果资源处于有效期内，浏览器直接从本地缓存加载。</li></ul> <p><strong>2. Cookie</strong></p> <ul><li>由服务器发送并存储在浏览器中的小段数据，通常用于持久化会话和存储用户偏好。</li> <li>由于Cookie随每次HTTP请求发送到服务器，因此应限制其大小和数量。</li></ul> <p><strong>3. Web Storage (LocalStorage &amp; SessionStorage)</strong></p> <ul><li><code>LocalStorage</code>: 持久性存储，直到手动删除或浏览器策略决定删除。</li> <li><code>SessionStorage</code>: 会话存储，当浏览器窗口或标签页关闭时自动删除。</li> <li>为网站提供了更多的存储空间和更好的性能，因为它不像Cookie那样随每次请求发送。</li></ul> <p><strong>4. IndexedDB</strong></p> <ul><li>一个低级API，用于存储大量结构化数据。</li> <li>允许高性能、异步的读写操作。</li></ul> <p><strong>5. Cache API</strong></p> <ul><li>通过Service Workers使用，使您能够显式地缓存资源，非常适用于构建Progressive Web Apps (PWAs)。</li> <li>提供更细粒度的资源缓存控制。</li></ul> <p><strong>6. Web SQL Database (已废弃)</strong></p> <ul><li>一种保存结构化数据的方式，使用SQL进行查询。</li> <li>由于标准化问题，已被废弃，不推荐使用。</li></ul> <p><strong>7. Application Cache (已废弃)</strong></p> <ul><li>是一个为网页提供离线访问的机制。</li> <li>由于存在多个问题和局限性，已被Service Workers和Cache API所取代。</li></ul> <h3 id="强缓存和协商缓存什么区别-如何设置"><a href="#强缓存和协商缓存什么区别-如何设置" class="header-anchor">#</a> 强缓存和协商缓存什么区别？如何设置？</h3> <h4 id="区别"><a href="#区别" class="header-anchor">#</a> 区别</h4> <p><strong>强缓存 (Strong Cache)</strong></p> <ul><li>当资源被强缓存时，浏览器不会发送请求到服务器来获取该资源，而是直接从本地缓存（如磁盘或内存）中读取资源。</li> <li>强缓存不会考虑资源在服务器上是否已经更新，直到本地的缓存过期。</li></ul> <p><strong>协商缓存 (Negotiated Cache)</strong></p> <ul><li>协商缓存需要浏览器向服务器发送请求，询问资源是否有更新。</li> <li>如果资源在服务器上没有更新，服务器会返回一个<code>304 Not Modified</code>状态码，告诉浏览器它可以使用本地的缓存版本。</li> <li>如果资源有更新，服务器会返回新的资源和<code>200 OK</code>状态码。</li></ul> <h4 id="如何设置"><a href="#如何设置" class="header-anchor">#</a> 如何设置</h4> <p><strong>强缓存设置</strong></p> <ul><li>使用<code>Cache-Control</code>响应头:
<ul><li><code>Cache-Control: max-age=&lt;seconds&gt;</code>: 定义资源在浏览器中缓存的最大时间（单位为秒）。</li> <li><code>Cache-Control: no-cache</code>: 要求每次都进行协商缓存，但资源仍可以被缓存。</li> <li><code>Cache-Control: no-store</code>: 完全禁止缓存。</li></ul></li> <li>使用<code>Expires</code>响应头 (较为老旧，但仍被许多浏览器支持):
<ul><li><code>Expires: &lt;date&gt;</code>: 设置资源的过期日期和时间。</li></ul></li></ul> <p><strong>协商缓存设置</strong></p> <ul><li>使用<code>Last-Modified</code>和<code>If-Modified-Since</code>头:
<ul><li>服务器首次响应时返回<code>Last-Modified: &lt;date&gt;</code>，标明资源最后修改的时间。</li> <li>浏览器在随后的请求中带上<code>If-Modified-Since: &lt;date&gt;</code>头，询问该时间之后资源是否有更新。</li></ul></li> <li>使用<code>ETag</code>和<code>If-None-Match</code>头:
<ul><li>服务器首次响应时返回<code>ETag: &lt;hash value&gt;</code>，标明资源的一个版本标识。</li> <li>浏览器在随后的请求中带上<code>If-None-Match: &lt;hash value&gt;</code>头，询问资源是否有新的版本。</li></ul></li></ul> <h3 id="协商缓存的过程"><a href="#协商缓存的过程" class="header-anchor">#</a> 协商缓存的过程</h3> <p>协商缓存的核心思想是，当客户端想要加载资源时，它会询问服务器资源是否已经更新。如果资源没有更新，服务器只返回一个小的确认消息，指示客户端可以使用其本地缓存的版本；如果资源已经更新，服务器会返回新的资源给客户端。以下是协商缓存的详细过程：
<strong>1. 初始请求</strong></p> <ul><li>用户首次访问某个资源时，服务器返回该资源，并在响应头中添加标识资源版本的信息，这可以是<code>Last-Modified</code>时间戳或<code>ETag</code>的值。</li></ul> <p><strong>2. 再次请求</strong></p> <ul><li>当用户再次请求相同的资源时，浏览器会检查之前存储的协商缓存相关的头部信息，并将其附加到请求头中，使用<code>If-Modified-Since</code>或<code>If-None-Match</code>。</li></ul> <p><strong>3. 服务器验证</strong></p> <ul><li>服务器收到请求后，会根据请求头中的信息（<code>If-Modified-Since</code>或<code>If-None-Match</code>）来判断资源是否已经更改。
<ul><li>使用<code>Last-Modified</code>和<code>If-Modified-Since</code>：服务器比较请求头中的时间戳与资源的最后修改时间。</li> <li>使用<code>ETag</code>和<code>If-None-Match</code>：服务器比较请求头中的ETag值与当前资源的ETag值。</li></ul></li></ul> <p><strong>4. 返回响应</strong></p> <ul><li>如果资源没有发生变化：
<ul><li>服务器返回<code>304 Not Modified</code>状态码。</li> <li>浏览器使用本地缓存的资源版本。</li></ul></li> <li>如果资源发生了变化：
<ul><li>服务器返回新的资源以及<code>200 OK</code>状态码。</li> <li>同时，新的<code>Last-Modified</code>和/或<code>ETag</code>值也会返回给客户端，供下次使用。</li></ul></li></ul> <h3 id="协商缓存需要用到哪些状态码"><a href="#协商缓存需要用到哪些状态码" class="header-anchor">#</a> 协商缓存需要用到哪些状态码</h3> <p>在决定何时使用强缓存或协商缓存时，我们需要考虑文件的更新频率、文件大小以及影响的范围。以下是HTML文件和JS文件缓存策略的一些建议：
<strong>1. 304 Not Modified</strong></p> <ul><li>当浏览器发送请求并包含协商缓存的相关头部信息（如<code>If-Modified-Since</code>或<code>If-None-Match</code>）时，如果服务器判断资源没有发生变化，它会返回<code>304 Not Modified</code>状态码。</li> <li>这告诉浏览器它可以安全地使用本地缓存的版本，而无需重新下载整个资源。</li></ul> <p><strong>2. 200 OK</strong></p> <ul><li>如果浏览器发送了协商缓存的相关头部信息，但服务器判断资源已经发生变化（或首次请求，没有相关缓存头），它会返回整个资源内容，并附带<code>200 OK</code>状态码。</li> <li>同时，响应通常会包含新的协商缓存相关的头部信息（如更新的<code>Last-Modified</code>或新的<code>ETag</code>值）。
在协商缓存的过程中，304 Not Modified状态码是最为关键的，它明确表示资源自上次请求以来没有发生变化，因此浏览器应继续使用其本地缓存版本。</li></ul> <h3 id="html文件js文件-哪些用强缓存-哪些用协商缓存-为什么。"><a href="#html文件js文件-哪些用强缓存-哪些用协商缓存-为什么。" class="header-anchor">#</a> html文件js文件，哪些用强缓存，哪些用协商缓存，为什么。</h3> <p><strong>HTML文件</strong></p> <ul><li><strong>协商缓存</strong>: HTML文件通常作为应用或网站的入口点，经常包含最新的结构或内容。如果HTML文件被强缓存并且内容发生了变化，用户可能会看到过时的页面内容或布局，这可能会导致错误或不良的用户体验。因此，使用协商缓存可以确保用户总是得到最新的HTML内容，同时在内容没有更改时利用本地缓存来提高加载速度。</li></ul> <p><strong>JS文件</strong></p> <ul><li><strong>强缓存</strong>: JS文件，特别是库或框架，如果不经常更改，可以使用强缓存来提高加载速度。当你知道某个JS文件会长时间保持不变时，强缓存是合适的。</li> <li><strong>协商缓存</strong>: 对于经常更改的JS文件或关键的应用逻辑，使用协商缓存可能更为合适。这可以确保用户总是加载到最新的JS版本，但如果文件没有更改，可以避免不必要的数据传输。</li></ul> <p><strong>附加建议</strong></p> <ul><li>为JS文件添加版本号或内容散列到其文件名（例如<code>script-v1.2.3.js</code>或<code>script-abc123.js</code>）可以更有效地使用强缓存。当文件内容更改时，文件名也会更改，从而使浏览器请求新版本的文件。这种策略允许你充分利用强缓存，同时确保用户加载到最新的文件版本。</li></ul> <h3 id="浏览器的事件"><a href="#浏览器的事件" class="header-anchor">#</a> 浏览器的事件</h3> <p>浏览器中的事件代表了文档或浏览器窗口中发生的一次特定交互。这些事件可以是由用户触发的（例如点击一个按钮）或者由API生成的（例如页面完成加载后）。下面是使用Markdown代码模式列出的一些常见的浏览器事件：
<strong>鼠标事件</strong></p> <ul><li><code>click</code>: 当元素被鼠标点击时触发。</li> <li><code>dblclick</code>: 当元素被鼠标双击时触发。</li> <li><code>mousedown</code>: 当按下鼠标按钮时触发。</li> <li><code>mouseup</code>: 当释放鼠标按钮时触发。</li> <li><code>mousemove</code>: 当鼠标移动时触发。</li> <li><code>mouseover</code>: 当鼠标移动到一个元素上方时触发。</li> <li><code>mouseout</code>: 当鼠标移出一个元素时触发。</li> <li><code>mouseenter</code>: 当鼠标进入一个元素时触发（不冒泡）。</li> <li><code>mouseleave</code>: 当鼠标离开一个元素时触发（不冒泡）。</li> <li><code>contextmenu</code>: 当用户尝试打开上下文菜单时触发（通常是右键点击）。</li></ul> <p><strong>键盘事件</strong></p> <ul><li><code>keydown</code>: 当按下一个键时触发。</li> <li><code>keyup</code>: 当释放一个键时触发。</li> <li><code>keypress</code>: 当按下并释放一个键时触发（通常用于字符输入）。</li></ul> <p><strong>表单事件</strong></p> <ul><li><code>submit</code>: 当表单提交时触发。</li> <li><code>reset</code>: 当表单重置时触发。</li> <li><code>change</code>: 当表单控件的值改变时触发。</li> <li><code>input</code>: 当用户输入数据时触发。</li> <li><code>focus</code>: 当元素获得焦点时触发。</li> <li><code>blur</code>: 当元素失去焦点时触发。</li></ul> <p><strong>窗口事件</strong></p> <ul><li><code>load</code>: 当文档或图片完成加载时触发。</li> <li><code>unload</code>: 当文档被完全卸载时触发。</li> <li><code>beforeunload</code>: 当窗口或文档即将卸载时触发。</li> <li><code>resize</code>: 当浏览器窗口大小改变时触发。</li> <li><code>scroll</code>: 当用户滚动指定的元素或窗口时触发。</li></ul> <p><strong>其他常见事件</strong></p> <ul><li><code>drag</code>: 当元素被拖拽时触发。</li> <li><code>drop</code>: 当元素在目标上被释放时触发。</li> <li><code>touchstart</code>: 当手指触摸屏幕时触发。</li> <li><code>touchmove</code>: 当手指在屏幕上移动时触发。</li> <li><code>touchend</code>: 当手指从屏幕上离开时触发。</li> <li><code>transitionend</code>: 当CSS过渡完成时触发。</li> <li><code>animationend</code>: 当CSS动画完成时触发。</li></ul> <h3 id="浏览器多进程有哪些"><a href="#浏览器多进程有哪些" class="header-anchor">#</a> 浏览器多进程有哪些</h3> <p>浏览器采用多进程架构来增强性能和稳定性。以下是浏览器中的多进程组件：
<strong>1. 主进程 (Browser Process)</strong></p> <ul><li>负责浏览器的UI，如导航栏、标签栏、书签栏等。</li> <li>负责处理用户输入，与渲染进程和插件进程的交互。</li> <li>负责存储和文件系统的操作。</li></ul> <p><strong>2. 渲染进程 (Renderer Process)</strong></p> <ul><li>每个标签页（或浏览上下文）一般对应一个渲染进程。</li> <li>负责解析HTML、CSS、JavaScript，生成页面的视觉表示。</li> <li>隔离的设计可以确保一个页面的崩溃不会影响其他标签页。</li></ul> <p><strong>3. 插件进程 (Plugin Process)</strong></p> <ul><li>对于使用NPAPI或其他旧式插件技术的插件（如Flash），每个插件实例都有一个对应的进程。</li> <li>这种隔离可以提高稳定性，防止插件崩溃时影响到浏览器主进程或其他渲染进程。</li></ul> <p><strong>4. GPU进程</strong></p> <ul><li>负责处理GPU相关的任务，如页面的硬件加速渲染。</li> <li>通过单独的GPU进程，浏览器可以更有效地利用图形硬件，同时也提高了稳定性。</li></ul> <p><strong>5. 网络进程</strong></p> <ul><li>负责处理网络请求，如HTTP请求。</li> <li>分离网络处理到独立的进程可以提高性能，特别是在多标签浏览的场景中。</li></ul> <p><strong>6. 扩展进程 (仅在支持扩展的浏览器中)</strong></p> <ul><li>对于像Chrome这样支持浏览器扩展的浏览器，每个扩展可能都有一个或多个独立的进程。</li> <li>这种隔离可以提高安全性和稳定性。</li></ul> <h3 id="filereader、blob、arraybuffer、typedbuffer、怎么保证上传顺序和并发控制"><a href="#filereader、blob、arraybuffer、typedbuffer、怎么保证上传顺序和并发控制" class="header-anchor">#</a> FileReader、BLob、ArrayBuffer、Typedbuffer、怎么保证上传顺序和并发控制</h3> <p><strong>并发控制和保证上传顺序</strong></p> <ul><li><strong>Promise和async/await</strong>: 使用<code>Promise</code>链或<code>async/await</code>可以确保异步操作（如文件上传）按预期的顺序执行。</li> <li><strong>并发队列</strong>: 使用队列来管理并发上传。例如，可以同时上传3个文件，完成一个再添加另一个，这样可以保证不超过3个文件的并发限制。</li> <li><strong>Promise.all</strong>: 如果想要并发上传多个文件但等待它们全部完成，可以使用<code>Promise.all()</code>。</li></ul> <h2 id="html"><a href="#html" class="header-anchor">#</a> html</h2> <h3 id="html5新增特性"><a href="#html5新增特性" class="header-anchor">#</a> html5新增特性</h3> <p><strong>1. 语义元素</strong>:</p> <ul><li><code>&lt;article&gt;</code>: 定义外部内容。</li> <li><code>&lt;aside&gt;</code>: 定义页面的侧边栏内容。</li> <li><code>&lt;details&gt;</code>: 为用户创建一个可点击的小部件，显示/隐藏详细信息。</li> <li><code>&lt;figcaption&gt;</code>: 定义<code>&lt;figure&gt;</code>元素的标题。</li> <li><code>&lt;figure&gt;</code>: 规定自包含的内容，如插图、图表、照片、代码清单等。</li> <li><code>&lt;footer&gt;</code>: 定义文档或部分的页脚。</li> <li><code>&lt;header&gt;</code>: 定义文档或部分的页眉。</li> <li><code>&lt;main&gt;</code>: 规定文档的主内容。</li> <li><code>&lt;mark&gt;</code>: 定义被标记或突出显示的文本。</li> <li><code>&lt;nav&gt;</code>: 定义导航链接的部分。</li> <li><code>&lt;section&gt;</code>: 定义文档中的独立部分。</li> <li><code>&lt;summary&gt;</code>: 定义<code>&lt;details&gt;</code>元素的标题。</li> <li><code>&lt;time&gt;</code>: 定义日期/时间。</li></ul> <p><strong>2. 图形和多媒体元素</strong>:</p> <ul><li><code>&lt;canvas&gt;</code>: 用于图形绘制，通过JavaScript绘制2D图形。</li> <li><code>&lt;svg&gt;</code>: 描述二维向量图形的XML标记语言。</li> <li><code>&lt;audio&gt;</code>: 定义声音或音乐内容。</li> <li><code>&lt;video&gt;</code>: 定义视频或电影内容。</li> <li><code>&lt;source&gt;</code>: 定义<code>&lt;video&gt;</code>和<code>&lt;audio&gt;</code>中的多媒体资源。</li></ul> <p><strong>3. 表单改进</strong>:</p> <ul><li>新的输入类型: <code>color</code>, <code>date</code>, <code>datetime</code>, <code>datetime-local</code>, <code>email</code>, <code>month</code>, <code>number</code>, <code>range</code>, <code>search</code>, <code>tel</code>, <code>time</code>, <code>url</code>, <code>week</code>。</li> <li><code>&lt;datalist&gt;</code>: 规定输入控件的选项列表。</li> <li><code>&lt;output&gt;</code>: 定义不同类型的输出，如脚本输出。</li></ul> <p><strong>4. 新的APIs</strong>:</p> <ul><li><strong>Drag and Drop API</strong>: 允许元素可拖放。</li> <li><strong>Geolocation API</strong>: 允许用户共享他们的物理位置。</li> <li><strong>LocalStorage &amp; SessionStorage</strong>: Web存储，允许网站存储键值对的数据在浏览器中。</li> <li><strong>Web Workers</strong>: 在后台运行JavaScript，不影响页面性能。</li> <li><strong>WebSocket</strong>: 允许开放一个持续的通信通道。</li> <li><strong>File API</strong>: 允许网页读取和操作用户的本地文件。</li></ul> <p><strong>5. 其他</strong>:</p> <ul><li><code>&lt;!DOCTYPE html&gt;</code>: 新的简化的DOCTYPE声明。</li> <li><code>&lt;embed&gt;</code>: 定义容器用于外部应用或互动程序。</li> <li><code>&lt;wbr&gt;</code>: 定义在文本中的换行机会。</li> <li>跨域资源共享 (CORS): 允许Web页面请求其他域的资源。</li></ul> <p><strong>6. 已被移除或标记为过时的特性</strong>:</p> <ul><li>例如<code>&lt;frame&gt;</code>, <code>&lt;frameset&gt;</code>, <code>&lt;acronym&gt;</code>等。</li></ul> <p><strong>HTML5 新增特性总结</strong>:</p> <ol><li><strong>语义元素</strong>: 增加了如<code>&lt;article&gt;</code>, <code>&lt;nav&gt;</code>, <code>&lt;section&gt;</code>, <code>&lt;header&gt;</code>, <code>&lt;footer&gt;</code>等，用于更准确地描述内容。</li> <li><strong>图形 &amp; 多媒体</strong>: 引入了<code>&lt;canvas&gt;</code>、<code>&lt;svg&gt;</code>、<code>&lt;audio&gt;</code>、<code>&lt;video&gt;</code>等，方便地嵌入图形和多媒体内容。</li> <li><strong>表单增强</strong>: 新增了多种输入类型及元素，如<code>&lt;datalist&gt;</code>, <code>&lt;output&gt;</code>和类型为<code>date</code>, <code>email</code>, <code>range</code>等的输入。</li> <li><strong>新APIs</strong>: 包括Drag &amp; Drop、Geolocation、Web存储、Web Workers、WebSocket 和 File API，使得前端开发更加强大和灵活。</li> <li><strong>简化的DOCTYPE</strong>: 通过<code>&lt;!DOCTYPE html&gt;</code>来声明文档类型，简化了开发者的工作。</li> <li><strong>跨域资源共享</strong>: 支持CORS，增强了Web安全性和灵活性。</li> <li><strong>移除或过时的元素</strong>: 一些旧</li></ol> <h3 id="convas和svg的区别"><a href="#convas和svg的区别" class="header-anchor">#</a> convas和svg的区别</h3> <p><code>&lt;canvas&gt;</code> 和 <code>&lt;svg&gt;</code> 都是HTML5引入的，用于在浏览器中绘制图形。但它们之间有很大的不同。以下是<code>&lt;canvas&gt;</code> 和 <code>&lt;svg&gt;</code> 之间的主要区别
<strong><code>&lt;canvas&gt;</code> 与 <code>&lt;svg&gt;</code> 的区别</strong>:</p> <ol><li><strong>定义方式</strong>:
<ul><li><strong>canvas</strong>: 是基于像素的。它使用JavaScript来绘制2D图形。</li> <li><strong>svg</strong>: 是基于矢量的。SVG描述的是图形的形状和其关系，不依赖分辨率。</li></ul></li> <li><strong>DOM</strong>:
<ul><li><strong>canvas</strong>: 没有对象模型。一旦图形被绘制，它就不再是浏览器可识别的对象。要修改图形，你需要重新绘制。</li> <li><strong>svg</strong>: 每个绘制的元素都是为DOM对象，这意味着可以通过JS和CSS来互动和修改这些元素。</li></ul></li> <li><strong>性能</strong>:
<ul><li><strong>canvas</strong>: 对于大量的数据或频繁的更新，性能更好。</li> <li><strong>svg</strong>: 当处理较小数量的对象并且需要高度的互动性时，通常表现更好。</li></ul></li> <li><strong>图形类型</strong>:
<ul><li><strong>canvas</strong>: 主要用于Web游戏和其他需要复杂渲染、动画或大数据量的应用。</li> <li><strong>svg</strong>: 适用于图标、地图、信息图表等。</li></ul></li> <li><strong>支持和兼容性</strong>:
<ul><li><strong>canvas</strong>: 在所有现代浏览器中都得到很好的支持，但较老的浏览器可能需要polyfill。</li> <li><strong>svg</strong>: 也在所有现代浏览器中得到支持，并且SVG文件可以在很多桌面绘图软件中编辑。</li></ul></li> <li><strong>事件处理</strong>:
<ul><li><strong>canvas</strong>: 由于没有对象模型，不能为单独的图形元素添加事件处理器。</li> <li><strong>svg</strong>: 每个SVG元素都是可识别的DOM对象，因此可以为每个SVG元素绑定事件处理器。</li></ul></li> <li><strong>图形创建</strong>:
<ul><li><strong>canvas</strong>: 通过JavaScript代码来创建图形。</li> <li><strong>svg</strong>: 可以使用文本编辑器手动创建或使用图形软件，如Adobe Illustrator或Inkscape。</li></ul></li></ol> <h3 id="dom常见的操作-怎么绑定事件"><a href="#dom常见的操作-怎么绑定事件" class="header-anchor">#</a> DOM常见的操作，怎么绑定事件</h3> <p><strong>常见的DOM操作</strong>:</p> <ol><li><strong>选择元素</strong>:
<ul><li><code>document.getElementById('id')</code>: 根据ID获取元素</li> <li><code>document.getElementsByClassName('classname')</code>: 根据类名获取元素集合</li> <li><code>document.getElementsByTagName('tagname')</code>: 根据标签名获取元素集合</li> <li><code>document.querySelector('selector')</code>: 返回匹配指定CSS选择器的第一个元素</li> <li><code>document.querySelectorAll('selector')</code>: 返回匹配指定CSS选择器的所有元素的集合</li></ul></li> <li><strong>修改元素属性和内容</strong>:
<ul><li><code>element.setAttribute('attr', 'value')</code>: 设置属性的值</li> <li><code>element.getAttribute('attr')</code>: 获取属性的值</li> <li><code>element.removeAttribute('attr')</code>: 删除属性</li> <li><code>element.innerHTML</code>: 获取或设置元素的HTML内容</li> <li><code>element.textContent</code>: 获取或设置元素的文本内容</li></ul></li> <li><strong>创建和删除节点</strong>:
<ul><li><code>document.createElement('tagname')</code>: 创建一个新元素</li> <li><code>parentNode.appendChild(childNode)</code>: 添加一个新的子节点</li> <li><code>parentNode.removeChild(childNode)</code>: 删除一个子节点</li> <li><code>parentNode.replaceChild(newChild, oldChild)</code>: 替换子节点</li></ul></li> <li><strong>类名和样式操作</strong>:
<ul><li><code>element.classList.add('classname')</code>: 添加类名</li> <li><code>element.classList.remove('classname')</code>: 删除类名</li> <li><code>element.classList.toggle('classname')</code>: 切换类名</li> <li><code>element.style.propertyName</code>: 获取或设置CSS样式的值</li></ul></li> <li><strong>事件绑定</strong>:<div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>element<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'eventname'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 事件处理代码</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li></ol> <p>例如, 绑定一个点击事件:</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>element<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Element was clicked!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="vue"><a href="#vue" class="header-anchor">#</a> vue</h2> <h3 id="vue中用到了什么模式-前端开发主要用到了哪些框架"><a href="#vue中用到了什么模式-前端开发主要用到了哪些框架" class="header-anchor">#</a> vue中用到了什么模式?前端开发主要用到了哪些框架？</h3> <p>Vue.js 是一个渐进式的JavaScript框架，用于构建用户界面。在设计中，Vue使用了以下模式：</p> <ul><li>观察者模式 (Observer Pattern): Vue的响应式数据系统基于此模式。当对象的某些依赖（如属性）发生变化时，所有依赖这些属性的对象都会被自动更新。</li> <li>MVVM (Model-View-ViewModel): Vue采用MVVM设计模式，其中模型(Model)代表数据，视图(View)代表UI，而视图模型(ViewModel)是一个中间件，它同步View和Model，通常在Vue中是由Vue实例承担的。</li> <li>组件化模式: Vue鼓励开发者构建可复用的组件，以便在不同的部分和项目中重用它们。</li> <li>订阅发布模式 (Pub-Sub Pattern): Vue的自定义事件系统使用了这种模式，允许组件相互通信。
前端开发中常用的框架:</li> <li>Vue.js: 如上所述，它是一个渐进式的JavaScript框架，用于构建现代的Web应用程序。</li> <li>React: 由Facebook开发，它是一个用于构建用户界面的JavaScript库。</li> <li>Angular: 由Google维护的一个完整的前端开发框架，它为开发者提供了大量的工具和设计模式，以构建复杂的Web应用程序。</li> <li>Svelte: 一个相对新的框架，它在构建时将组件转换为高效的Vanilla JavaScript。</li> <li>Backbone.js: 一个轻量级的MVC框架，常用于构建单页应用。</li> <li>Ember.js: 一个声明式的框架，用于构建大型的Web应用程序。</li> <li>Preact: 与React非常相似，但体积更小，更快。</li> <li>jQuery: 虽然不是一个完整的框架，但在过去的很多年里，它是前端开发的标准库，提供了许多DOM操作和事件处理的功能</li></ul> <h3 id="vue生命周期-组件间生命周期的顺序"><a href="#vue生命周期-组件间生命周期的顺序" class="header-anchor">#</a> vue生命周期？组件间生命周期的顺序？</h3> <p><strong>Vue生命周期钩子</strong>:</p> <ol><li><strong>创建阶段</strong>:
<ul><li><code>beforeCreate</code>: 实例被创建之后，数据观察和事件配置都还未初始化。</li> <li><code>created</code>: 实例创建完成后被立即调用，此时数据观察已设定，但DOM还未生成，<code>$el</code>属性还不存在。</li></ul></li> <li><strong>挂载阶段</strong>:
<ul><li><code>beforeMount</code>: 在挂载（即将将模板插入DOM）开始之前被调用。</li> <li><code>mounted</code>: 实例被挂载到DOM后调用。此时，你可以通过<code>this.$el</code>访问到渲染的DOM。</li></ul></li> <li><strong>更新阶段</strong>:
<ul><li><code>beforeUpdate</code>: 数据更新前调用，发生在虚拟DOM重新渲染和打补丁之前。</li> <li><code>updated</code>: 由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。</li></ul></li> <li><strong>销毁阶段</strong>:
<ul><li><code>beforeDestroy</code>: 实例销毁之前调用。在这一步中，实例仍然完全可用。</li> <li><code>destroyed</code>: Vue实例销毁后调用。</li></ul></li></ol> <p><strong>组件间生命周期的顺序：</strong>
当涉及到父子组件的关系时，生命周期的执行顺序如下：</p> <ul><li>父组件 beforeCreate</li> <li>父组件 created</li> <li>父组件 beforeMount</li> <li>子组件 beforeCreate</li> <li>子组件 created</li> <li>子组件 beforeMount</li> <li>子组件 mounted</li> <li>父组件 mounted</li> <li>... (如果有数据更新，则涉及到beforeUpdate和updated钩子，首先由父组件开始，再到子组件)</li> <li>父组件 beforeDestroy</li> <li>子组件 beforeDestroy</li> <li>子组件 destroyed</li> <li>父组件 destroyed
这种顺序确保了父组件的逻辑在子组件之前运行，但是子组件的DOM在父组件之前渲染。</li></ul> <h3 id="vue的history模式和hash模式有什么区别-为什么history会出现404"><a href="#vue的history模式和hash模式有什么区别-为什么history会出现404" class="header-anchor">#</a> vue的history模式和hash模式有什么区别，为什么history会出现404？</h3> <p><strong>Vue Router的模式</strong>:</p> <ol><li><strong>Hash模式 (<code>hash</code>)</strong>:
<ul><li><strong>URL结构</strong>: <code>http://domain.com/#/your-route</code></li> <li><strong>原理</strong>: 利用URL中的hash (<code>#</code>之后的部分)来表示路由。当hash改变时，不会重新加载页面。</li> <li><strong>优点</strong>:
<ul><li>不需要额外的服务器配置。</li> <li>在所有浏览器中都可以工作，包括不支持HTML5 History API的浏览器。</li></ul></li> <li><strong>缺点</strong>:
<ul><li>URL中的hash部分可能在某些情况下看起来不太美观。</li></ul></li></ul></li> <li><strong>History模式 (<code>history</code>)</strong>:
<ul><li><strong>URL结构</strong>: <code>http://domain.com/your-route</code></li> <li><strong>原理</strong>: 利用HTML5 History API来控制路由。这允许使用标准URL而不需要hash。</li> <li><strong>优点</strong>:
<ul><li>URL看起来更加清晰和传统。</li></ul></li> <li><strong>缺点</strong>:
<ul><li>需要服务器端的配置。如果没有适当的服务器配置，用户可能会看到404错误。</li></ul></li></ul></li></ol> <p><strong>为什么history模式会出现404：</strong>
当使用history模式时，URL看起来像普通的URL。这意味着，当用户直接输入URL或刷新页面时，浏览器会尝试请求该URL对应的服务器路径。如果服务器没有为该路径配置返回单页面应用的index.html文件，服务器会返回404错误。
为了解决这个问题，服务器需要配置为对所有未知路径都返回同一个index.html文件，让前端的Vue Router处理路由。这种配置确保了即使在使用history模式时，用户在刷新或直接访问URL时也不会看到404错误。</p> <h3 id="vue设计原理"><a href="#vue设计原理" class="header-anchor">#</a> Vue设计原理</h3> <ol><li><p><strong>响应式数据系统</strong>:</p> <ul><li>Vue使用<strong>Object.defineProperty</strong> (在Vue 3中使用<strong>Proxy</strong>) 来观察和响应数据的变化。</li> <li>当数据更改时，Vue会自动重新渲染相关的组件。</li></ul></li> <li><p><strong>虚拟DOM (Virtual DOM)</strong>:</p> <ul><li>Vue使用虚拟DOM来提高渲染性能。这是对真实DOM的轻量级表示。</li> <li>当数据更改时，Vue创建一个新的虚拟DOM并与之前的版本进行差异比较，然后高效地更新真实DOM。</li></ul></li> <li><p><strong>组件系统</strong>:</p> <ul><li>Vue应用程序由可重用的组件组成。</li> <li>每个组件都有自己的状态、逻辑和视图，使得代码更加模块化和可维护。</li></ul></li> <li><p><strong>模板语法</strong>:</p> <ul><li>Vue提供了声明式的模板语法，允许开发者直观地定义界面。</li> <li>模板是基于数据的声明式描述，Vue将其编译为虚拟DOM渲染函数。</li></ul></li> <li><p><strong>指令 (Directives)</strong>:</p> <ul><li>Vue的模板语法中的前缀为<code>v-</code>的特殊标记。</li> <li>指令提供了一些逻辑，例如条件渲染(<code>v-if</code>)或列表渲染(<code>v-for</code>)。</li></ul></li> <li><p><strong>事件系统</strong>:</p> <ul><li>Vue提供了一个简单的方法来监听DOM事件并在Vue实例中执行方法。</li> <li>使用<code>v-on:</code>前缀或<code>@</code>简写来绑定事件。</li></ul></li> <li><p><strong>双向数据绑定</strong>:</p> <ul><li>通过<code>v-model</code>指令，Vue提供了双向数据绑定，特别是在表单元素上。</li> <li>当输入数据更改时，Vue实例的数据会自动更新，反之亦然。</li></ul></li> <li><p><strong>MVVM模式 (Model-View-ViewModel)</strong>:</p> <ul><li>Vue遵循MVVM设计模式，其中<code>Model</code>代表数据，<code>View</code>代表UI，<code>ViewModel</code>是Vue实例，作为中介者同步<code>Model</code>和<code>View</code>。</li></ul></li> <li><p><strong>依赖注入</strong>:</p> <ul><li>Vue提供了一种方式（例如<code>provide/inject</code>）来允许祖先组件向其所有子孙组件提供特定的属性或方法。</li></ul></li> <li><p><strong>插件和混入</strong>:</p></li></ol> <ul><li>Vue的生态系统支持插件和混入，以增强核心库的功能。</li></ul> <ol start="11"><li><strong>生命周期钩子</strong>:</li></ol> <ul><li>在组件的不同阶段（如创建、更新和销毁），Vue提供了生命周期钩子，允许用户执行自定义逻辑。</li></ul> <h3 id="vue脚手架"><a href="#vue脚手架" class="header-anchor">#</a> vue脚手架</h3> <h3 id="vue和react的区别"><a href="#vue和react的区别" class="header-anchor">#</a> vue和react的区别</h3> <ol><li><p><strong>起源和背景</strong>:</p> <ul><li><strong>Vue</strong>: 由前Google工程师尤雨溪（Evan You）创立，开始作为一个个人项目，但后来获得了广泛的社区支持。</li> <li><strong>React</strong>: 由Facebook开发，并用于其多个产品，如Facebook和Instagram。</li></ul></li> <li><p><strong>核心概念</strong>:</p> <ul><li><strong>Vue</strong>: 使用基于模板的声明式渲染，同时提供了响应式数据绑定。</li> <li><strong>React</strong>: 使用JSX (JavaScript + XML) 进行渲染，倡导组件的纯函数性。</li></ul></li> <li><p><strong>数据绑定</strong>:</p> <ul><li><strong>Vue</strong>: 双向数据绑定（通过v-model）。</li> <li><strong>React</strong>: 单向数据流，但可以使用受控组件实现双向绑定。</li></ul></li> <li><p><strong>组件化</strong>:</p> <ul><li><strong>Vue</strong>: 提供了具有明确功能的选项（如data、methods、computed、watch等）。</li> <li><strong>React</strong>: 更偏向于使用JavaScript函数和React hooks。</li></ul></li> <li><p><strong>状态管理</strong>:</p> <ul><li><strong>Vue</strong>: 通常使用Vuex。</li> <li><strong>React</strong>: 通常使用Redux或React Context API。</li></ul></li> <li><p><strong>生态系统</strong>:</p> <ul><li><strong>Vue</strong>: Vue Router、Vuex、Vue CLI等。</li> <li><strong>React</strong>: React Router、Redux、Create React App等。</li></ul></li> <li><p><strong>学习曲线</strong>:</p> <ul><li><strong>Vue</strong>: 通常被认为对初学者更友好，由于其API和设计的一致性。</li> <li><strong>React</strong>: 可能需要更多时间去适应JSX和组件生命周期的概念，但一旦掌握，也是很直观的。</li></ul></li> <li><p><strong>自定义渲染</strong>:</p> <ul><li><strong>Vue</strong>: 主要用于Web界面。</li> <li><strong>React</strong>: 除了Web界面，还有React Native用于移动应用开发。</li></ul></li> <li><p><strong>响应系统</strong>:</p> <ul><li><strong>Vue</strong>: 使用依赖追踪和setter/getter的机制。</li> <li><strong>React</strong>: 使用状态(state)和props的比较来决定是否重新渲染。</li></ul></li> <li><p><strong>脚本风格</strong>:</p></li></ol> <ul><li><strong>Vue</strong>: 支持单文件组件，允许模板、脚本和样式在同一个文件中。</li> <li><strong>React</strong>: 倾向于将样式和标记混合在JS/JSX文件中。</li></ul> <h3 id="vue-3-有了解过吗"><a href="#vue-3-有了解过吗" class="header-anchor">#</a> Vue 3 有了解过吗？</h3> <h3 id="vue2和vue3区别"><a href="#vue2和vue3区别" class="header-anchor">#</a> vue2和vue3区别</h3> <ol><li><p><strong>Composition API</strong>:</p> <ul><li><strong>Vue 2</strong>: 主要使用Options API，其中组件的选项（如<code>data</code>、<code>methods</code>、<code>computed</code>）是分隔开的。</li> <li><strong>Vue 3</strong>: 引入了Composition API，允许更灵活地组织组件逻辑，并更好地支持类型检查。</li></ul></li> <li><p><strong>Performance</strong>:</p> <ul><li><strong>Vue 2</strong>: 虚拟DOM重构是一般的。</li> <li><strong>Vue 3</strong>: 更高效的虚拟DOM重构，引入了静态树和静态属性提升，这使得渲染更加高效。</li></ul></li> <li><p><strong>Proxy-based reactivity</strong>:</p> <ul><li><strong>Vue 2</strong>: 使用<code>Object.defineProperty</code>进行响应性处理。</li> <li><strong>Vue 3</strong>: 使用<code>Proxy</code>作为其响应性系统的基础，这为新的响应性功能提供了更好的性能和额外的功能。</li></ul></li> <li><p><strong>Fragment, Teleport, Suspense</strong>:</p> <ul><li><strong>Vue 2</strong>: 组件必须有单一的根元素。</li> <li><strong>Vue 3</strong>: 支持Fragment（多根元素的组件）、Teleport（将组件的子元素传送到DOM的其他位置）和Suspense（用于异步组件的加载状态）。</li></ul></li> <li><p><strong>Custom Renderer API</strong>:</p> <ul><li><strong>Vue 2</strong>: 自定义渲染器API不是公开的。</li> <li><strong>Vue 3</strong>: 允许开发者使用自定义渲染器API。</li></ul></li> <li><p><strong>Size</strong>:</p> <ul><li><strong>Vue 2</strong>: 大小相对较大。</li> <li><strong>Vue 3</strong>: 更小且更快，由于Tree shaking的支持。</li></ul></li> <li><p><strong>TypeScript</strong>:</p> <ul><li><strong>Vue 2</strong>: 支持TypeScript，但并非从一开始就设计为TypeScript优先。</li> <li><strong>Vue 3</strong>: 核心代码库使用TypeScript重写，提供了更好的TS支持和类型定义。</li></ul></li> <li><p><strong>V-model</strong>:</p> <ul><li><strong>Vue 2</strong>: 有单一的v-model指令用于双向数据绑定。</li> <li><strong>Vue 3</strong>: v-model现在可以在一个组件上使用多次，且可以自定义。</li></ul></li> <li><p><strong>Lifecycle Hooks</strong>:</p> <ul><li><strong>Vue 2</strong>: 使用beforeDestroy和destroyed。</li> <li><strong>Vue 3</strong>: 这两个生命周期钩子已重命名为beforeUnmount和unmounted。</li></ul></li> <li><p><strong>Global API Changes</strong>:</p></li></ol> <ul><li><strong>Vue 2</strong>: 全局API和全局配置使用Vue构造函数。</li> <li><strong>Vue 3</strong>: 引入了一个新的全局API创建方法，如<code>createApp</code>。</li></ul> <ol start="11"><li><strong>Multiple v-on Listeners</strong>:</li></ol> <ul><li><strong>Vue 2</strong>: 不支持。</li> <li><strong>Vue 3</strong>: 可以为同一个事件使用多个事件侦听器。</li></ul> <h3 id="vue双向绑定原理-深挖-哪个属性-什么模式-vue2和3有什么不同"><a href="#vue双向绑定原理-深挖-哪个属性-什么模式-vue2和3有什么不同" class="header-anchor">#</a> vue双向绑定原理（深挖 哪个属性？什么模式？vue2和3有什么不同）</h3> <ol><li><p><strong>响应式系统</strong>:</p> <ul><li><strong>Vue 2</strong>:
<ul><li>使用 <code>Object.defineProperty</code> 来劫持每个属性的 getter 和 setter。</li> <li>当属性被访问和修改时，会分别触发 getter 和 setter 方法。</li></ul></li> <li><strong>Vue 3</strong>:
<ul><li>使用 <code>Proxy</code> 对象进行数据劫持。</li> <li>相比 <code>Object.defineProperty</code>，<code>Proxy</code> 可以直接监听对象和数组的变化，无需递归遍历。</li></ul></li></ul></li> <li><p><strong>v-model 指令</strong>:</p> <ul><li><code>v-model</code> 是 Vue 中用于双向数据绑定的指令。</li> <li>它是 <code>v-bind</code> 和 <code>v-on</code> 的语法糖。</li> <li>对于 <code>&lt;input&gt;</code> 元素，<code>v-model</code> 会将输入的值绑定到 Vue 实例的数据，并监听 input 事件来更新数据。</li></ul></li> <li><p><strong>事件处理</strong>:</p> <ul><li>当输入字段发生变化时，会触发一个 input 事件。</li> <li>Vue 通过事件处理器捕获这些事件，并更新 Vue 实例的数据。</li></ul></li> <li><p><strong>计算属性和侦听器</strong>:</p> <ul><li>Vue 的双向绑定还与计算属性和侦听器配合工作，以实现更复杂的功能。</li></ul></li> <li><p><strong>Vue 2 与 Vue 3 的不同</strong>:</p> <ul><li>如上所述，两者最大的差异在于其底层的响应式系统。</li> <li>Vue 3 的响应式系统使用 <code>Proxy</code>，它为性能优化和更精细的变更检测提供了更多的机会。</li> <li>Vue 3 还提供了对多个 v-model 的支持，允许开发者在单个组件上使用多个 v-model，以支持多个双向绑定。</li></ul></li></ol> <h3 id="vue-双向绑定的底层原理"><a href="#vue-双向绑定的底层原理" class="header-anchor">#</a> Vue 双向绑定的底层原理</h3> <ol><li><p><strong>响应式数据系统</strong>:</p> <ul><li>当你把一个普通的 JavaScript 对象传入 Vue 实例的 <code>data</code> 选项，Vue 将遍历此对象的所有属性，并使用 <code>Object.defineProperty</code> 将它们转为 getter/setter（在 Vue 2.x 中）。</li> <li>在 Vue 3 中，Vue 使用了 <code>Proxy</code> 来替代 <code>Object.defineProperty</code>，从而实现更强大和灵活的响应性。</li></ul></li> <li><p><strong>依赖收集</strong>:</p> <ul><li>当渲染 Vue 组件时，Vue 会“触碰” <code>data</code> 中的属性，从而触发 getter。</li> <li>Getter 中会进行依赖收集，即记录哪些属性被哪些组件依赖。这样当数据发生变化时，只有依赖这些数据的组件会重新渲染。</li></ul></li> <li><p><strong>使用 v-model 进行双向绑定</strong>:</p> <ul><li>在 <code>&lt;input&gt;</code> 标签上，我们可以使用 <code>v-model</code> 指令来实现双向数据绑定。</li> <li>实际上，<code>v-model</code> 是 <code>v-bind:value</code> 和 <code>v-on:input</code> 的语法糖。</li> <li>当用户输入时，输入框的值会改变，触发 <code>input</code> 事件，<code>v-on:input</code> 会确保这个变化反映到 Vue 实例的 <code>data</code> 属性上。</li> <li>当 <code>data</code> 属性发生变化时，由于 Vue 的响应性系统，DOM 会自动更新以反映这些变化。</li></ul></li> <li><p><strong>数据变动 -&gt; 视图更新</strong>:</p> <ul><li>当我们更改 <code>data</code> 中的数据时，setter 会被触发。</li> <li>Vue 会立即异步地开始更新组件，以匹配新状态。</li></ul></li> <li><p><strong>视图变动 -&gt; 数据更新</strong>:</p> <ul><li>这主要通过事件监听实现，例如当输入框内容发生变化时。</li> <li>使用 <code>v-model</code>，或等价的 <code>v-bind</code> 和 <code>v-on</code> 组合，可以实现视图到数据的更新。</li></ul></li></ol> <h3 id="v-if和v-show区别"><a href="#v-if和v-show区别" class="header-anchor">#</a> v-if和v-show区别</h3> <ol><li><p><strong>渲染方式</strong>:</p> <ul><li><strong>v-if</strong>: 当条件为 <code>false</code> 时，元素及其内部的所有内容都不会被渲染到 DOM 中。它们完全被销毁和重新创建，而不是简单地隐藏和显示。</li> <li><strong>v-show</strong>: 不论条件为真还是假，元素始终会被渲染到 DOM 中。当条件为 <code>false</code> 时，该指令通过设置 CSS 的 <code>display</code> 属性为 <code>none</code> 来隐藏元素。</li></ul></li> <li><p><strong>渲染成本</strong>:</p> <ul><li><strong>v-if</strong>: 有更高的切换开销，因为它涉及到真正的 DOM 节点的销毁和重建。</li> <li><strong>v-show</strong>: 切换成本较低，因为它只是简单地切换 CSS 属性。</li></ul></li> <li><p><strong>初始成本</strong>:</p> <ul><li><strong>v-if</strong>: 如果在初始渲染时条件为 <code>false</code>，则有更低的初始渲染成本。</li> <li><strong>v-show</strong>: 无论初始条件如何，元素及其所有内容都会被渲染，因此初始渲染成本相对较高。</li></ul></li> <li><p><strong>与其他指令的结合</strong>:</p> <ul><li><strong>v-if</strong> 与 <code>v-for</code> 一起使用时要特别小心，因为优先级更高的 <code>v-for</code> 可能会影响预期的行为。</li> <li><strong>v-show</strong> 不支持 <code>&lt;template&gt;</code> 元素，也不支持 <code>v-else</code> 和 <code>v-else-if</code>。</li></ul></li></ol> <p><strong>总体建议：</strong></p> <ul><li>如果元素需要频繁地切换显示状态，v-show 会更合适，因为只需要简单地修改 CSS 属性。</li> <li>如果运行时条件很少改变，或者在渲染时需要真正地添加或移除元素，那么 v-if 更为合适。</li></ul> <h3 id="compute和watch区别"><a href="#compute和watch区别" class="header-anchor">#</a> compute和watch区别</h3> <ol><li><p><strong>基本定义</strong>:</p> <ul><li><strong>computed</strong>: 是用于声明式地描述依赖于其他数据属性的计算属性。它们是基于它们的依赖进行缓存的。</li> <li><strong>watch</strong>: 是观察并响应 Vue 实例上的数据变动的更通用方法。可以执行任何副作用（如数据请求）。</li></ul></li> <li><p><strong>返回值</strong>:</p> <ul><li><strong>computed</strong>: 通常返回一个值，基于它的依赖项的当前状态。</li> <li><strong>watch</strong>: 无需返回值。它观察某个值，并在该值发生变化时执行某些操作。</li></ul></li> <li><p><strong>缓存性</strong>:</p> <ul><li><strong>computed</strong>: 是基于其依赖项的响应性系统进行缓存的。只有当依赖项发生变化时，计算属性才会重新求值。</li> <li><strong>watch</strong>: 每次监听的数据属性变化时都会执行。</li></ul></li> <li><p><strong>使用场景</strong>:</p> <ul><li><strong>computed</strong>: 当一些数据依赖于其他数据进行计算或转换时使用。例如，基于一个数组计算已完成的任务数量。</li> <li><strong>watch</strong>: 当数据变化需要执行异步或开销较大的操作时使用。例如，当某个属性变化时请求新数据。</li></ul></li> <li><p><strong>方法与属性</strong>:</p> <ul><li><strong>computed</strong>: 主要是作为属性使用，但也可以设置 getter 和 setter。</li> <li><strong>watch</strong>: 可以使用 handler 方法和其他配置选项，例如深度观察 <code>deep</code> 或立即执行的 <code>immediate</code>。</li></ul></li></ol> <p>总结：虽然 computed 和 watch 在某种程度上可以互换使用，但选择哪个取决于你想要完成的具体任务。computed 更适合需要计算的场景，而 watch 更适合响应数据变化来执行异步或开销较大的操作。</p> <h3 id="vue里面的常用api"><a href="#vue里面的常用api" class="header-anchor">#</a> vue里面的常用api</h3> <ol><li><p><strong>全局配置</strong>:</p> <ul><li><strong>Vue.config</strong>: 用于设置 Vue 的全局配置。</li></ul></li> <li><p><strong>全局 API</strong>:</p> <ul><li><strong>Vue.extend</strong>: 用于创建一个“子类”构造器。</li> <li><strong>Vue.component</strong>: 用于全局注册或获取一个组件。</li> <li><strong>Vue.directive</strong>: 用于全局注册或获取一个自定义指令。</li></ul></li> <li><p><strong>实例属性</strong>:</p> <ul><li><strong>vm.$data</strong>: Vue 实例观察的数据对象。</li> <li><strong>vm.$props</strong>: 当前组件接收到的 <code>props</code> 对象。</li> <li><strong>vm.$el</strong>: Vue 实例使用的根 DOM 元素。</li> <li><strong>vm.$options</strong>: 用于当前 Vue 实例的初始化选项。</li> <li><strong>vm.$parent &amp; vm.$children</strong>: 父级和子级组件的引用。</li> <li><strong>vm.$slots &amp; vm.$scopedSlots</strong>: 用于访问插槽内容。</li> <li><strong>vm.$refs</strong>: 一个对象，持有已注册过 <code>ref</code> 的所有子组件。</li> <li><strong>vm.$watch</strong>: 用于监听实例的变化。</li></ul></li> <li><p><strong>实例方法</strong>:</p> <ul><li><strong>vm.$mount</strong>: 手动地挂载一个未挂载的实例。</li> <li><strong>vm.$forceUpdate</strong>: 迫使 Vue 实例重新渲染。</li> <li><strong>vm.$nextTick</strong>: 用于延迟执行一段代码直到下一次 DOM 更新循环。</li> <li><strong>vm.$set &amp; vm.$delete</strong>: 用于添加或删除响应式属性。</li></ul></li> <li><p><strong>生命周期方法</strong>:</p> <ul><li><strong>beforeCreate, created, beforeMount, mounted, beforeUpdate, updated, beforeDestroy, destroyed</strong>: 这是 Vue 组件生命周期中的各个阶段的钩子函数。</li></ul></li> <li><p><strong>指令</strong>:</p> <ul><li><strong>v-bind</strong>: 绑定属性或动态指定组件。</li> <li><strong>v-model</strong>: 在表单 <code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code> 和 <code>&lt;select&gt;</code> 元素上创建双向数据绑定。</li> <li><strong>v-for</strong>: 为数组中的每个项渲染节点。</li> <li><strong>v-on</strong>: 绑定事件监听器。</li> <li><strong>v-if, v-else-if, v-else</strong>: 条件渲染元素。</li> <li><strong>v-show</strong>: 根据条件切换元素的显示/隐藏。</li> <li><strong>v-pre</strong>: 跳过这个元素和它的子元素的编译过程。</li> <li><strong>v-cloak</strong>: 在 Vue 编译结束后，从绑定的 HTML 元素上移除。</li> <li><strong>v-once</strong>: 表示元素和它的所有子元素应该被视为静态内容并跳过编译。</li></ul></li> <li><p><strong>特殊属性</strong>:</p> <ul><li><strong>key</strong>: 用于跟踪节点的身份，当节点在 diff 算法中被重用时特别有用。</li> <li><strong>ref</strong>: 用于在父组件中注册子组件的引用。</li></ul></li></ol> <h3 id="nexttick"><a href="#nexttick" class="header-anchor">#</a> $nextTick</h3> <p><code>vm.$nextTick</code> 是 Vue 实例的一个非常有用的方法，它允许你延迟一段代码的执行，直到 Vue 完成了下一次的 DOM 更新循环。当你修改了一些数据，并希望在 DOM 更新之后立即基于新的 DOM 进行某些操作时，通常使用 <code>vm.$nextTick</code>。</p> <h3 id="set"><a href="#set" class="header-anchor">#</a> $set</h3> <p>vm.$set 是 Vue 中的一个实例方法，它被用来绕过 Vue 的响应系统的限制，为已经创建的对象添加新的响应式属性。在 Vue 的响应系统中，如果你直接给对象添加新属性，该属性是非响应式的，意味着当这个属性变化时，Vue 不会触发任何更新。
使用 vm.$set，你可以确保新添加的属性是响应式的，且变动时能够触发视图更新。
下面使用 Markdown 代码模式来展示 vm.$set 的基本用法：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>vm<span class="token punctuation">.</span><span class="token function">$set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> propertyName<span class="token operator">/</span>index<span class="token punctuation">,</span> value<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="为什么vue3比vue2提升性能-表现在什么地方"><a href="#为什么vue3比vue2提升性能-表现在什么地方" class="header-anchor">#</a> 为什么vue3比vue2提升性能，表现在什么地方</h3> <ol><li><p><strong>编译优化</strong>:</p> <ul><li>Vue 3 的编译器引入了更多的编译时优化。例如，它能静态地分析模板，以便在生成的 JavaScript 代码中跳过不需要的条件分支。</li> <li>介绍了 Block Tree 的概念，使得只有动态节点会参与 Virtual DOM 的对比，大幅度减小了运行时的性能开销。</li></ul></li> <li><p><strong>更小的体积</strong>:</p> <ul><li>Vue 3 的代码库采用了 Tree-shaking 的支持，能更有效地减小最终构建的大小。</li></ul></li> <li><p><strong>Proxy-based 观察者机制</strong>:</p> <ul><li>Vue 3 使用 Proxy 代替了 Vue 2 的 Object.defineProperty，以实现数据响应式。Proxy 可以直接观察对象和数组的变化，没有“不变性”的限制，并且性能更好。</li></ul></li> <li><p><strong>优化的 Virtual DOM 算法和更新机制</strong>:</p> <ul><li>Vue 3 引入了一种更高效的 Virtual DOM 算法，并优化了 patching 过程，减少了不必要的计算。</li></ul></li> <li><p><strong>异步渲染机制</strong>:</p> <ul><li>Vue 3 提供了异步渲染的能力，可以有效地分解长时间的更新过程，避免界面的卡顿。</li></ul></li> <li><p><strong>组合 API (Composition API)</strong>:</p> <ul><li>Vue 3 引入了组合 API，它使得代码更易于管理和重用，这可能对性能没有直接影响，但它有助于开发更优化和清晰的代码。</li></ul></li> <li><p><strong>自定义 Renderer API</strong>:</p> <ul><li>Vue 3 允许开发者使用不同的渲染后端，这可以用来优化特定环境下的渲染性能。</li></ul></li></ol> <p><strong>具体表现在</strong>:</p> <ul><li><strong>更快的初次渲染和更新渲染</strong>，得益于编译优化和运行时的优化。</li> <li><strong>更小的打包体积</strong>，这对于性能敏感和加载时间敏感的场景（如移动端）特别重要。</li> <li><strong>更优的内存使用</strong>，由于 Proxy 的使用和优化的 Virtual DOM 算法。</li> <li><strong>更灵活和高效的代码组织方式</strong>，得益于 Composition API。</li></ul> <h3 id="父子组件生命周期"><a href="#父子组件生命周期" class="header-anchor">#</a> 父子组件生命周期</h3> <p><strong>父子组件生命周期钩子执行顺序</strong>:</p> <p><strong>初始化阶段</strong>:</p> <ol><li>父组件 <code>beforeCreate</code></li> <li>父组件 <code>created</code></li> <li>父组件 <code>beforeMount</code></li> <li>子组件 <code>beforeCreate</code></li> <li>子组件 <code>created</code></li> <li>子组件 <code>beforeMount</code></li> <li>子组件 <code>mounted</code></li> <li>父组件 <code>mounted</code></li></ol> <p><strong>销毁阶段</strong>:</p> <ol><li>父组件 <code>beforeDestroy</code></li> <li>子组件 <code>beforeDestroy</code></li> <li>子组件 <code>destroyed</code></li> <li>父组件 <code>destroyed</code></li></ol> <p><strong>注意点</strong>:</p> <ul><li>在初始化阶段，父组件的 <code>beforeMount</code> 钩子先于子组件的所有生命周期钩子执行。但是，父组件的 <code>mounted</code> 钩子会在子组件的 <code>mounted</code> 钩子之后执行。这是因为父组件的模板中的子组件需要先挂载和渲染完毕。</li> <li>在销毁阶段，父组件的 <code>beforeDestroy</code> 钩子会先于子组件的生命周期钩子执行。但子组件的销毁过程（包括 <code>beforeDestroy</code> 和 <code>destroyed</code> 钩子）会在父组件的 <code>destroyed</code> 钩子之前完成。</li></ul> <h3 id="vue的props相关"><a href="#vue的props相关" class="header-anchor">#</a> vue的props相关</h3> <ol><li><p><strong>基本概念</strong>:</p> <ul><li><code>props</code> 是 &quot;properties&quot; 的简写。</li> <li>它是一种父子组件之间进行数据传输的方式。</li> <li>子组件通过 <code>props</code> 接收数据，但不应该修改这些数据。如需修改，应当使用事件通知父组件进行操作。</li></ul></li> <li><p><strong>声明方式</strong>:
子组件通过 <code>props</code> 选项来声明它期望从父组件接收的数据。</p></li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'title'</span><span class="token punctuation">,</span> <span class="token string">'message'</span><span class="token punctuation">]</span>
或者
<span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">title</span><span class="token operator">:</span> String<span class="token punctuation">,</span>
  <span class="token literal-property property">message</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">type</span><span class="token operator">:</span> String<span class="token punctuation">,</span>
    <span class="token literal-property property">required</span><span class="token operator">:</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="vue中子组件可以修改父组件的props吗"><a href="#vue中子组件可以修改父组件的props吗" class="header-anchor">#</a> vue中子组件可以修改父组件的props吗</h3> <p>在 Vue 中，子组件不应直接修改从父组件接收的 <code>props</code>。原因如下：</p> <ol><li><p><strong>单向数据流</strong>:</p> <ul><li>Vue 的组件间通信建立在单向数据流的原则上。这意味着<code>props</code>只应从父组件流向子组件，而不应该反过来。</li></ul></li> <li><p><strong>预测性</strong>:</p> <ul><li>如果允许子组件直接修改 <code>props</code>，那么组件之间的数据流动就会变得难以跟踪和预测。</li></ul></li> <li><p><strong>警告</strong>:</p> <ul><li>如果你尝试在子组件内部修改 <code>props</code>，Vue 将会在控制台给出警告。</li></ul></li></ol> <p><strong>正确的方式</strong>:</p> <p>如果子组件需要通知父组件修改某些数据，应该使用自定义事件：</p> <ol><li>子组件中使用 <code>$emit</code> 发送事件。</li> <li>父组件监听这个事件并作出相应的处理。</li></ol> <p><strong>示例</strong>:</p> <div class="language-vue line-numbers-mode"><pre class="language-vue"><code><span class="token comment">&lt;!-- ParentComponent.vue --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ChildComponent</span> <span class="token attr-name">:value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>parentValue<span class="token punctuation">&quot;</span></span> <span class="token attr-name">@updateValue</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>updateParentValue<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">parentValue</span><span class="token operator">:</span> <span class="token string">'Hello Vue!'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">updateParentValue</span><span class="token punctuation">(</span><span class="token parameter">newValue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>parentValue <span class="token operator">=</span> newValue<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token comment">&lt;!-- ChildComponent.vue --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>notifyParent<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>Update Value<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'value'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">notifyParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'updateValue'</span><span class="token punctuation">,</span> <span class="token string">'Hello OpenAI!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br></div></div><p>总之，子组件不应该直接修改从父组件传递的 <code>props</code>。要修改数据，应该使用事件来通知父组件。</p> <h3 id="vue组件间通信方式"><a href="#vue组件间通信方式" class="header-anchor">#</a> Vue组件间通信方式</h3> <ol><li><p><strong>Props / $emit</strong>:</p> <ul><li>父组件通过 <code>props</code> 向子组件传递数据。</li> <li>子组件通过 <code>$emit</code> 发送事件通知父组件。</li></ul> <div class="language-vue line-numbers-mode"><pre class="language-vue"><code><span class="token comment">&lt;!-- ParentComponent.vue --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ChildComponent</span> <span class="token attr-name">:propData</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>data<span class="token punctuation">&quot;</span></span> <span class="token attr-name">@childEvent</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>handleEvent<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-vue line-numbers-mode"><pre class="language-vue"><code><span class="token comment">&lt;!-- ChildComponent.vue --&gt;</span>
this.$emit('childEvent', payload);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li><p><strong>$refs</strong>:</p> <ul><li>访问子组件实例或 DOM 元素。</li></ul> <div class="language-vue line-numbers-mode"><pre class="language-vue"><code><span class="token comment">&lt;!-- ParentComponent.vue --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ChildComponent</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>childRef<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>childRef<span class="token punctuation">.</span><span class="token function">someMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p><strong>$children and $parent</strong>:</p> <ul><li><code>$children</code>: 父组件访问其所有子组件实例。</li> <li><code>$parent</code>: 子组件访问其父组件实例。</li></ul> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">this</span><span class="token punctuation">.</span>$children<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">someMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>$parent<span class="token punctuation">.</span><span class="token function">someParentMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li><p><strong>Provide / Inject</strong>:</p> <ul><li>祖先组件提供变量，然后后代组件可以通过 <code>inject</code> 进行接收，无需中间组件传递。</li></ul> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// AncestorComponent</span>
<span class="token function">provide</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">providedData</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>data
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// DescendantComponent</span>
<span class="token literal-property property">inject</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'providedData'</span><span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li><p><strong>Event Bus</strong>:</p> <ul><li>创建一个新的 Vue 实例作为事件中心。</li></ul> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> EventBus <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// In Component A</span>
EventBus<span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'event'</span><span class="token punctuation">,</span> payload<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// In Component B</span>
EventBus<span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span><span class="token string">'event'</span><span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></li> <li><p><strong>Vuex</strong>:</p> <ul><li>Vuex 是一个状态管理模式和库。所有组件可以从一个集中的存储中读取或修改状态。</li></ul> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// Committing a mutation</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'mutationName'</span><span class="token punctuation">,</span> payload<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Dispatching an action</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">'actionName'</span><span class="token punctuation">,</span> payload<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li> <li><p><strong>$attrs and $listeners</strong>:</p> <ul><li><code>$attrs</code>: 包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。</li> <li><code>$listeners</code>: 包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。</li></ul></li> <li><p><strong>Slots and Scoped Slots</strong>:</p> <ul><li>允许父组件在子组件的模板内部插入内容。</li></ul> <div class="language-vue line-numbers-mode"><pre class="language-vue"><code><span class="token comment">&lt;!-- ParentComponent.vue --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ChildComponent</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name"><span class="token namespace">v-slot:</span>default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>slotProps<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    {{ slotProps.someData }}
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ChildComponent</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li> <li><p><strong>Direct component communication using methods</strong>:</p> <ul><li>一个组件直接调用另一个组件的方法。</li></ul> <div class="language-vue line-numbers-mode"><pre class="language-vue"><code><span class="token comment">&lt;!-- ParentComponent.vue --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ChildComponent</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>childComponentRef<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// ParentComponent's method</span>
<span class="token function">someMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>childComponentRef<span class="token punctuation">.</span><span class="token function">childMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></li></ol> <h3 id="如何自定义通用组件"><a href="#如何自定义通用组件" class="header-anchor">#</a> 如何自定义通用组件</h3> <ol><li><p><strong>定义需求</strong>:</p> <ul><li>在开始之前，明确您希望组件完成的功能。</li> <li>考虑组件应该接受哪些 <code>props</code> 以及可能发出哪些事件。</li></ul></li> <li><p><strong>组件结构</strong>:</p> <ul><li>使用有意义的文件和组件名称，使其易于理解和搜索。</li></ul> <div class="language-vue line-numbers-mode"><pre class="language-vue"><code><span class="token comment">&lt;!-- GeneralComponent.vue --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token comment">&lt;!-- component template here --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'GeneralComponent'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// define props here</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token comment">// other component options...</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">scoped</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">
  <span class="token comment">/* styles for the component */</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div></li> <li><p><strong>Props</strong>:</p> <ul><li>使用 <code>props</code> 使组件可配置。</li> <li>定义清晰的数据类型、默认值和验证。</li></ul> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">type</span><span class="token operator">:</span> String<span class="token punctuation">,</span>
    <span class="token keyword">default</span><span class="token operator">:</span> <span class="token string">'Default Title'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">isActive</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">type</span><span class="token operator">:</span> Boolean<span class="token punctuation">,</span>
    <span class="token keyword">default</span><span class="token operator">:</span> <span class="token boolean">false</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// ... other props</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div></li> <li><p><strong>Slots</strong>:</p> <ul><li>使用插槽以允许外部内容嵌入组件内部，增加组件的灵活性。</li></ul> <div class="language-vue line-numbers-mode"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span>  <span class="token comment">&lt;!-- default slot --&gt;</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li> <li><p><strong>Emit Events</strong>:</p> <ul><li>当组件内部的状态改变时，使用 <code>$emit</code> 发出事件，通知父组件。</li></ul> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token function">handleButtonClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// do something</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'buttonClicked'</span><span class="token punctuation">,</span> payload<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li> <li><p><strong>Styles</strong>:</p> <ul><li>使用 <code>scoped</code> 样式以防止样式泄露到其他组件。</li> <li>考虑提供 prop 以允许外部自定义某些样式。</li></ul></li> <li><p><strong>Documentation</strong>:</p> <ul><li>为您的组件提供文档，解释它的功能、接受的 <code>props</code>、发出的事件以及如何使用它。</li></ul></li> <li><p><strong>Testing</strong>:</p> <ul><li>编写单元测试，确保组件在各种配置下都按预期工作。</li></ul></li></ol> <h3 id="vue-的数据观测原理"><a href="#vue-的数据观测原理" class="header-anchor">#</a> vue 的数据观测原理</h3> <p>Vue 的响应式系统是其核心特性之一，它允许数据与视图之间建立起绑定关系。当数据改变时，视图会自动更新。以下是 Vue 的数据观测原理的概述：</p> <ol><li><p><strong>Object.defineProperty</strong>：</p> <p>在 Vue 2.x 中，响应式系统的核心是利用 ES5 的 <code>Object.defineProperty</code> 方法将对象的属性转化为 getter 和 setter。这使得 Vue 可以在属性被访问和修改时执行依赖跟踪和变更通知。</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 收集依赖</span>
    Dep<span class="token punctuation">.</span>target <span class="token operator">&amp;&amp;</span> dep<span class="token punctuation">.</span><span class="token function">addDep</span><span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> value<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">set</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newValue <span class="token operator">!==</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 更新值</span>
      value <span class="token operator">=</span> newValue<span class="token punctuation">;</span>
      <span class="token comment">// 通知依赖更新</span>
      dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div></li> <li><p><strong>依赖收集</strong>：</p> <p>当组件渲染或计算属性被评估时，它们访问响应式数据的 getter。这时，它们被添加为该数据属性的&quot;依赖&quot;。这样，当属性值改变时，相关的组件或计算属性可以被重新评估。</p></li> <li><p><strong>Watcher</strong>：</p> <p>Vue 使用 <code>Watcher</code> 类来观察响应式数据的变化。当数据改变时，与之相关的 <code>Watcher</code> 会被通知，从而触发视图的更新或重新计算计算属性。</p></li> <li><p><strong>Batching Updates</strong>：</p> <p>Vue 使用一个队列来批处理 DOM 更新，确保每个 watcher 只运行一次并防止不必要的重渲染。这是通过 Vue 的异步队列实现的。</p></li> <li><p><strong>Vue 3 的 Proxy-based reactivity</strong>：</p> <p>在 Vue 3 中，响应式系统得到了重写，并开始使用 ES6 的 <code>Proxy</code> 替代 <code>Object.defineProperty</code>，这提供了更好的性能和更强的功能，例如观测添加的属性、数组索引和集合。</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> observed <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 收集依赖</span>
    <span class="token function">track</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> oldValue <span class="token operator">=</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// 更新值</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldValue <span class="token operator">!==</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 通知依赖更新</span>
      <span class="token function">trigger</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div></li></ol> <p>总结：Vue 的响应式系统通过巧妙地结合 ES5/ES6 的特性、依赖跟踪和异步更新队列，实现了当数据改变时自动更新视图的功能。</p> <h3 id="react-vue-为什么要使用虚拟dom-有哪些不使用虚拟dom的前端框架"><a href="#react-vue-为什么要使用虚拟dom-有哪些不使用虚拟dom的前端框架" class="header-anchor">#</a> react vue 为什么要使用虚拟dom，有哪些不使用虚拟dom的前端框架</h3> <p><strong>为什么要使用虚拟 DOM</strong>:</p> <ol><li><strong>高效的更新</strong>：每次数据变化，重新渲染整个 UI 是低效的。虚拟 DOM 允许我们描述在一次数据更改之后 UI 的期望状态，然后它高效地计算出最小的操作集来更新真实的 DOM。</li> <li><strong>避免直接操作 DOM</strong>：直接的 DOM 操作是昂贵的。虚拟 DOM 提供了一个中间表示，使得我们可以避免直接操作 DOM，只在真正需要的时候进行最小的操作。</li> <li><strong>跨平台</strong>：虚拟 DOM 不只是为浏览器设计的。因为它是一个中间表示，所以它可以被渲染到其他的平台，比如 React Native 可以将其渲染到移动应用中。
<strong>不使用虚拟 DOM 的前端框架</strong>:</li> <li><strong>AngularJS (Angular 1.x)</strong>：它使用了脏检查来跟踪数据变化，而不是虚拟 DOM。</li> <li><strong>Backbone.js</strong>：它提供了模型和视图的绑定，但并没有使用虚拟 DOM。</li> <li><strong>jQuery</strong>：尽管它不是一个完整的框架，但 jQuery 是操作 DOM 的库，它没有使用虚拟 DOM。</li> <li><strong>Svelte</strong>：这是一个现代的前端框架，它在编译时进行优化，从而避免了运行时的虚拟 DOM 比对。</li> <li><strong>Alpine.js</strong>：一个轻量级的框架，用于在页面中增加简单的交互，没有使用虚拟 DOM。</li></ol> <p>需要注意的是，虚拟 DOM 不是性能优化的银弹。虚拟 DOM 的优势是在于当存在大量、复杂的 UI 更新时，它可以提供更一致和可预测的性能。但在某些场景下，其他方法可能更为高效。</p> <h3 id="vuex"><a href="#vuex" class="header-anchor">#</a> vuex</h3> <p>Vuex 是 Vue.js 的状态管理模式 + 库。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。
<strong>核心概念</strong>:</p> <ol><li><p><strong>State</strong>：
Vuex 使用单一状态树——是的, 使用一个对象就包含了全部的应用层级状态。每个 Vue 实例的 data 对象只处理实例内部的状态。</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">state</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li> <li><p><strong>Getters</strong>：
类似于 Vue 的计算属性，允许对 State 进行处理并返回。</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">state</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">1</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">getters</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">doubleCount</span><span class="token operator">:</span> <span class="token parameter">state</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>count <span class="token operator">*</span> <span class="token number">2</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div></li> <li><p><strong>Mutations</strong>：
更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。每个 mutation 都有一个字符串的事件类型 (type) 和一个回调函数 (handler)。</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">state</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">1</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">mutations</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">increment</span><span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      state<span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div></li> <li><p><strong>Actions</strong>：
类似于 mutation，但允许含有异步操作。</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">state</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">mutations</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">increment</span><span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> payload</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      state<span class="token punctuation">.</span>count <span class="token operator">+=</span> payload<span class="token punctuation">.</span>amount<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">actions</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">incrementAsync</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> commit <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'increment'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">amount</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div></li> <li><p><strong>Modules</strong>：
对于大型应用，将 store 分割成模块 (module) 是必要的。</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> moduleA <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">state</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token literal-property property">mutations</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">actions</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">getters</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">modules</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">a</span><span class="token operator">:</span> moduleA<span class="token punctuation">,</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div></li></ol> <p><strong>优势</strong>:</p> <ol><li><strong>集中式管理</strong>：Vuex 提供了一个集中式的状态存储，使得管理全局状态变得容易和可预测。</li> <li><strong>时间旅行调试</strong>：使用 Vue 的 devtools 插件，可以轻松地进行时间旅行式的调试和状态快照导出/导入。</li> <li><strong>状态持久化</strong>：通过插件，Vuex 可以很容易地与持久化存储解决方案集成。</li></ol> <p><strong>注意点</strong>:</p> <ol><li>应该始终使用 <code>commit</code> 提交 mutation，而不是直接更改 state。</li> <li>实际的异步操作应该通过 action 进行，而不是直接在 mutation 中。</li></ol> <h3 id="为什么用pinia而不是vuex做状态管理"><a href="#为什么用pinia而不是vuex做状态管理" class="header-anchor">#</a> 为什么用Pinia而不是vuex做状态管理?</h3> <p><strong>Pinia</strong> 是 Vue 3 中新出现的状态管理库，是为了更好地适应 Vue 3 的 Composition API 而设计的。与 <strong>Vuex</strong> 相比，它提供了一些新的特性和优势。以下是使用 Pinia 而不是 Vuex 的一些理由：</p> <ol><li><strong>与 Vue 3 配合更好</strong>：Pinia 是为 Vue 3 和 Composition API 设计的，从而可以充分利用 Vue 3 的新功能。</li> <li><strong>类型支持</strong>：Pinia 提供了更好的 TypeScript 支持，使得开发者可以更容易地利用 TypeScript 带来的类型安全性和自动完成功能。</li> <li><strong>简化的 API</strong>：Pinia 提供了一个更简单、直观的 API，使得学习曲线变得更平缓，特别是对于那些已经熟悉 Composition API 的开发者。</li> <li><strong>无需 this 上下文</strong>：在 Vuex 中，你经常需要使用 <code>this</code> 来访问 state、getters 等。而在 Pinia 中，由于它使用了 Composition API，因此不需要依赖 <code>this</code> 上下文。</li> <li><strong>独立的状态树</strong>：与 Vuex 使用单一的状态树不同，Pinia 允许每个 store 有其自己的状态树，这使得状态更加模块化和独立。</li> <li><strong>内建的 devtools 支持</strong>：Pinia 自带开发者工具支持，提供了时间旅行、状态修改记录等功能，使得调试变得更加方便。</li> <li><strong>按需导入</strong>：由于 Pinia 允许每个 store 有其独立的状态，因此你可以更灵活地按需导入你需要的 store，而不是像 Vuex 那样总是导入整个 store 树。</li></ol> <p><strong>注意点</strong>：
尽管 Pinia 提供了许多新特性和优势，但如果你正在维护一个大型的、基于 Vue 2 和 Vuex 的旧项目，那么迁移到 Pinia 可能会带来一些挑战。此外，由于 Pinia 是一个相对较新的库，因此可能还不如 Vuex 那样稳定和经过充分测试。
总之，选择使用 Pinia 还是 Vuex 应根据项目的具体需求和团队的经验来决定。</p> <h3 id="如果把所有状态都用全局状态管理会有什么问题"><a href="#如果把所有状态都用全局状态管理会有什么问题" class="header-anchor">#</a> 如果把所有状态都用全局状态管理会有什么问题?</h3> <p>将所有状态都存储在全局状态管理工具（如 Vuex、Redux 或 Pinia）中可能会引发以下问题和挑战：</p> <ol><li><strong>过度复杂化</strong>：不是所有的状态都需要全局管理。将所有状态放入全局会导致状态树变得庞大和复杂。</li> <li><strong>性能问题</strong>：频繁地更新全局状态可能会导致不必要的组件重新渲染，从而对性能产生影响。</li> <li><strong>维护难度增加</strong>：当全局状态管理器中充斥着大量不相关的状态时，跟踪哪部分状态由哪部分应用逻辑修改会变得困难。</li> <li><strong>团队协作难度增加</strong>：当多个开发者同时在同一个全局状态树上工作时，可能会更容易引发冲突和错误。</li> <li><strong>模块化和代码重用困难</strong>：将所有状态集中在一起可能会导致状态和逻辑的耦合，这使得将功能模块化或在不同项目中重用代码变得更加困难。</li> <li><strong>测试难度增加</strong>：具有大量全局状态的应用可能更难进行单元测试，因为需要为测试配置大量的上下文。</li> <li><strong>初始化和重置的复杂性</strong>：在需要重置应用状态或进行初始化操作时，处理一个庞大的全局状态比处理分散的局部状态要复杂得多。</li> <li><strong>不必要的依赖</strong>：组件可能会开始依赖那些它们实际上并不需要的全局状态，从而导致不必要的紧耦合。</li></ol> <p><strong>结论</strong>：
虽然全局状态管理工具非常强大，并且为处理跨组件或复杂状态提供了便利，但应该谨慎地选择哪些状态需要全局管理，哪些状态更适合作为组件的局部状态。</p> <h3 id="对于一个状态如何考虑是否应该提升到全局状态"><a href="#对于一个状态如何考虑是否应该提升到全局状态" class="header-anchor">#</a> 对于一个状态如何考虑是否应该提升到全局状态?</h3> <p>决定是否应该将某个状态提升到全局状态管理工具中通常涉及到多个考虑因素。以下是你应该考虑的一些关键点：</p> <ol><li><strong>组件间共享</strong>：如果多个组件需要访问同一个状态，并且这些组件不是父子关系，那么使用全局状态可能更为合适。</li> <li><strong>状态持久性</strong>：如果某个状态需要在页面刷新或跨路由持久存在，则可能需要考虑将其放入全局状态中。</li> <li><strong>业务逻辑的复杂性</strong>：复杂的业务逻辑和异步操作，如 API 调用，可能更适合在全局状态管理中处理，以便集中管理和调试。</li> <li><strong>状态来源</strong>：如果状态是由多个组件产生并可能被多个组件修改的，那么将其置于全局状态中可能更加合适，以确保数据的一致性。</li> <li><strong>组件解耦</strong>：为了避免组件之间产生过多的直接依赖，将状态提升到全局可以帮助组件保持独立性。</li> <li><strong>测试和调试</strong>：全局状态工具通常提供了开发者工具，可以更轻松地跟踪状态变化、调试和测试。</li> <li><strong>性能和优化</strong>：全局状态管理通常提供了更高级的优化手段，如中间件、延迟加载或持久化。</li> <li><strong>代码清晰度和组织</strong>：全局状态可以帮助你更清晰地组织和模块化你的代码，特别是对于大型应用。</li></ol> <p><strong>注意事项</strong>：</p> <ul><li>不要盲目地将所有状态提升到全局。过度使用全局状态可能会导致应用的复杂性不必要地增加。</li> <li>如果状态只在一个组件或一个组件的子组件中使用，那么将其保持为局部状态可能更有意义。</li> <li>考虑未来的需求和应用扩展。即使现在只有一个组件需要某个状态，但如果你预计将来其他组件也可能需要它，那么现在就考虑将其提升为全局状态可能是明智的。</li></ul> <p><strong>结论</strong>：
决定状态的位置需要平衡当前和未来的需求、应用的复杂性、可维护性和性能。始终以清晰性、可读性和可维护性为首要目标。</p> <h3 id="哪些数据放在vuex中"><a href="#哪些数据放在vuex中" class="header-anchor">#</a> 哪些数据放在Vuex中</h3> <p>将数据放在Vuex中是为了进行全局状态管理。但并不是所有的数据都适合放入Vuex。以下是一些建议你考虑放入Vuex的数据和场景：</p> <ol><li><strong>用户信息</strong>：如登录状态、用户基本信息、用户权限等，这些信息通常会被多个组件或页面所用到。</li> <li><strong>应用配置</strong>：主题设置、语言选择或其他全局的应用配置。</li> <li><strong>跨组件通信的数据</strong>：当多个不直接关联的组件需要共享数据时。</li> <li><strong>应用状态</strong>：例如显示全局通知、加载指示器的状态等。</li> <li><strong>缓存数据</strong>：例如从API获取的数据，可以在Vuex中缓存，避免重复请求。</li> <li><strong>复杂的交互状态</strong>：例如对话框、侧边栏的打开/关闭状态，如果这些状态涉及到多个组件或页面，则可能更适合放在Vuex中。</li> <li><strong>业务逻辑和异步操作</strong>：Vuex的actions可以帮助你集中管理复杂的业务逻辑和异步操作。</li></ol> <p><strong>但也需要注意以下情况，可能不适合放在Vuex中</strong>：</p> <ol><li><strong>组件内部状态</strong>：如某个下拉菜单的打开状态、一个开关的状态等，这些通常只与该组件有关，无需放入全局状态。</li> <li><strong>频繁变动的状态</strong>：如果状态更新非常频繁，但并不需要其他组件知道这些变动，则无需放入Vuex。</li> <li><strong>非共享状态</strong>：如果数据只在一个组件或一个组件树内部使用，并不需要共享给其他组件，那么将其作为局部状态管理可能更为合适。</li></ol> <p><strong>结论</strong>：
选择哪些数据放入Vuex中应该基于数据的用途和范围。关键是理解全局状态的目的是为了方便多个组件共享和管理数据，而不是为了存储所有的状态。适当的判断和组织可以确保你的应用结构清晰、可维护。</p> <h3 id="vue路由的实现原理"><a href="#vue路由的实现原理" class="header-anchor">#</a> vue路由的实现原理</h3> <p>Vue路由，即<code>vue-router</code>，是Vue.js官方的路由管理器。它提供了SPA（单页应用）之间路由的切换、导航和状态管理。下面是vue-router的基本实现原理：</p> <ol><li><p><strong>路由表注册</strong>：当我们创建一个Vue Router实例时，我们需要传递一个路由配置数组。这个数组定义了哪个URL对应哪个组件。</p></li> <li><p><strong>监听URL变化</strong>：Vue Router会根据运行环境（浏览器或Node.js）使用不同的方法监听URL的变化。</p> <ul><li><strong>Hash模式</strong>：在旧的浏览器中，默认使用<code>hash</code>模式，即通过<code>hashchange</code>事件监听URL的<code>#</code>后面部分的变化。</li> <li><strong>History模式</strong>：在支持HTML5 History API的现代浏览器中，Vue Router会使用<code>pushState</code>和<code>replaceState</code>来改变URL，同时通过<code>popstate</code>事件来监听URL的变化。</li></ul></li> <li><p><strong>路由匹配</strong>：当URL发生变化时，Vue Router会根据当前URL与预先定义的路由配置进行匹配，找到对应的组件。</p></li> <li><p><strong>视图渲染</strong>：一旦找到了与当前URL匹配的组件，Vue Router会将该组件渲染到<code>&lt;router-view&gt;</code>位置。如果有嵌套路由，则相应的子组件会被渲染到父路由组件的<code>&lt;router-view&gt;</code>中。</p></li> <li><p><strong>导航守卫</strong>：在渲染组件之前或之后，Vue Router提供了导航守卫（navigation guards）功能，允许我们实现对路由的访问控制，如验证登录、重定向等。</p></li> <li><p><strong>路由元信息</strong>：通过在路由配置中定义<code>meta</code>字段，我们可以为某个路由设置额外的元信息，这些信息可以在导航守卫中使用。</p></li> <li><p><strong>过渡效果</strong>：Vue Router允许我们为进入和离开的页面添加过渡动画效果。</p></li></ol> <p><strong>结论</strong>：
vue-router的核心原理是监听URL变化，根据URL与预定义的路由配置进行匹配，然后渲染相应的组件到<code>&lt;router-view&gt;</code>。此外，它还提供了许多高级功能，如导航守卫、路由懒加载、嵌套路由等，使单页应用的开发更为便捷。</p> <h3 id="描述一下数据流向的过程"><a href="#描述一下数据流向的过程" class="header-anchor">#</a> 描述一下数据流向的过程</h3> <p>在Vue应用中，数据流向通常遵循以下过程：</p> <ol><li><p><strong>Props Down, Events Up</strong>（父传子通过props，子传父通过事件）：</p> <ul><li><p><strong>Props</strong>：父组件向子组件传递数据通过<code>props</code>。</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 父组件</span>
<span class="token operator">&lt;</span>ChildComponent <span class="token operator">:</span>someProp<span class="token operator">=</span><span class="token string">&quot;parentData&quot;</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 子组件</span>
<span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'someProp'</span><span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li><p><strong>Events</strong>：子组件通过触发事件向父组件通知信息或请求。</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 子组件</span>
<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'childEvent'</span><span class="token punctuation">,</span> eventData<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 父组件</span>
<span class="token operator">&lt;</span>ChildComponent @childEvent<span class="token operator">=</span><span class="token string">&quot;handleEvent&quot;</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li></ul></li> <li><p><strong>Vuex</strong>：当多个组件需要共享状态时，通常会使用Vuex作为应用级的状态管理工具。</p> <ul><li><p><strong>State</strong>：存放应用的状态（即数据源）。</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token literal-property property">state</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li> <li><p><strong>Getters</strong>：从state派生的计算属性。</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token literal-property property">getters</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">isEven</span><span class="token operator">:</span> <span class="token parameter">state</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>count <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">===</span> <span class="token number">0</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li> <li><p><strong>Mutations</strong>：同步更改state的方法。</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token literal-property property">mutations</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token function">increment</span><span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    state<span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li> <li><p><strong>Actions</strong>：可以包含异步操作的方法，最后通过commit触发mutation。</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token literal-property property">actions</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token function">incrementAsync</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> commit <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'increment'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></li></ul></li> <li><p><strong>组件内部的数据流</strong>：</p> <ul><li><p><strong>Data</strong>：每个组件实例的私有数据。</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">message</span><span class="token operator">:</span> <span class="token string">'Hello Vue!'</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li> <li><p><strong>Computed Properties</strong>：基于组件的响应式依赖进行计算并缓存结果。</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token literal-property property">computed</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token function">uppercaseMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li> <li><p><strong>Methods</strong>：定义组件的方法。</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Button clicked!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li> <li><p><strong>Watchers</strong>：监听数据变化并执行操作。</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token literal-property property">watch</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token function">message</span><span class="token punctuation">(</span><span class="token parameter">newVal<span class="token punctuation">,</span> oldVal</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Message changed from </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>oldVal<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> to </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>newVal<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li></ul></li></ol> <p><strong>结论</strong>：
Vue应用中的数据流向是非常明确和受控的，遵循单向数据流原则。父组件通过<code>props</code>传递数据给子组件，子组件通过事件与父组件通讯。对于跨组件或应用级的状态管理，通常使用Vuex。</p> <h3 id="vue为什么要用data包裹属性"><a href="#vue为什么要用data包裹属性" class="header-anchor">#</a> vue为什么要用data包裹属性</h3> <p>在<code>Vue</code>中，<code>data</code>对象用于声明组件状态或属性。这是为什么：</p> <ol><li><strong>封装</strong>: <code>data</code>提供了一个清晰的界定，指示这些特定的属性是组件的状态，与其他组件的方法、生命周期钩子等明确分离。</li> <li><strong>响应性</strong>: <code>Vue</code>使用其响应系统来跟踪<code>data</code>中的属性的变化。当这些属性变化时，任何依赖于它们的部分都会被重新渲染。将这些属性包裹在<code>data</code>中，使得<code>Vue</code>知道要监视它们的变化。</li> <li><strong>可预测性</strong>: 当你查看一个<code>Vue</code>组件，你可以很容易地识别哪些属性是组件的状态，因为它们都在<code>data</code>对象内。</li> <li><strong>组件实例化</strong>: 当创建一个新的组件实例时，<code>data</code>必须是一个函数，这样每个实例都可以维护其独立的数据拷贝。这防止了不同实例之间的数据污染。</li></ol> <p>例如：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function-variable function">data</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">message</span><span class="token operator">:</span> <span class="token string">'Hello, Vue!'</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="vue的diff算法-vue2和3之间做了什么优化"><a href="#vue的diff算法-vue2和3之间做了什么优化" class="header-anchor">#</a> vue的diff算法（vue2和3之间做了什么优化）</h3> <p>Vue的<code>diff</code>算法是其虚拟DOM技术的核心，用于有效地对比新旧虚拟DOM并决定如何有效地更新实际的DOM。以下是Vue的<code>diff</code>算法和Vue2与Vue3之间的主要差异和优化：</p> <h2 id="vue的diff算法基本思路"><a href="#vue的diff算法基本思路" class="header-anchor">#</a> Vue的<code>diff</code>算法基本思路：</h2> <ol><li><strong>同一层级比较</strong>：Vue采用“深度优先、同层级”的策略进行diff，只会在同一层级的节点之间进行对比，减少了比较的复杂性。</li> <li><strong>节点的类型和key</strong>：如果两个节点的类型不同，那么Vue会直接替换该节点以及其所有子节点。如果类型相同，但是<code>key</code>不同，也会被视为不同的节点并直接替换。</li> <li><strong>Vnode的比较</strong>：当新旧Vnode相同时，Vue会继续对比其属性和子节点。</li></ol> <h2 id="vue2与vue3的diff算法优化"><a href="#vue2与vue3的diff算法优化" class="header-anchor">#</a> Vue2与Vue3的<code>diff</code>算法优化：</h2> <h3 id="vue2的diff"><a href="#vue2的diff" class="header-anchor">#</a> Vue2的<code>diff</code>：</h3> <ol><li>Vue2使用双端比较的策略。在进行子节点的对比时，首先会比较新旧Vnodes的两端节点，根据不同情况进行节点的移动、新增或删除。</li> <li>Vue2的核心思想是尽量复用旧的DOM元素，减少不必要的DOM操作。</li></ol> <h3 id="vue3的diff优化"><a href="#vue3的diff优化" class="header-anchor">#</a> Vue3的<code>diff</code>优化：</h3> <ol><li><strong>静态树提升</strong>：Vue3可以检测到完全是静态的子树，并且在进行<code>diff</code>的时候直接跳过它们。</li> <li><strong>静态属性提升</strong>：对于那些不会改变的静态属性，Vue3在<code>diff</code>过程中也可以跳过它们。</li> <li><strong>基于块的更新策略</strong>：Vue3引入了基于编译时块的更新策略。这意味着模板中的每一部分（例如：v-if、v-for等）都是一个块，只有当这个块的动态数据发生变化时才会重新渲染，大大减少了不必要的渲染和<code>diff</code>计算。</li> <li><strong>更细粒度的<code>diff</code></strong>：Vue3在编译时可以进行更多的优化，使得<code>diff</code>过程更为细粒度，从而提高性能。</li></ol> <p><strong>结论</strong>：
Vue的<code>diff</code>算法在Vue2和Vue3之间经历了一系列的优化，尤其是在Vue3中引入的编译时优化和基于块的更新策略，使其在性能上有了显著的提升。</p> <h2 id="js-node"><a href="#js-node" class="header-anchor">#</a> js&amp;node</h2> <h3 id="js与ts区别"><a href="#js与ts区别" class="header-anchor">#</a> js与ts区别</h3> <p><strong>JavaScript (JS) vs. TypeScript (TS)</strong>:</p> <ol><li><p><strong>类型系统</strong>：</p> <ul><li><strong>JS</strong>: 动态类型语言。变量的类型在运行时确定。</li> <li><strong>TS</strong>: 静态类型语言。变量的类型在编码时确定，并在编译时进行类型检查。</li></ul></li> <li><p><strong>编译需求</strong>：</p> <ul><li><strong>JS</strong>: 直接在浏览器或其他JavaScript运行时环境中执行。</li> <li><strong>TS</strong>: 需要先被编译成JavaScript，然后才能在浏览器或其他JavaScript环境中执行。</li></ul></li> <li><p><strong>类型注解</strong>：</p> <ul><li><strong>JS</strong>: 不支持类型注解。</li> <li><strong>TS</strong>: 支持类型注解，允许开发者明确指定变量、函数参数和函数返回值的类型。</li></ul></li> <li><p><strong>接口</strong>：</p> <ul><li><strong>JS</strong>: 不支持接口。</li> <li><strong>TS</strong>: 支持接口，允许开发者定义对象的结构和约定。</li></ul></li> <li><p><strong>类和继承</strong>：</p> <ul><li><strong>JS</strong>: 支持基于原型的继承。ES6及之后版本支持类，但类型检查仍然是动态的。</li> <li><strong>TS</strong>: 支持基于类的面向对象编程，并加入了静态类型检查。</li></ul></li> <li><p><strong>泛型</strong>：</p> <ul><li><strong>JS</strong>: 不支持泛型。</li> <li><strong>TS</strong>: 支持泛型，允许创建可重用的组件，同时还可以保持类型信息。</li></ul></li> <li><p><strong>模块系统</strong>：</p> <ul><li><strong>JS</strong>: ES6及之后版本支持模块导入和导出。</li> <li><strong>TS</strong>: 支持模块系统，并可以与JS模块系统无缝协作。</li></ul></li> <li><p><strong>工具和IDE支持</strong>：</p> <ul><li><strong>JS</strong>: 有许多工具和IDE支持。</li> <li><strong>TS</strong>: 由于其静态类型特性，TS通常提供更好的自动完成、重构和错误检查功能。</li></ul></li> <li><p><strong>社区和生态系统</strong>：</p> <ul><li><strong>JS</strong>: 拥有庞大的社区和丰富的生态系统。</li> <li><strong>TS</strong>: 社区正在增长，并且很多流行的JS库和框架已经提供或支持TS类型定义。</li></ul></li></ol> <p><strong>结论</strong>：
JavaScript是一种动态类型的解释型语言，而TypeScript是JavaScript的一个超集，添加了静态类型、接口、泛型等特性，增强了代码的可读性和可维护性，同时提供了更强大的工具支持。</p> <h3 id="js数据类型有哪些-基本数据类型和引用数据类型的区别"><a href="#js数据类型有哪些-基本数据类型和引用数据类型的区别" class="header-anchor">#</a> js数据类型有哪些？基本数据类型和引用数据类型的区别？</h3> <ol><li><p><strong>基本（原始）数据类型</strong>:</p> <ul><li><strong>Number</strong>: 表示整数和浮点数。</li> <li><strong>String</strong>: 表示文本数据，用单引号、双引号或反引号表示。</li> <li><strong>Boolean</strong>: 表示逻辑值，有两个值，<code>true</code>或<code>false</code>。</li> <li><strong>Undefined</strong>: 表示未定义的值，通常为声明但未初始化的变量的默认值。</li> <li><strong>Null</strong>: 表示一个空值，通常表示一个无值的对象。</li> <li><strong>Symbol</strong> (ES6+): 创建唯一的标识符。</li> <li><strong>BigInt</strong> (ES2020+): 表示大整数。</li></ul></li> <li><p><strong>引用数据类型</strong>:</p> <ul><li><strong>Object</strong>: 表示一个对象，是键值对的集合。
<ul><li><strong>Array</strong>: 特殊的对象，表示一个有序的元素列表。</li> <li><strong>Function</strong>: 特殊的对象，可以被调用执行。</li> <li><strong>Date</strong>, <strong>RegExp</strong>, <strong>Map</strong>, <strong>Set</strong>等也是特殊的对象。</li></ul></li></ul></li></ol> <p><strong>基本数据类型与引用数据类型的主要区别</strong>:</p> <ol><li><p><strong>存储位置</strong>:</p> <ul><li><strong>基本数据类型</strong>: 存储在栈内存中，占用空间固定。</li> <li><strong>引用数据类型</strong>: 变量存储在栈内存中，但它的值是一个指针，该指针指向堆内存中的对象。</li></ul></li> <li><p><strong>值的复制</strong>:</p> <ul><li><strong>基本数据类型</strong>: 当复制基本类型的值时，会创建该值的一个拷贝。</li> <li><strong>引用数据类型</strong>: 当复制对象时，复制的是对象的地址（指针），这意味着两个变量指向的是堆内存中的同一个对象。</li></ul></li> <li><p><strong>访问方式</strong>:</p> <ul><li><strong>基本数据类型</strong>: 通过值访问。</li> <li><strong>引用数据类型</strong>: 通过引用（或指针）访问。</li></ul></li> <li><p><strong>可变性</strong>:</p> <ul><li><strong>基本数据类型</strong>: 值是不可变的。</li> <li><strong>引用数据类型</strong>: 值是可变的，可以对对象的属性进行添加、删除或修改。</li></ul></li></ol> <p><strong>结论</strong>:
基本数据类型存储的是实际的值，而引用数据类型存储的是指向对象的地址。基本数据类型的值是不可变的，而引用数据类型的对象可以被修改。</p> <h3 id="javascript-里的数据类型。判断数据类型有哪些方法"><a href="#javascript-里的数据类型。判断数据类型有哪些方法" class="header-anchor">#</a> JavaScript 里的数据类型。判断数据类型有哪些方法？</h3> <ol><li><p><strong>typeof 操作符</strong>:</p> <ul><li>用于判断一个变量的数据类型。</li> <li>例如: <code>typeof 'abc'</code> 返回 <code>'string'</code>。</li> <li>注意: <code>typeof null</code> 返回 <code>'object'</code>，这是一个历史遗留的问题。</li></ul></li> <li><p><strong>instanceof 操作符</strong>:</p> <ul><li>用于判断一个对象是否是某个构造函数的实例。</li> <li>例如: <code>[] instanceof Array</code> 返回 <code>true</code>。</li></ul></li> <li><p><strong>Object.prototype.toString.call() 方法</strong>:</p> <ul><li>最准确最常用的方法。</li> <li>例如: <code>Object.prototype.toString.call([])</code> 返回 <code>'[object Array]'</code>。</li></ul></li> <li><p><strong>constructor 属性</strong>:</p> <ul><li>每个对象都有一个 constructor 属性，指向创建该对象的构造函数。</li> <li>例如: <code>(new Date()).constructor === Date</code> 返回 <code>true</code>。</li></ul></li> <li><p><strong>Array.isArray() 方法</strong>:</p> <ul><li>用于判断一个值是否是数组。</li> <li>例如: <code>Array.isArray([])</code> 返回 <code>true</code>。</li></ul></li></ol> <p><strong>注意</strong>:</p> <ul><li><code>typeof</code> 是最简单的方式，但它对于引用类型的判断能力有限，尤其无法准确判断数组和null。</li> <li><code>instanceof</code> 在不同的全局执行环境中可能返回不同的结果，因为它依赖于具体环境中的原型链。</li> <li><code>Object.prototype.toString.call()</code> 是最准确且最常用的方法，它能准确判断各种内置对象类型。</li> <li><code>constructor</code> 需要注意该属性可能会被改变，所以不是最安全的方式。</li> <li><code>Array.isArray()</code> 是判断数组的最佳方法，但只能用于判断数组。</li></ul> <p><strong>示例</strong>:</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">'hello'</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> bool <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> nullValue <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> undefinedValue <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> <span class="token function-variable function">func</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> date <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> regexp <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">abc</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 'string'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 'number'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> bool<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'boolean'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 'object'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 'object'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> nullValue<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 'object'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> undefinedValue<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 'undefined'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> func<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 'function'</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>date <span class="token keyword">instanceof</span> <span class="token class-name">Date</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>regexp <span class="token keyword">instanceof</span> <span class="token class-name">RegExp</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// true</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// '[object Array]'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// '[object Date]'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>regexp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// '[object RegExp]'</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Array<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Object<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>date<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Date<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>regexp<span class="token punctuation">.</span>constructor <span class="token operator">===</span> RegExp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// true</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// true</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><h3 id="如何判断一个变量的类型是不是数组"><a href="#如何判断一个变量的类型是不是数组" class="header-anchor">#</a> 如何判断一个变量的类型是不是数组</h3> <p>Array.isArray() 、 instanceof、 Object.prototype.toString.call()</p> <h3 id="instanceof-和-typeof-的区别。"><a href="#instanceof-和-typeof-的区别。" class="header-anchor">#</a> instanceof 和 typeof 的区别。</h3> <ol><li><p><strong>定义与功能</strong>:</p> <ul><li><strong><code>typeof</code></strong>: 是一个一元操作符，返回一个字符串，表示未经计算的操作数的类型。</li> <li><strong><code>instanceof</code></strong>: 是一个二元操作符，测试一个对象是否在其原型链上具有某个构造函数的 <code>prototype</code> 属性。</li></ul></li> <li><p><strong>返回值</strong>:</p> <ul><li><strong><code>typeof</code></strong>: 返回一个表示类型的字符串（如 'number', 'string', 'function', 'object' 等）。</li> <li><strong><code>instanceof</code></strong>: 返回一个布尔值，表示对象是否为特定构造函数的实例。</li></ul></li> <li><p><strong>使用场景</strong>:</p> <ul><li><strong><code>typeof</code></strong>: 主要用于判断基本数据类型和函数。</li> <li><strong><code>instanceof</code></strong>: 主要用于判断引用数据类型，如数组、对象和自定义类型。</li></ul></li> <li><p><strong>局限性</strong>:</p> <ul><li><strong><code>typeof</code></strong>:
<ul><li>对于数组、null 和对象，<code>typeof</code> 都返回 'object'。</li> <li>不能区分数组和普通对象。</li> <li><code>typeof null</code> 的结果是 'object'，这是一个历史遗留的问题。</li></ul></li> <li><strong><code>instanceof</code></strong>:
<ul><li>只能用于对象，不能用于基本数据类型。</li> <li>不同的全局执行环境会产生不同的构造函数和原型，可能导致不同环境下的检查返回不同的结果。</li></ul></li></ul></li></ol> <p><strong>示例</strong>:</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> <span class="token function-variable function">func</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 'object'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> func<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'function'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 'object'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 'string'</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>func <span class="token keyword">instanceof</span> <span class="token class-name">Function</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// false (因为str是基本数据类型，不是String对象实例)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h3 id="instanceof可靠吗"><a href="#instanceof可靠吗" class="header-anchor">#</a> instanceof可靠吗</h3> <p><code>instanceof</code> 是一个常用的操作符，用于判断对象是否是某个构造函数的实例。但它并不是完全可靠的，以下是其局限性和可能导致不准确判断的情况：</p> <ol><li><p><strong>不同的全局执行环境</strong>:</p> <ul><li>当涉及到多个全局执行环境（例如，多个浏览器窗口或iframe），每个环境都有自己的执行环境和原型链。即使同样的代码在不同的环境中执行，<code>instanceof</code> 的结果也可能不同。</li></ul></li> <li><p><strong>原型链的修改</strong>:</p> <ul><li>如果修改了对象的原型链，使用 <code>instanceof</code> 进行类型判断可能得到意外的结果。</li></ul></li> <li><p><strong>不能识别基本数据类型</strong>:</p> <ul><li><code>instanceof</code> 不能直接判断基本数据类型，只能判断对象。例如，对于基本的字符串、数字或布尔值，使用 <code>instanceof</code> 会返回 <code>false</code>。</li></ul></li> <li><p><strong>对于一些原生对象构造器</strong>:</p> <ul><li>当原生对象构造器在不同的环境中有不同的实现，如 <code>Array</code>，可能会出现一个对象在一个环境中是 <code>Array</code> 的实例，但在另一个环境中不是。</li></ul></li></ol> <p><strong>示例</strong>:</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> iframe <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'iframe'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>iframe<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">iframe<span class="token punctuation">.</span>contentWindow<span class="token punctuation">.</span>Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false, 因为这个数组是在另一个全局执行环境中创建的</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr <span class="token keyword">instanceof</span> <span class="token class-name">iframe<span class="token punctuation">.</span>contentWindow<span class="token punctuation">.</span>Array</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="es6新增特性"><a href="#es6新增特性" class="header-anchor">#</a> ES6新增特性</h3> <ol><li>let 和 const</li></ol> <ul><li>let 提供了块级作用域的变量声明。</li> <li>const 用于声明常量或不可重新赋值的变量。</li></ul> <ol start="2"><li>箭头函数 (=&gt;)</li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">square</span> <span class="token operator">=</span> <span class="token parameter">x</span> <span class="token operator">=&gt;</span> x <span class="token operator">*</span> x<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ol start="3"><li>类 (Classes)
ES6 引入了基于原型的类语法。</li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">height<span class="token punctuation">,</span> width</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>height <span class="token operator">=</span> height<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>width <span class="token operator">=</span> width<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">getArea</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>height <span class="token operator">*</span> <span class="token keyword">this</span><span class="token punctuation">.</span>width<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><ol start="4"><li>模块 (Imports &amp; Exports)
ES6引入了模块化的导入和导出语法。</li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// file: moduleA.js</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">funcA</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// file: moduleB.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> funcA <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./moduleA'</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ol start="5"><li>模板字符串</li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> name <span class="token operator">=</span> <span class="token string">&quot;John&quot;</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hello, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">!</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 &quot;Hello, John!&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ol start="6"><li>默认参数、剩余参数和展开操作符</li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">greet</span><span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">&quot;John&quot;</span><span class="token punctuation">,</span> <span class="token operator">...</span>otherArgs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// John</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>otherArgs<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// [&quot;Doe&quot;, 30]</span>
<span class="token punctuation">}</span>
<span class="token function">greet</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">[</span><span class="token string">&quot;Doe&quot;</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ol start="7"><li>解构赋值</li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> <span class="token punctuation">{</span>x<span class="token punctuation">,</span> y<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ol start="8"><li>Promise
异步编程的一种新方式，可以更简洁地处理异步操作和错误。</li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token comment">/* some condition */</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">&quot;Success!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">&quot;Error!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ol start="9"><li>增强的对象字面量
使得对象初始化语法更简洁和更有表现力。</li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> <span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ol start="10"><li>迭代器和 for...of 循环</li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> value <span class="token keyword">of</span> <span class="token punctuation">[</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;b&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;c&quot;</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 分别打印 &quot;a&quot;, &quot;b&quot;, 和 &quot;c&quot;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ol start="11"><li>新的数据结构
如 Set, Map, WeakSet 和 WeakMap。</li></ol> <ul><li><strong>Set</strong>:
<ul><li><code>Set</code> 是一个集合，可以存储任何类型的唯一值，重复的值将被忽略。</li></ul></li></ul> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> mySet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
mySet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
mySet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
mySet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// This won't be added since it's a duplicate</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>mySet<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li><strong>Map:</strong>
Map 是一个键值对的集合。键和值可以是任何类型。</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> myMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
myMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'ChatGPT'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
myMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">'type'</span><span class="token punctuation">,</span> <span class="token string">'AI'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ChatGPT</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li><strong>WeakSet:</strong>
WeakSet 是一个集合， 仅可以存储对象的弱引用，而不是对象本身。当对象被垃圾回收，WeakSet 会自动删除该对象的引用。
由于其特性，WeakSet 不可遍历。</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> obj2 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> weakSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakSet</span><span class="token punctuation">(</span><span class="token punctuation">[</span>obj1<span class="token punctuation">,</span> obj2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li><strong>WeakMap:</strong>
WeakMap 与 Map 类似，但只接受对象作为键，并且持有的是对象的弱引用。
当对象被垃圾回收，WeakMap 会自动删除该对象的键值对。
由于其特性，WeakMap 的键不可遍历。</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> objKey1 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token string">'key1'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> objKey2 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token string">'key2'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> weakMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
weakMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>objKey1<span class="token punctuation">,</span> <span class="token string">'value1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
weakMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>objKey2<span class="token punctuation">,</span> <span class="token string">'value2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>总结:</p> <ul><li>Set 和 Map 是持有值或键值对的强引用，可以直接遍历。</li> <li>WeakSet 和 WeakMap 是持有对象的弱引用，适用于不希望阻止垃圾回收的场景，但它们的键不可遍历。</li></ul> <ol start="12"><li><p>Symbol 类型
提供了一种创建唯一标识符的方式。</p></li> <li><p>生成器 (Generators)
使用 function* 和 yield 语法创建。</p></li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">simpleGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">yield</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">yield</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">yield</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> gen <span class="token operator">=</span> <span class="token function">simpleGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { value: 1, done: false }</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { value: 2, done: false }</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { value: 3, done: false }</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { value: undefined, done: true }</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><ol start="14"><li>Array、Object 和 String 的新方法
如 Array.from(), Object.assign(), String.startsWith(), 和其他的。</li></ol> <h3 id="数组常用方法"><a href="#数组常用方法" class="header-anchor">#</a> 数组常用方法</h3> <ul><li>push(): 将一个或多个元素添加到数组的末尾。</li> <li>pop(): 移除数组末尾的元素，并返回该元素。</li> <li>unshift(): 将一个或多个元素添加到数组的开头。</li> <li>shift(): 移除数组开头的元素，并返回该元素。</li> <li>concat(): 连接两个或多个数组，返回一个新数组。</li> <li>slice(): 从数组中截取一部分，返回一个新数组。</li> <li>splice(): 在指定位置添加或移除元素</li> <li>forEach(): 对数组中的每个元素执行指定的函数。</li> <li>map(): 对数组中的每个元素执行指定的函数，并返回一个新数组。</li> <li>indexOf() 和 lastIndexOf(): 查找元素在数组中的索引位置。</li></ul> <h3 id="改变this指向"><a href="#改变this指向" class="header-anchor">#</a> 改变this指向</h3> <p>在JavaScript中，你可以使用 bind()、call() 和 apply()，箭头函数和new关键字 这些方法来改变函数内部的 this 指向。这对于在不同的上下文中执行函数时非常有用。</p> <ol><li>bind(): bind() 方法创建一个新函数，其中 this 的值被设置为指定的值，并且在调用时会预先传入一些参数。</li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hello, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">!</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'Alice'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> sayHelloToAlice <span class="token operator">=</span> <span class="token function">sayHello</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">sayHelloToAlice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出：Hello, Alice!</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ol start="2"><li>call(): call() 方法直接调用函数，可以指定函数内部的 this 值，并且可以传入多个参数作为参数列表。</li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">greet</span><span class="token punctuation">(</span><span class="token parameter">greeting</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>greeting<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">!</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'Bob'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">greet</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token string">'Hi'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出：Hi, Bob!</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ol start="3"><li>apply(): apply() 方法和 call() 类似，但参数需要以数组形式传入。</li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">introduce</span><span class="token punctuation">(</span><span class="token parameter">skill1<span class="token punctuation">,</span> skill2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">I'm </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> and I know </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>skill1<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> and </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>skill2<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'Charlie'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">introduce</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'JavaScript'</span><span class="token punctuation">,</span> <span class="token string">'Python'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出：I'm Charlie and I know JavaScript and Python.</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>这些方法可以让你控制函数在不同上下文中的执行方式。选择其中一个方法取决于你需要的功能以及函数的参数传递方式。</p> <h3 id="call-apply-blid区别"><a href="#call-apply-blid区别" class="header-anchor">#</a> call,apply,blid区别</h3> <ol><li>call():</li></ol> <ul><li>call() 方法直接调用函数，并传递一个指定的 this 值和一系列参数作为参数列表。</li> <li>参数：call(thisArg, arg1, arg2, ...)，第一个参数是函数内部的 this 值，后面的参数是函数调用时的参数。</li> <li>作用：即时调用函数，并传递参数。</li></ul> <ol start="2"><li>apply():</li></ol> <ul><li>apply() 方法也直接调用函数，但参数以数组形式传递。</li> <li>参数：apply(thisArg, [arg1, arg2, ...])，第一个参数是函数内部的 this 值，第二个参数是参数数组。</li> <li>作用：即时调用函数，并传递参数数组。</li></ul> <ol start="3"><li>bind():</li></ol> <ul><li>bind() 方法创建一个新函数，其中 this 的值被设置为指定的值，并且在调用时会预先传入一些参数。</li> <li>参数：bind(thisArg, arg1, arg2, ...)，第一个参数是函数内部的 this 值，后面的参数是预先传入的参数。</li> <li>作用：创建一个新函数，可以稍后调用，传入额外参数。</li></ul> <h3 id="防抖和节流的区别-什么情况用节流-什么情况用防抖"><a href="#防抖和节流的区别-什么情况用节流-什么情况用防抖" class="header-anchor">#</a> 防抖和节流的区别？什么情况用节流？什么情况用防抖？</h3> <p>防抖（Debounce）和节流（Throttle）都是用于优化在频繁触发的事件（如滚动、窗口大小调整、用户输入等）中的函数执行。它们的主要区别在于对事件的响应方式不同。</p> <h4 id="防抖-debounce"><a href="#防抖-debounce" class="header-anchor">#</a> <strong>防抖 (Debounce):</strong></h4> <p>防抖的目的是确保函数在一连串连续触发的事件中只执行一次，通常在事件结束后的一段时间内不再触发事件时，才执行一次函数。如果事件在设定的等待时间内再次触发，计时会被重置，函数的执行会被推迟。</p> <p>适用情况：</p> <ul><li>用户输入（例如搜索框）：防止用户连续输入时频繁触发请求，只在用户停止输入后才发起请求。</li> <li>窗口大小调整：避免频繁触发重排和重绘。</li></ul> <h4 id="节流-throttle"><a href="#节流-throttle" class="header-anchor">#</a> <strong>节流 (Throttle):</strong></h4> <p>节流的目的是限制函数在一定时间内执行的频率，确保一段时间内函数不会被连续触发多次。不管事件触发多快，函数都会在一定时间间隔内执行一次。</p> <p>适用情况：</p> <ul><li>滚动事件：在滚动时，限制函数的执行频率，以避免过多计算。</li> <li>鼠标移动：当鼠标移动时，限制函数执行的频率，以提高性能。</li></ul> <h4 id="区别总结"><a href="#区别总结" class="header-anchor">#</a> 区别总结:</h4> <ul><li>防抖：确保函数在事件结束后的一段等待时间内不会被连续触发，只执行一次。</li> <li>节流：限制函数在一定时间内的执行频率，保证函数在一定时间间隔内执行。</li> <li>具体使用哪种方法取决于你的需求。如果需要确保事件连续触发时只执行一次，使用防抖。如果需要限制事件在一定时间间隔内的执行频率，使用节流。</li></ul> <h3 id="axios是做什么的-和ajax区别"><a href="#axios是做什么的-和ajax区别" class="header-anchor">#</a> Axios是做什么的，和ajax区别</h3> <p>Axios 是一个基于 Promise 的 JavaScript 库，用于进行 HTTP 请求。它主要用于在浏览器和 Node.js 中发起 HTTP 请求，并提供了更简单、更方便的方式来处理异步请求和响应。Axios 支持许多功能，如请求和响应的拦截、数据转换、取消请求、错误处理等。</p> <p>与 Axios 类似，XMLHttpRequest 和 fetch 也可以用于发起 HTTP 请求，它们是实现异步通信的传统方法。以下是 Axios 与传统的 XMLHttpRequest（简称XHR）的主要区别：</p> <p><strong>语法和使用:</strong>
Axios：使用 Promise 和链式调用的方式来处理异步请求，更直观且易于使用。
XMLHttpRequest：需要手动编写回调函数，并在不同的事件阶段进行处理。
<strong>功能和特性:</strong>
Axios：提供了丰富的功能，如请求和响应的拦截、数据转换、请求取消、并发请求管理等。
XMLHttpRequest：相对较少的功能，需要额外的库或代码来实现一些高级特性。
<strong>浏览器兼容性:</strong>
Axios：支持现代浏览器和 Node.js，可以在不同环境中使用。
XMLHttpRequest：较老版本的浏览器可能存在一些兼容性问题，但是作为一个原生的 API，在大部分浏览器中都可以使用。
<strong>请求和响应的拦截:</strong>
Axios：可以在请求发送前和响应返回后拦截并对它们进行处理。
XMLHttpRequest：没有内置的拦截机制，需要通过手动编写代码来实现类似的功能。
总的来说，Axios 提供了更现代、更易用的方式来处理 HTTP 请求，尤其在处理复杂的异步操作和数据转换时非常方便。但 XMLHttpRequest 仍然是原生的浏览器提供的方式，可以在一些简单的场景中使用。fetch 是另一个原生的替代方案，它类似于 Axios，但在一些方面可能需要更多的额外处理。</p> <h3 id="ajax原理-实现-请求体写在哪"><a href="#ajax原理-实现-请求体写在哪" class="header-anchor">#</a> ajax原理，实现，请求体写在哪</h3> <p>AJAX（Asynchronous JavaScript and XML） 是一种在不刷新整个页面的情况下，通过 JavaScript 异步地向服务器发送请求并获取数据的技术。它使得网页能够实现局部刷新，提升用户体验，而无需重新加载整个页面。</p> <p><strong>AJAX 原理：</strong></p> <ul><li>创建 XMLHttpRequest 对象：使用 JavaScript 创建一个 XMLHttpRequest 对象，它允许你发起 HTTP 请求。</li> <li>指定请求参数：使用该对象的 open() 方法指定请求的方法（GET、POST 等）、URL、是否异步等。</li> <li>设置回调函数：使用 onreadystatechange 事件监听器，指定一个回调函数，用于处理服务器响应。</li> <li>发送请求：调用 send() 方法发送请求到服务器。</li> <li>服务器处理：服务器处理请求，返回响应数据。</li> <li>解析响应：当接收到响应数据时，onreadystatechange 事件被触发，你可以在回调函数中处理服务器的响应。</li></ul> <p><strong>AJAX 实现示例：</strong></p> <p>以下是一个使用原生 JavaScript 实现 AJAX 请求的简单示例，其中请求体写在 send() 方法中。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">&quot;POST&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;https://example.com/api&quot;</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 配置请求参数</span>
xhr<span class="token punctuation">.</span><span class="token function">setRequestHeader</span><span class="token punctuation">(</span><span class="token string">&quot;Content-Type&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;application/json&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 设置请求头</span>
xhr<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>readyState <span class="token operator">===</span> <span class="token number">4</span> <span class="token operator">&amp;&amp;</span> xhr<span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> responseData <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>responseText<span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>responseData<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> requestBody <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">key</span><span class="token operator">:</span> <span class="token string">&quot;value&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 请求体</span>
xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>requestBody<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 发送请求</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p><strong>请求体写在哪：</strong>
在上述示例中，请求体是通过 send() 方法的参数传递的。对于 POST 请求，通常将请求体数据作为参数传递给 send() 方法。请求体的内容要根据服务器端的接收格式（如 JSON、表单数据等）进行相应的序列化，以确保服务器能够正确解析数据。在示例中，我们使用 JSON.stringify() 将 JavaScript 对象转换为 JSON 字符串作为请求体。</p> <p>需要注意，如果使用 GET 请求，请求体通常不会被使用，因为数据会附加在 URL 的查询参数中。</p> <h3 id="箭头函数有了解过吗-跟普通的函数有什么区别"><a href="#箭头函数有了解过吗-跟普通的函数有什么区别" class="header-anchor">#</a> 箭头函数有了解过吗？跟普通的函数有什么区别？</h3> <ul><li>语法简洁：箭头函数可以使用更简洁的语法来定义函数，尤其在单行函数中更明显。</li> <li>没有自己的 this：箭头函数没有自己的 this，它会继承父级作用域的 this 值。这意味着箭头函数内部无法通过 this 来访问函数自身的属性，也不能用作构造函数。</li> <li>没有 arguments 对象：箭头函数也没有自己的 arguments 对象，同样是继承父级作用域的。</li> <li>不能用作构造函数：由于箭头函数没有自己的 this，所以不能用作构造函数来创建对象。</li> <li>没有 super：箭头函数没有 super 关键字，不能用于访问父级类的属性和方法。</li> <li>没有 prototype 属性：箭头函数没有 prototype 属性，因此不能作为构造函数创建实例。</li></ul> <p>在简单的情况下，箭头函数更具可读性和简洁性。然而，由于箭头函数没有自己的 this 和 arguments，在需要访问这些值的情况下，传统函数表达式可能更为适用。选择使用哪种函数形式取决于具体的使用场景和需要。</p> <h3 id="数组方法-map和foreach区别"><a href="#数组方法-map和foreach区别" class="header-anchor">#</a> 数组方法，map和foreach区别</h3> <p><strong>map() 方法：</strong>
map() 方法创建一个新数组，该数组由原数组中的每个元素经过函数处理后的返回值组成。原数组不受影响。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> originalArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> newArray <span class="token operator">=</span> originalArray<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> item <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [2, 4, 6, 8]</span>
<span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 返回一个新数组，原数组不会被修改，可以将处理后的结果存储在新的数组中。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>forEach() 方法：</strong>
forEach() 方法用于遍历数组中的每个元素，并对每个元素执行指定的操作。它不会创建新的数组，只是在遍历过程中对元素进行操作。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
array<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 只用于遍历数组，它没有返回值，而是直接在遍历过程中执行指定的操作。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>区别总结：</strong></p> <ul><li>map() 返回一个新数组，包含原数组每个元素经过处理后的返回值。</li> <li>forEach() 遍历数组，对每个元素执行指定的操作，没有返回值，也不会创建新数组。</li> <li>如果你需要对数组进行操作并返回一个新数组，使用 map()。如果只是需要遍历数组并执行操作，使用 forEach()。</li></ul> <p>选择使用哪个方法取决于你的需求：是否需要创建新数组，或只是在遍历中执行操作。</p> <h3 id="typescript泛型有哪些"><a href="#typescript泛型有哪些" class="header-anchor">#</a> typescript泛型有哪些</h3> <p>TypeScript 的泛型（Generics）是一种在函数、类、接口等中使用类型变量来增强代码的灵活性和重用性的特性。它允许你在定义时不指定具体的类型，而在使用时再传入具体的类型参数。</p> <ol><li>泛型函数：</li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> identity<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> value<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> result <span class="token operator">=</span> identity<span class="token operator">&lt;</span>number<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 显式指定类型参数</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ol start="2"><li>泛型接口：</li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">interface</span> <span class="token class-name">ArrayWrapper</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token function">add</span><span class="token punctuation">(</span>item<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> <span class="token literal-property property">stringArray</span><span class="token operator">:</span> ArrayWrapper<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><ol start="3"><li>泛型类：</li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Box</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token constant">T</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> numberBox <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Box</span><span class="token operator">&lt;</span>number<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ol start="4"><li>泛型约束：可以对泛型类型参数添加约束，限制允许的类型范围。</li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">interface</span> <span class="token class-name">Lengthy</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">length</span><span class="token operator">:</span> number<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> getLength<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">Lengthy</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>obj<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> number <span class="token punctuation">{</span>
  <span class="token keyword">return</span> obj<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> stringLength <span class="token operator">=</span> <span class="token function">getLength</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 5</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><ol start="5"><li>默认类型参数：在泛型中可以为类型参数指定默认类型。</li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> defaultValue<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token operator">=</span> string<span class="token operator">&gt;</span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> value<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> stringValue <span class="token operator">=</span> <span class="token function">defaultValue</span><span class="token punctuation">(</span><span class="token string">&quot;Default&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;Default&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="对js继承有了解吗"><a href="#对js继承有了解吗" class="header-anchor">#</a> 对Js继承有了解吗？</h3> <p><strong>ES6类继承：</strong>
ES6引入了类（class）和继承的概念，使继承更加清晰和易用。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hello, my name is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用父类构造函数</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> childObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'Bob'</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
childObj<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用从父类继承的方法</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>ES6类继承通过 extends 关键字来实现，同时使用 super 调用父类构造函数。这样的语法更加直观和易于理解。</p> <p>总之，继承是面向对象编程中的重要概念，可以让你在不重复编写代码的情况下，从现有的对象或类中继承属性和方法。</p> <h3 id="对原型链有了解吗-什么是原型链-原型链的终点-function-prototype指向哪"><a href="#对原型链有了解吗-什么是原型链-原型链的终点-function-prototype指向哪" class="header-anchor">#</a> 对原型链有了解吗？什么是原型链？原型链的终点？Function.prototype指向哪？</h3> <p>是的，我了解原型链。在JavaScript中，原型链是一种对象之间通过原型属性相互关联的机制，它允许对象继承另一个对象的属性和方法。每个对象都有一个原型（prototype），对象通过原型链连接在一起，形成一个层次结构。</p> <p><strong>原型链的概念：</strong></p> <p>每个对象都有一个原型，除了 null。当你访问一个对象的属性或方法时，如果该对象本身没有这个属性或方法，JavaScript会沿着原型链继续查找，直到找到对应的属性或方法或者到达原型链的终点。</p> <p><strong>原型链的终点：</strong></p> <p>原型链的终点是 Object.prototype，它是所有对象的最顶层原型。Object.prototype 没有自己的原型，它的 <strong>proto</strong> 属性指向 null。</p> <p><strong>Function.prototype：</strong></p> <p>在 JavaScript 中，函数也是对象，它们也有原型。Function.prototype 是一个函数的原型对象，它是所有函数对象的原型。函数的原型对象包含一些通用的属性和方法，例如 call()、apply() 和 bind() 等。</p> <p>需要注意的是，函数是由 Function 构造函数创建的，而 Function 自身也是一个函数。所以，Function.prototype 本身也是一个对象，并且它的原型是 Object.prototype。</p> <p>在继承中，函数的原型对象会连接到 Function.prototype，从而让函数对象可以继承函数原型对象中的属性和方法。</p> <p>总之，原型链是 JavaScript 中的一个重要概念，它使得对象可以通过原型属性继承其他对象的属性和方法，最终连接到 Object.prototype。</p> <h3 id="原型链的机制与使用场景"><a href="#原型链的机制与使用场景" class="header-anchor">#</a> 原型链的机制与使用场景</h3> <p><strong>原型链的机制：</strong></p> <p>原型链是 JavaScript 中对象之间通过原型属性建立关联的机制。每个对象都有一个原型（<strong>proto</strong>），指向另一个对象。当访问一个对象的属性或方法时，如果该对象本身没有该属性或方法，JavaScript 引擎会沿着原型链逐级向上查找，直到找到对应的属性或方法，或者到达原型链的终点（即 Object.prototype）。</p> <p>这种机制使得对象可以通过继承和共享属性和方法，从而实现代码的复用和扩展。</p> <p><strong>原型链的使用场景：</strong></p> <p>继承：原型链是 JavaScript 实现继承的基础。你可以通过构造函数和原型链来创建对象之间的继承关系，从父对象继承属性和方法。</p> <p>方法共享：通过原型链，多个对象可以共享相同的方法。这对于减少内存占用和代码复用非常有用。</p> <p>属性和方法的查找：如果一个对象的属性或方法不在当前对象上，JavaScript 引擎会沿着原型链查找它们。这使得代码可以在不同的层级上进行查找，提高了灵活性。</p> <p>内置对象和功能扩展：内置对象如 Array、String 等都是通过原型链扩展而来的。你也可以通过扩展原型链来给内置对象添加自定义方法。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 原型链继承</span>
<span class="token keyword">function</span> <span class="token function">Animal</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">Animal</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">speak</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> makes a sound.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">Dog</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> breed</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">Animal</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>breed <span class="token operator">=</span> breed<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">Dog</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Animal</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Dog</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Dog<span class="token punctuation">;</span>

<span class="token keyword">const</span> myDog <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token string">'Buddy'</span><span class="token punctuation">,</span> <span class="token string">'Golden Retriever'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
myDog<span class="token punctuation">.</span><span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Buddy makes a sound.</span>

<span class="token comment">// 方法共享</span>
<span class="token keyword">function</span> <span class="token function">SharedFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token class-name">SharedFunction</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">showInfo</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Shared function is called.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> obj1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SharedFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> obj2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SharedFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
obj1<span class="token punctuation">.</span><span class="token function">showInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Shared function is called.</span>
obj2<span class="token punctuation">.</span><span class="token function">showInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Shared function is called.</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><h3 id="什么数据存在对象中-什么数据存在prototype中"><a href="#什么数据存在对象中-什么数据存在prototype中" class="header-anchor">#</a> 什么数据存在对象中，什么数据存在prototype中</h3> <p>在 JavaScript 中，对象和其原型链中的属性和数据有不同的存储方式和作用。通常情况下，以下规则适用于数据的存储位置：</p> <p>对象中存储的数据：</p> <ol><li>实例属性：每个对象实例可以拥有自己的属性，这些属性存储在对象本身上。</li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span> <span class="token comment">// 实例属性</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;Alice&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;Bob&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Alice</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person2<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Bob</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ol start="2"><li>对象方法：对象中的方法是存储在对象本身上的函数。</li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> car <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">brand</span><span class="token operator">:</span> <span class="token string">&quot;Toyota&quot;</span><span class="token punctuation">,</span>
  <span class="token function-variable function">start</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>brand<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> is starting.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

car<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Toyota is starting.</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>原型中存储的数据：</p> <ol><li>原型属性：原型对象上的属性可以被多个实例共享。这些属性存储在原型对象上。</li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Animal</span><span class="token punctuation">(</span><span class="token parameter">type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">=</span> type<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">Animal</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>sound <span class="token operator">=</span> <span class="token string">&quot;Unknown&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> cat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token string">&quot;Cat&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> dog <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token string">&quot;Dog&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat<span class="token punctuation">.</span>sound<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Unknown (从原型继承)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>dog<span class="token punctuation">.</span>sound<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Unknown (从原型继承)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><ol start="2"><li>原型方法：原型对象上的方法也可以被多个实例共享。这些方法存储在原型对象上。</li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Shape</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token class-name">Shape</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">area</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token string">&quot;Shape area calculation.&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">Circle</span><span class="token punctuation">(</span><span class="token parameter">radius</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>radius <span class="token operator">=</span> radius<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Circle</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Shape</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> circle <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Circle</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>circle<span class="token punctuation">.</span><span class="token function">area</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Shape area calculation.</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>总之，实例属性和方法存储在对象本身上，而原型属性和方法存储在原型对象上。通过原型链，对象可以继承和共享原型中的属性和方法，从而实现代码的重用和扩展。</p> <h3 id="package-json相关-name和module区别。dependencies"><a href="#package-json相关-name和module区别。dependencies" class="header-anchor">#</a> package.json相关：name和module区别。dependencies</h3> <ul><li>name 字段定义项目的名称，必须唯一。</li> <li>module 字段定义 ES6 模块的入口路径。</li> <li>dependencies 字段列出项目的生产环境依赖。</li></ul> <h3 id="js事件模型与事件循环机制"><a href="#js事件模型与事件循环机制" class="header-anchor">#</a> JS事件模型与事件循环机制</h3> <p>JavaScript 事件模型和事件循环机制是理解异步编程在浏览器和Node.js中运行原理的关键概念。</p> <h4 id="javascript-事件模型"><a href="#javascript-事件模型" class="header-anchor">#</a> JavaScript 事件模型：</h4> <p>JavaScript 中的事件模型基于事件驱动编程的思想。在浏览器环境中，用户与页面交互、网络请求完成、计时器到期等都可以触发事件。每个事件都被封装成一个事件对象，包含相关的信息和数据。</p> <p>开发者可以通过添加事件监听器（也称为事件处理函数）来响应特定事件。事件监听器会注册到特定的事件上，当事件触发时，监听器会被调用。</p> <h4 id="javascript-事件循环机制"><a href="#javascript-事件循环机制" class="header-anchor">#</a> JavaScript 事件循环机制：</h4> <p>JavaScript 是单线程的语言，这意味着它在任意时刻只能执行一个任务。然而，JavaScript 支持异步编程，通过事件循环（Event Loop）机制来实现。</p> <p>事件循环是 JavaScript 异步编程的核心。它负责管理任务队列和调用栈。在事件循环中，主要有以下几个重要的组成部分：</p> <ul><li>调用栈（Call Stack）：用于存储当前执行的函数调用链。当一个函数被调用时，它会被推入调用栈，当函数执行完毕时，它会从调用栈中弹出。</li> <li>任务队列（Task Queue）：存储异步任务的队列，比如事件、定时器、网络请求的回调等。</li> <li>微任务队列（Microtask Queue）：存储微任务的队列，微任务通常包括 Promise 的回调和 DOM 变动观察器（Mutation Observer）的回调。</li></ul> <p>事件循环的过程是：</p> <ul><li>执行当前调用栈中的任务。</li> <li>检查微任务队列，执行所有微任务。</li> <li>从任务队列中取出一个任务，执行它。</li> <li>重复上述步骤。</li></ul> <p>这样的循环使得 JavaScript 在处理异步任务时，能够保持单线程的特性，同时不会阻塞其他任务的执行。</p> <p>总之，JavaScript 事件模型和事件循环机制是理解异步编程和事件驱动的基础。理解这些概念有助于优化代码的性能，避免阻塞，提供更好的用户体验。</p> <h3 id="微任务和宏任务"><a href="#微任务和宏任务" class="header-anchor">#</a> 微任务和宏任务</h3> <p>事件循环（Event Loop）是 JavaScript 运行时的一种机制，用于管理代码的执行顺序，以实现异步编程。在 JavaScript 中，任务被分为微任务（Microtask）和宏任务（Macrotask），它们被放置在不同的任务队列中，并在事件循环中执行。</p> <ul><li>微任务（Microtask）： 微任务是一些需要尽快执行的任务，比如 Promise 的回调、process.nextTick（Node.js 中的微任务）等。微任务队列的执行优先级比宏任务高，即在当前执行栈为空时，会立即执行微任务队列中的所有任务。这意味着微任务在当前任务完成后立即执行，不会阻塞下一个宏任务的执行。</li> <li>宏任务（Macrotask）： 宏任务包括一些需要延迟执行的任务，比如 setTimeout、setInterval、DOM 事件等。宏任务会在当前的执行栈为空时，从宏任务队列中取出一个任务执行。不同类型的宏任务有不同的优先级，通常 setTimeout 和 setInterval 的延迟时间会影响它们的执行顺序。</li></ul> <p>事件循环的基本流程如下：</p> <ol><li>执行当前执行栈中的同步代码，直至执行栈为空。</li> <li>检查微任务队列，如果有微任务，依次执行微任务直至微任务队列为空。</li> <li>从宏任务队列中取出一个宏任务，执行它的代码。</li> <li>回到步骤 1，重复执行。
这个循环过程会一直持续，直到没有微任务和宏任务为止。微任务在当前循环内执行，而宏任务则需要等待下一个循环开始时执行。</li></ol> <p>示例代码：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;3&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;4&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>在这个例子中，输出的顺序会是：1 -&gt; 4 -&gt; 3 -&gt; 2。因为微任务的执行优先级高于宏任务，所以 Promise 回调会在 setTimeout 中的代码之前执行。这是因为微任务队列会在当前执行栈为空时立即执行。</p> <h3 id="栅格瓦片数据的渲染优化方式-分级渲染-软加载"><a href="#栅格瓦片数据的渲染优化方式-分级渲染-软加载" class="header-anchor">#</a> 栅格瓦片数据的渲染优化方式，分级渲染，软加载</h3> <p>栅格瓦片数据的渲染优化是在地图应用中常见的问题，特别是在处理大规模地图数据时。以下是两种常见的优化方式：分级渲染和软加载。</p> <h4 id="分级渲染-level-of-detail-简称lod"><a href="#分级渲染-level-of-detail-简称lod" class="header-anchor">#</a> 分级渲染（Level of Detail，简称LOD）：</h4> <p>分级渲染是一种根据地图缩放级别选择性加载和渲染瓦片的技术。它通过在不同缩放级别下使用不同细节级别的瓦片来提高性能。</p> <ul><li>预定义瓦片层级：将地图的瓦片数据分为不同的层级，每个层级包含一组瓦片数据，细节逐级增加。</li> <li>根据缩放级别选择加载：随着用户地图的缩放，选择加载与当前缩放级别匹配的瓦片数据。低缩放级别显示整体地图，高缩放级别显示详细地图。</li> <li>渲染优化：在低缩放级别下，只加载少量瓦片以提高性能。在高缩放级别下，加载更多细节的瓦片。</li></ul> <h4 id="软加载-lazy-loading"><a href="#软加载-lazy-loading" class="header-anchor">#</a> 软加载（Lazy Loading）：</h4> <p>软加载是指只加载当前视窗范围内的瓦片数据，以及用户预期可能浏览到的附近区域的瓦片数据，而不是一次性加载整个地图。</p> <ul><li>视窗管理：根据用户当前的地图视窗范围，计算出需要显示的瓦片范围。</li> <li>加载优化：只加载视窗范围内的瓦片数据，同时预加载用户可能浏览到的附近区域的瓦片。</li> <li>滚动加载：当用户滚动或移动地图时，根据新的视窗范围，动态加载新的瓦片数据。</li></ul> <p>这两种优化方式可以单独或联合使用，根据具体情况选择最适合的策略。分级渲染可以在不同缩放级别下提供更好的细节，而软加载可以降低初始加载成本和提高地图浏览的流畅性。</p> <h3 id="for-in-for-of-的区别-遍历数组用什么"><a href="#for-in-for-of-的区别-遍历数组用什么" class="header-anchor">#</a> for…in… for…of…的区别， 遍历数组用什么</h3> <h4 id="for-in-循环"><a href="#for-in-循环" class="header-anchor">#</a> for...in 循环：</h4> <p>for...in 用于遍历对象的可枚举属性，包括对象自身的属性以及继承的属性。不建议用于遍历数组，因为可能会遍历到数组的非数值属性。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token literal-property property">c</span><span class="token operator">:</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h4 id="for-of-循环"><a href="#for-of-循环" class="header-anchor">#</a> for...of 循环：</h4> <p>for...of 用于遍历可迭代对象，如数组、字符串、Map、Set 等。它遍历的是对象的值，而不是索引或键。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> value <span class="token keyword">of</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h4 id="foreach-方法"><a href="#foreach-方法" class="header-anchor">#</a> forEach 方法：</h4> <p>forEach 是数组的一个方法，用于遍历数组的每个元素。它接收一个回调函数作为参数，对数组的每个元素都执行一次回调函数。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">value</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h4 id="遍历数组的选择"><a href="#遍历数组的选择" class="header-anchor">#</a> 遍历数组的选择：</h4> <p>通常情况下，使用 for...of 或 forEach 遍历数组更为推荐。这两种方法更直观，代码更简洁，并且不会涉及到对象的原型属性。在现代 JavaScript 中，for...of 循环和 forEach 方法是遍历数组的首选方法。</p> <h3 id="js中栈与堆"><a href="#js中栈与堆" class="header-anchor">#</a> js中栈与堆</h3> <h4 id="栈-stack"><a href="#栈-stack" class="header-anchor">#</a> 栈（Stack）：</h4> <p>栈是一种线性数据结构，它采用先进后出（Last In First Out，LIFO）的原则。在 JavaScript 中，栈主要用于存储基本数据类型和函数调用上下文。</p> <ul><li>存储内容：栈存储基本数据类型（如数字、字符串、布尔值）以及函数的调用上下文（函数的参数、局部变量、返回地址等）。</li> <li>内存管理：栈的内存分配和释放由 JavaScript 引擎自动管理。变量的创建和销毁都在栈上进行。</li></ul> <h4 id="堆-heap"><a href="#堆-heap" class="header-anchor">#</a> 堆（Heap）：</h4> <p>堆是一种动态分配内存的区域，用于存储复杂对象，如对象、数组和函数。</p> <ul><li>存储内容：堆存储对象、数组、函数等复杂数据类型。这些数据可以是动态分配的，大小和结构在运行时可以改变。</li> <li>内存管理：堆的内存分配和释放相对复杂，由 JavaScript 的垃圾回收机制自动管理。当对象不再被引用时，垃圾回收器会自动回收其占用的内存空间。</li></ul> <p>JavaScript 中的基本数据类型存储在栈上，而对象、数组等复杂数据类型存储在堆上，而变量则包含指向堆上数据的引用。</p> <h3 id="介绍下闭包-什么样的函数是闭包函数"><a href="#介绍下闭包-什么样的函数是闭包函数" class="header-anchor">#</a> 介绍下闭包，什么样的函数是闭包函数？</h3> <p>闭包是一种在 JavaScript 中常见的概念，它指的是在函数内部定义的函数，可以访问外部函数的变量和作用域，即使外部函数已经执行完毕。</p> <p>闭包通常由两部分组成：内部函数和外部函数。内部函数可以访问外部函数的变量和作用域，即使外部函数已经执行完毕，这是因为闭包会保留外部函数的作用域链。</p> <p>以下是闭包的一个简单示例：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">outerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> outerVariable <span class="token operator">=</span> <span class="token string">'I am from outer function'</span><span class="token punctuation">;</span>
  
  <span class="token keyword">function</span> <span class="token function">innerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>outerVariable<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// innerFunction 可以访问 outerVariable</span>
  <span class="token punctuation">}</span>
  
  <span class="token keyword">return</span> innerFunction<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> closureFunction <span class="token operator">=</span> <span class="token function">outerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">closureFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出：I am from outer function</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>在上面的示例中，innerFunction 是一个闭包函数，它可以访问外部函数 outerFunction 中的 outerVariable 变量，即使 outerFunction 已经执行完毕。</p> <h4 id="闭包函数的特点"><a href="#闭包函数的特点" class="header-anchor">#</a> 闭包函数的特点：</h4> <ul><li>可以访问外部函数的变量：闭包函数可以访问外部函数的局部变量、参数和其他函数，即使外部函数已经执行完毕。</li> <li>保留外部函数的作用域链：闭包函数会保留对外部函数的作用域链的引用，这使得它可以继续访问外部函数的变量。</li></ul> <h4 id="闭包的应用场景"><a href="#闭包的应用场景" class="header-anchor">#</a> 闭包的应用场景：</h4> <ul><li>封装数据：闭包可以用于创建私有变量和方法，通过闭包函数暴露有限的接口来访问这些私有数据。</li> <li>延迟执行：闭包可以用于实现延迟执行，例如在定时器、事件处理函数中。</li> <li>模块化开发：使用闭包可以创建模块化的代码，避免全局命名冲突。</li></ul> <h3 id="闭包的原理"><a href="#闭包的原理" class="header-anchor">#</a> 闭包的原理</h3> <p>闭包的原理涉及到 JavaScript 中的作用域链和垃圾回收机制。让我们更详细地探讨一下闭包的工作原理：</p> <ol><li><p>作用域链：
在 JavaScript 中，每个函数都会创建一个新的作用域。当函数内部访问一个变量时，JavaScript 引擎会首先在当前函数的作用域中查找变量，如果找不到，就会沿着作用域链往外层函数的作用域中查找，直到找到或者到达全局作用域。</p></li> <li><p>函数内部函数：
当在一个函数内部定义另一个函数时，内部函数就成为一个闭包函数。内部函数可以访问外部函数的局部变量和作用域。</p></li> <li><p>引用外部变量：
闭包函数可以引用外部函数的变量，即使外部函数已经执行完毕。这是因为闭包函数的作用域链包括了外部函数的作用域。</p></li> <li><p>保留作用域链：
闭包函数会保留对外部函数作用域链的引用，使得外部函数的变量在闭包函数内部仍然可访问。</p></li> <li><p>内存管理：
由于闭包函数会保留外部函数的作用域链，可能导致外部函数的局部变量无法被垃圾回收机制回收。这可能引发内存泄漏问题。当不再需要闭包函数时，最好手动解除引用，帮助垃圾回收器回收不再使用的变量。</p></li></ol> <p>下面是一个示例，展示了闭包函数的原理：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">outerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> outerVar <span class="token operator">=</span> <span class="token string">&quot;I am from outer&quot;</span><span class="token punctuation">;</span>
  
  <span class="token keyword">function</span> <span class="token function">innerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>outerVar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 闭包函数访问外部变量</span>
  <span class="token punctuation">}</span>
  
  <span class="token keyword">return</span> innerFunction<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> closureFunction <span class="token operator">=</span> <span class="token function">outerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建闭包函数</span>
<span class="token function">closureFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出：I am from outer</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>在上述示例中，innerFunction 是一个闭包函数，它能够访问 outerFunction 的局部变量 outerVar，即使 outerFunction 已经执行完毕。这是因为闭包函数保留了对外部函数作用域的引用。</p> <h3 id="闭包-内存泄漏怎么解决"><a href="#闭包-内存泄漏怎么解决" class="header-anchor">#</a> 闭包，内存泄漏怎么解决</h3> <p>闭包在 JavaScript 中常常会导致内存泄漏问题，特别是当闭包函数引用外部函数的变量，而这些变量在外部函数的生命周期内一直保持引用，导致这些变量无法被垃圾回收。下面是一些解决闭包导致内存泄漏的方法：</p> <ol><li><strong>解除引用：</strong>
最简单的方法是在不再需要闭包函数时，手动解除闭包函数对外部变量的引用。可以将闭包函数的引用设置为 null，这将断开闭包函数和外部变量之间的连接，使得垃圾回收器可以回收它们。</li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">outerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> outerVar <span class="token operator">=</span> <span class="token string">&quot;I am from outer&quot;</span><span class="token punctuation">;</span>
  
  <span class="token keyword">function</span> <span class="token function">innerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>outerVar<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token keyword">return</span> innerFunction<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> closureFunction <span class="token operator">=</span> <span class="token function">outerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 在不再需要 closureFunction 时解除引用</span>
closureFunction <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><ol start="2"><li><p><strong>使用单例模式：</strong>
在某些情况下，可以考虑使用单例模式来管理闭包。在单例模式中，只创建一个闭包函数的实例，确保不会多次引用外部变量。</p></li> <li><p><strong>避免循环引用：</strong>
当闭包函数和外部函数之间形成循环引用时，内存泄漏可能会发生。确保在闭包函数中不引用外部函数本身或其子属性，以避免形成循环引用。</p></li> <li><p><strong>使用事件解绑：</strong>
如果闭包函数作为事件处理函数，确保在事件结束后解绑事件，从而解除闭包对外部变量的引用。</p></li> <li><p><strong>使用块级作用域：</strong>
在 ES6 以及更新的 JavaScript 版本中，可以使用 let 或 const 来声明变量，它们具有块级作用域，有助于在块结束时自动解除引用。</p></li> <li><p><strong>使用WeakMap：</strong>
如果需要在闭包函数中存储外部变量引用，可以考虑使用 WeakMap 来存储，因为 WeakMap 不会阻止外部变量被垃圾回收。</p></li></ol> <p>总之，避免内存泄漏需要仔细管理闭包函数和外部变量之间的引用关系，确保在不再需要时及时解除引用，以便垃圾回收机制能够正常工作。</p> <h3 id="script标签中async和defer的区别"><a href="#script标签中async和defer的区别" class="header-anchor">#</a> script标签中async和defer的区别</h3> <p>async 和 defer 都是用于控制 <code>&lt;script&gt;</code> 标签加载外部脚本时的行为。它们有一些区别，主要涉及到脚本的加载和执行顺序。</p> <h4 id="区别-2"><a href="#区别-2" class="header-anchor">#</a> 区别：</h4> <ol><li>加载时机：</li></ol> <ul><li>使用 async 属性加载的脚本会在下载完成后立即执行，不会阻塞页面的解析和其他资源的加载。(将脚本标记为异步执行)</li> <li>使用 defer 属性加载的脚本会在文档解析完毕后执行，但在 DOMContentLoaded 事件之前。(将脚本标记为延迟执行)</li></ul> <ol start="2"><li>执行顺序：</li></ol> <ul><li>async 属性加载的脚本可能会按照下载完成的顺序执行，而不是在页面中出现的顺序。</li> <li>defer 属性加载的脚本会按照在文档中出现的顺序执行，不会改变原有的顺序。</li></ul> <h4 id="适用场景"><a href="#适用场景" class="header-anchor">#</a> 适用场景：</h4> <ul><li><p>async：</p> <ul><li>当脚本独立于页面内容，不依赖其他脚本，且可以异步加载和执行时，可以使用 async。</li> <li>适用于一些分析、广告或独立的工具脚本，不需要阻塞页面解析。</li></ul></li> <li><p>defer：</p> <ul><li>当需要确保脚本按照在文档中的顺序执行，且在文档解析完毕后执行时，可以使用 defer。</li> <li>适用于需要在页面加载完毕后执行的脚本，且需要访问和操作页面内容。
需要注意的是，async 和 defer 属性只对外部脚本有效，即通过 src 属性引入的脚本文件。对于内联脚本（直接写在 <code>&lt;script&gt;</code> 标签中的脚本），不会受到这两个属性的影响。另外，尽管 defer 保证了脚本的执行顺序，但并不保证在 DOMContentLoaded 事件触发前脚本就已经执行完毕，因此在某些情况下，仍然可能影响页面的性能。</li></ul></li></ul> <h3 id="var-和-let-有什么区别"><a href="#var-和-let-有什么区别" class="header-anchor">#</a> var 和 let 有什么区别？</h3> <h4 id="作用域"><a href="#作用域" class="header-anchor">#</a> 作用域：</h4> <ul><li>使用 var 声明的变量在函数作用域或全局作用域内有效，不具备块级作用域。</li> <li>使用 let 声明的变量具有块级作用域，它们在包含它们的代码块（花括号 {}）内有效。</li></ul> <h4 id="变量提升"><a href="#变量提升" class="header-anchor">#</a> 变量提升：</h4> <ul><li>使用 var 声明的变量会发生变量提升，即变量会在其作用域范围内的任何地方都被声明，但初始化会留在原处。</li> <li>使用 let 声明的变量也会发生变量提升，但在变量声明前使用会导致暂时性死区（Temporal Dead Zone，TDZ），即无法访问该变量。</li></ul> <h4 id="重复声明"><a href="#重复声明" class="header-anchor">#</a> 重复声明：</h4> <ul><li>使用 var 可以重复声明同一个变量，不会报错，后续声明会覆盖前面的声明。</li> <li>使用 let 在同一个作用域内重复声明同一个变量会导致语法错误。</li></ul> <p>示例：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 使用 var</span>
<span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 20</span>

<span class="token comment">// 使用 let</span>
<span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 10</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>在上述示例中，var 的变量声明被提升到函数或全局作用域，所以两次声明的 x 实际上是同一个变量。而使用 let 声明的变量在不同的块级作用域内是独立的。</p> <p>总之，推荐使用 let 来声明变量，因为它更符合现代 JavaScript 的块级作用域概念，能够避免一些由 var 带来的问题。</p> <h3 id="const-和-let-有什么区别"><a href="#const-和-let-有什么区别" class="header-anchor">#</a> const 和 let 有什么区别？</h3> <ul><li>使用 let 声明的变量可以重新赋值，其值可以修改。</li> <li>使用 const 声明的变量在声明时必须初始化，并且一旦初始化后，其值就不能再修改。但对于引用类型（对象、数组等），const 只保证变量指向的引用地址不变，而不保证引用对象的内容不变。</li></ul> <p>使用建议：</p> <ul><li>如果变量不需要重新赋值，应该使用 const 来声明，以增加代码的可读性和可维护性。</li> <li>如果变量可能需要重新赋值，可以使用 let 来声明。</li> <li>如果需要声明的是一个常量，并且不需要在后续代码中重新赋值，应该使用 const。</li></ul> <h3 id="异步编程的方法"><a href="#异步编程的方法" class="header-anchor">#</a> 异步编程的方法</h3> <h4 id="回调函数-callbacks"><a href="#回调函数-callbacks" class="header-anchor">#</a> 回调函数（Callbacks）：</h4> <p>回调函数是最基本的异步编程方式。将一个函数作为参数传递给另一个函数，在操作完成后执行回调函数。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token parameter">callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 模拟异步操作</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token string">&quot;Some data&quot;</span><span class="token punctuation">;</span>
    <span class="token function">callback</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token parameter">data</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h4 id="promise"><a href="#promise" class="header-anchor">#</a> Promise：</h4> <p>Promise 是一种更为结构化的异步编程方式，它代表了一个可能会在未来完成的操作。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 模拟异步操作</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token string">&quot;Some data&quot;</span><span class="token punctuation">;</span>
      <span class="token function">resolve</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">data</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">error</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h4 id="async-await"><a href="#async-await" class="header-anchor">#</a> Async/Await：</h4> <p>Async/Await 是建立在 Promise 基础上的语法糖，使异步代码看起来更像同步代码，更易于理解和维护。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 模拟异步操作</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token string">&quot;Some data&quot;</span><span class="token punctuation">;</span>
      <span class="token function">resolve</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">processData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">processData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><h4 id="事件监听-event-listeners"><a href="#事件监听-event-listeners" class="header-anchor">#</a> 事件监听（Event Listeners）：</h4> <p>通过注册事件监听器来处理异步操作，当某个事件发生时触发相应的处理函数。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> button <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;myButton&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
button<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;click&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Button clicked&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h4 id="定时器-timers"><a href="#定时器-timers" class="header-anchor">#</a> 定时器（Timers）：</h4> <p>使用 setTimeout 或 setInterval 函数来执行一段代码，延迟或定期地进行异步操作。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Delayed operation&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="promise-了解吗"><a href="#promise-了解吗" class="header-anchor">#</a> promise 了解吗？</h3> <p>Promise 是 JavaScript 中处理异步操作的一种机制，它提供了一种更为结构化的方式来处理异步代码，避免了回调地狱（Callback Hell）问题，并使代码更加可读和可维护。</p> <p>Promise 可以看作是一个代表了异步操作最终结果的对象。一个 Promise 可以处于以下三种状态之一：</p> <ul><li>Pending（待定）：初始状态，表示异步操作正在进行中。</li> <li>Fulfilled（已完成）：异步操作成功完成，并返回了结果。</li> <li>Rejected（已拒绝）：异步操作失败，返回了错误信息。</li></ul> <p><strong>Promise 提供了以下几个核心方法：</strong></p> <ul><li>.then(onFulfilled, onRejected)：用于注册在 Promise 成功（Fulfilled）或失败（Rejected）时执行的回调函数。</li> <li>.catch(onRejected)：用于捕获 Promise 被拒绝时的错误，并执行相应的错误处理回调。</li> <li>.finally(onFinally)：用于注册在 Promise 完成时（不论成功或失败）执行的回调函数。</li></ul> <p>示例代码如下：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 模拟异步操作</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> isSuccess <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>isSuccess<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">&quot;Operation successful&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">&quot;Operation failed&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

promise
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">result</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Success:&quot;</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">error</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">&quot;Error:&quot;</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">finally</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Promise completed&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>在实际应用中，Promise 可以用于处理网络请求、文件读取、定时器等异步操作，使代码更加可读，可维护，并且能够处理并发的异步任务。需要注意的是，从 ES6 开始，Promise 已经成为了 JavaScript 的标准特性。</p> <h3 id="promise如果后面有多个-then怎么传值"><a href="#promise如果后面有多个-then怎么传值" class="header-anchor">#</a> promise如果后面有多个.then怎么传值</h3> <p>在 Promise 链式调用中，每个 .then() 方法可以接收前一个 .then() 返回的值，并且可以返回一个新的值或 Promise 对象。这允许您在链中处理和传递值。</p> <p>以下是一个示例，演示如何在多个 .then() 链中传递值：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token string">&quot;Some data&quot;</span><span class="token punctuation">;</span>
      <span class="token function">resolve</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">data</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Step 1:&quot;</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> data <span class="token operator">+</span> <span class="token string">&quot; modified&quot;</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">modifiedData</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Step 2:&quot;</span><span class="token punctuation">,</span> modifiedData<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> modifiedData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">length</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Step 3:&quot;</span><span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">error</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>在上述示例中，每个 .then() 方法接收前一个 .then() 返回的值作为参数，并且可以返回一个新的值或 Promise 对象。这种链式操作使得代码更加清晰和可读。</p> <p>需要注意的是，如果在 .then() 中没有返回值，则后续 .then() 会接收到 undefined。如果在 .then() 中抛出了错误或返回了一个被拒绝的 Promise，错误会被传递到 .catch()。</p> <p>总之，通过 .then() 链式调用，您可以方便地处理 Promise 的异步操作，并在不同步骤中传递和处理值。</p> <h3 id="settimeout-和-promise-的执行顺序"><a href="#settimeout-和-promise-的执行顺序" class="header-anchor">#</a> setTimeout 和 Promise 的执行顺序</h3> <p>在理解 setTimeout 和 Promise 的执行顺序时，需要注意 JavaScript 的事件循环机制。</p> <p><strong>setTimeout：</strong></p> <ul><li><p>setTimeout 函数用于在一段时间之后执行指定的代码。</p></li> <li><p>当调用 setTimeout 时，JavaScript 引擎会将要执行的代码块放入事件队列中，并在指定的时间间隔后将其移动到执行栈中执行。</p></li> <li><p>setTimeout 的回调函数会在当前代码执行完毕后、在主线程空闲时、指定的延迟时间过后才会执行。
<strong>Promise：</strong></p></li> <li><p>Promise 是一种异步操作的管理机制，通过 .then() 或 async/await 处理异步操作的结果。</p></li> <li><p>当创建一个 Promise 并执行异步操作时，Promise 会立即返回一个处于 pending 状态的 Promise 对象。在异步操作完成后，Promise 可能会进入 fulfilled（成功）或 rejected（失败）状态。</p></li> <li><p>.then() 回调函数会在 Promise 的状态发生变化（解决或拒绝）时执行。</p></li></ul> <p>在 JavaScript 中，事件循环机制决定了代码的执行顺序。简单来说，事件循环包括以下步骤：</p> <ol><li>从事件队列中取出一个待执行的任务（如定时器回调或 Promise 的回调函数）。</li> <li>将任务放入执行栈，执行任务中的代码。</li> <li>在执行栈为空之前，重复步骤 1 和 2。</li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Start&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;setTimeout callback&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Promise callback&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;End&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><ol><li>执行第一个 console.log(&quot;Start&quot;)，输出 &quot;Start&quot;。</li> <li>放入 setTimeout 回调函数和 Promise 回调函数到事件队列中。</li> <li>执行 console.log(&quot;End&quot;)，输出 &quot;End&quot;。</li> <li>执行 Promise 回调函数，输出 &quot;Promise callback&quot;。</li> <li>执行 setTimeout 回调函数，输出 &quot;setTimeout callback&quot;。
需要注意的是，尽管在 setTimeout 中设置了延迟为 0，但由于 JavaScript 是单线程执行的，其他同步代码会先于延迟执行的代码执行。</li></ol> <p>总结：在 JavaScript 中，Promise 的回调函数总是会在当前代码执行完成后立即执行，而 setTimeout 的回调函数会在指定的延迟时间之后执行，但要考虑到事件循环机制。</p> <h3 id="promise的三种状态"><a href="#promise的三种状态" class="header-anchor">#</a> promise的三种状态</h3> <p>Promise 有三种状态，它们分别是：</p> <ul><li>Pending（待定）：初始状态，表示异步操作正在进行中，尚未完成也尚未被拒绝。在 Promise 创建时就处于这个状态。</li> <li>Fulfilled（已完成）：也称为 Resolved（已解决），表示异步操作成功完成，并返回了结果。一旦进入 Fulfilled 状态，Promise 的状态就不能再改变，且会执行 .then() 注册的成功回调函数。</li> <li>Rejected（已拒绝）：表示异步操作失败，返回了错误信息。一旦进入 Rejected 状态，Promise 的状态也不能再改变，且会执行 .catch() 或 .then() 注册的失败回调函数。</li></ul> <p>Promise 的状态流转是单向的，即从 Pending 可以转移到 Fulfilled 或 Rejected，但一旦进入 Fulfilled 或 Rejected 就不能再改变。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> isSuccess <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>isSuccess<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">&quot;Operation successful&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 进入 Fulfilled 状态</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">&quot;Operation failed&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 进入 Rejected 状态</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

promise
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">result</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Success:&quot;</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">error</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">&quot;Error:&quot;</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><h3 id="promise和async-await区别"><a href="#promise和async-await区别" class="header-anchor">#</a> promise和async/await区别</h3> <p>Promise 和 async/await 都是用于处理异步操作的机制，但它们在语法上和使用方式上有一些区别。</p> <h4 id="promise-2"><a href="#promise-2" class="header-anchor">#</a> Promise：</h4> <ul><li>语法：使用 .then()、.catch()、.finally() 等方法来处理异步操作。</li> <li>链式调用：Promise 使用链式调用来处理多个异步操作，通过 .then() 方法注册回调函数。</li> <li>处理并发：使用 Promise.all() 可以并发处理多个异步操作，并等待所有操作完成。</li> <li>处理错误：使用 .catch() 可以捕获 Promise 被拒绝时的错误。</li></ul> <h4 id="async-await-2"><a href="#async-await-2" class="header-anchor">#</a> async/await：</h4> <ul><li>语法：使用 async 声明一个异步函数，内部使用 await 来等待异步操作的完成。</li> <li>更接近同步：async/await 让异步代码看起来更像同步代码，提供了更自然的写法。</li> <li>错误处理：使用 try 和 catch 可以捕获异步操作中的错误，使错误处理更加直观。</li> <li>顺序执行：使用 await 会等待前一个异步操作完成后再执行下一个，使得操作按照顺序执行。</li></ul> <h3 id="async-await怎么捕获异常"><a href="#async-await怎么捕获异常" class="header-anchor">#</a> async await怎么捕获异常？</h3> <p>在使用 async/await 进行异步编程时，您可以使用 try 和 catch 来捕获异步操作中可能出现的异常。这使得处理异步操作中的错误更加直观和类似于处理同步代码中的错误。</p> <h3 id="async-await的底层原理-generator的原理"><a href="#async-await的底层原理-generator的原理" class="header-anchor">#</a> async await的底层原理？generator的原理？</h3> <p>async/await 的底层原理涉及到 JavaScript 的生成器（Generator）和 Promise。简要解释一下它的工作原理：</p> <ol><li><p>Promise：async/await 的核心是 Promise，它是一种处理异步操作的标准机制。async 函数返回一个 Promise 对象，而 await 表达式会暂停函数的执行，直到等待的 Promise 解决或拒绝。</p></li> <li><p>生成器（Generator）：生成器是一种特殊类型的函数，可以通过 function* 声明。生成器函数可以在执行过程中暂停并再次恢复，从而实现了可中断的执行。</p></li></ol> <p>在底层，async/await 实际上是基于生成器和 Promise 实现的。编译器和 JavaScript 引擎使用生成器来管理异步代码的执行状态，并且将异步代码转换为 Promise 链。</p> <p>下面是一个简化的示例，展示了 async/await 的工作原理：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 假设有一个异步操作的函数</span>
<span class="token keyword">function</span> <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token string">&quot;Some data&quot;</span><span class="token punctuation">;</span>
      <span class="token function">resolve</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 使用 async/await</span>
<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">processData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Success:&quot;</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">&quot;Error:&quot;</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 上述代码类似于以下基于生成器和 Promise 的实现：</span>

<span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">processDataGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Success:&quot;</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">&quot;Error:&quot;</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 运行生成器函数</span>
<span class="token keyword">const</span> generator <span class="token operator">=</span> <span class="token function">processDataGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> promise <span class="token operator">=</span> generator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>
promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">result</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  generator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 继续执行生成器函数</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">error</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  generator<span class="token punctuation">.</span><span class="token function">throw</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 抛出错误，执行生成器函数中的 catch 块</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br></div></div><p>在上述示例中，async/await 的 processData 函数和基于生成器的 processDataGenerator 函数实现了相同的功能。实际上，async/await 语法更加简洁，使异步代码的编写和理解更加方便。</p> <h3 id="js中-与-有什么区别"><a href="#js中-与-有什么区别" class="header-anchor">#</a> js中 == 与 === 有什么区别</h3> <p>在 JavaScript 中，== 和 === 是用于比较两个值是否相等的运算符，它们之间存在重要的区别。</p> <h4 id="运算符-相等运算符"><a href="#运算符-相等运算符" class="header-anchor">#</a> == 运算符（相等运算符）：</h4> <ul><li>== 运算符用于比较两个值是否相等，但不考虑它们的数据类型。</li> <li>如果两个值的类型不同，会进行类型转换，然后再比较值是否相等。</li> <li>例如，1 == '1' 会返回 true，因为 '1' 会被转换成数字 1。</li></ul> <h4 id="运算符-严格相等运算符"><a href="#运算符-严格相等运算符" class="header-anchor">#</a> === 运算符（严格相等运算符）：</h4> <ul><li>=== 运算符也用于比较两个值是否相等，但严格区分数据类型。</li> <li>只有在两个值的类型和值都相同时，=== 才会返回 true，否则返回 false。</li> <li>例如，1 === '1' 会返回 false，因为它们的类型不同。</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">==</span> <span class="token string">'1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// true，因为进行了类型转换</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">===</span> <span class="token string">'1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// false，因为类型不同</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token boolean">true</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// true，因为 true 被转换为数字 1</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token boolean">true</span> <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false，因为类型不同</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// true，因为它们被认为相等</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">===</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false，因为类型不同</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="setinterval的任务堆积问题-为什么settimeout能解决"><a href="#setinterval的任务堆积问题-为什么settimeout能解决" class="header-anchor">#</a> setInterval的任务堆积问题，为什么settimeout能解决</h3> <p>setInterval 的任务堆积问题和为什么 setTimeout 能够解决这个问题涉及到 JavaScript 事件循环机制。</p> <h4 id="setinterval-的任务堆积问题"><a href="#setinterval-的任务堆积问题" class="header-anchor">#</a> setInterval 的任务堆积问题：</h4> <ul><li>当使用 setInterval 设置定时器时，指定的回调函数会以固定的时间间隔被周期性地执行。</li> <li>如果回调函数的执行时间超过了设定的时间间隔，就会导致多个回调函数被连续触发，从而可能导致任务堆积和性能问题。</li></ul> <h4 id="settimeout-的解决方法"><a href="#settimeout-的解决方法" class="header-anchor">#</a> setTimeout 的解决方法：</h4> <ul><li>使用 setTimeout 来模拟周期性任务，可以在每个任务执行完成后设置下一个任务的定时器。</li> <li>这样做可以确保每个任务完成后等待一定的时间再执行下一个任务，避免了任务堆积的问题。</li></ul> <p>示例代码比较：
<strong>使用 setInterval 会导致任务堆积：</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> intervalId<span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">startInterval</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  intervalId <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Interval task&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 模拟耗时操作</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000000000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>startInterval();</p> <p><strong>使用 setTimeout 避免任务堆积：</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">startTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token function">intervalTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Timeout task&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 模拟耗时操作</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000000000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span>intervalTask<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">setTimeout</span><span class="token punctuation">(</span>intervalTask<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">startTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>在上述示例中，使用 setInterval 可能会导致任务堆积，而使用 setTimeout 则可以在每个任务执行完成后等待一段时间再执行下一个任务，从而避免了堆积问题。当需要实现周期性的操作时，使用 setTimeout 来手动控制任务的触发时间是一种更好的选择。</p> <h3 id="深拷贝和浅拷贝的区别"><a href="#深拷贝和浅拷贝的区别" class="header-anchor">#</a> 深拷贝和浅拷贝的区别？</h3> <h4 id="浅拷贝-shallow-copy"><a href="#浅拷贝-shallow-copy" class="header-anchor">#</a> 浅拷贝（Shallow Copy）：</h4> <ul><li>创建一个新对象，并将原始对象的属性值复制到新对象中。</li> <li>基本数据类型的属性值复制后是两个独立的值，但引用类型的属性值仍然是原始对象和新对象共享的。</li> <li>浅拷贝的属性值只进行一级复制，不会复制引用类型属性的内部关联对象。</li></ul> <h4 id="深拷贝-deep-copy"><a href="#深拷贝-deep-copy" class="header-anchor">#</a> 深拷贝（Deep Copy）：</h4> <ul><li>创建一个新对象，递归地将原始对象的属性值进行复制，包括引用类型的属性值。</li> <li>所有属性值都是独立的，修改新对象不会影响原始对象。</li> <li>深拷贝会复制所有关联对象，包括引用类型属性的内部关联对象。</li></ul> <p>选择深拷贝还是浅拷贝取决于您的需求和应用场景：</p> <ul><li>如果只需要复制对象的一级属性值，并且不需要考虑属性值的关联对象，可以使用浅拷贝。</li> <li>如果需要完全独立的副本，包括属性值的关联对象，应该使用深拷贝</li></ul> <h3 id="如何实现深拷贝"><a href="#如何实现深拷贝" class="header-anchor">#</a> 如何实现深拷贝</h3> <ul><li>递归复制：使用递归遍历对象的每个属性，创建一个新的对象并复制属性值。这是一种自定义实现的方式，可以处理复杂的数据结构和循环引用。</li> <li>JSON 序列化与反序列化：使用 JSON.stringify() 将对象转换为字符串，然后使用 JSON.parse() 将字符串解析为新的对象。这种方式简单，但不能复制函数、正则表达式等特殊对象，并且会丢失原对象的原型链。</li> <li>第三方库：许多 JavaScript 库（如 Lodash、jQuery 等）提供了深拷贝的实现。这些库通常有成熟的算法来处理不同情况，同时提供了更多的选项和功能。</li> <li>结合递归和 Object.assign()：结合使用递归和 Object.assign() 函数来递归地复制属性值。这种方式可以处理普通对象，但对于特殊对象（如 Date、RegExp 等）可能需要特殊处理。</li> <li>结合递归和 Map：使用 Map 数据结构来存储已经复制过的对象，避免循环引用，并使用递归复制属性值。</li> <li>使用第三方库如 cloneDeep：一些第三方库（如 Lodash）提供了高效和全面的深拷贝函数，可以处理各种情况，包括循环引用和特殊对象。</li></ul> <p>不同的实现方式适用于不同的情况，您可以根据需要选择最适合您项目需求的方式。需要注意的是，深拷贝可能会在性能上消耗较多资源，特别是在处理大型对象或嵌套层次较深的对象时。</p> <h2 id="运算符是深拷贝还是浅拷贝"><a href="#运算符是深拷贝还是浅拷贝" class="header-anchor">#</a> ... 运算符是深拷贝还是浅拷贝</h2> <p>... 运算符（展开运算符）用于对象和数组的拷贝时，实际上是浅拷贝。它只会复制一层属性或元素，如果属性值或元素是引用类型，复制后的对象和原始对象仍然会共享这些引用类型属性。</p> <p>因此，... 运算符在复制对象和数组时是浅拷贝，对于实现深拷贝，需要使用其他递归的方式，或者借助于第三方库。对于多层嵌套的对象和数组，... 运算符并不能实现深拷贝。</p> <h3 id="js的严格模式"><a href="#js的严格模式" class="header-anchor">#</a> js的严格模式</h3> <p>JavaScript 严格模式（Strict Mode）是一种在代码中启用严格错误检查和更强制的语法规则的方式。通过在代码的开头添加 'use strict';（或在函数内部添加）来启用严格模式。严格模式有助于捕获一些常见的编程错误，并提供更好的代码优化。</p> <p>严格模式引入了一些不同于非严格模式下的行为和规则，包括：</p> <h4 id="变量声明"><a href="#变量声明" class="header-anchor">#</a> 变量声明：</h4> <ul><li>必须使用 var、let 或 const 关键字来声明变量，不允许隐式创建全局变量。</li> <li>未声明的变量不能被赋值，否则会抛出错误。</li></ul> <h4 id="禁止使用未声明的变量"><a href="#禁止使用未声明的变量" class="header-anchor">#</a> 禁止使用未声明的变量：</h4> <p>在非严格模式下，使用未声明的变量会自动创建一个全局变量。但在严格模式下，使用未声明的变量会导致引发错误。</p> <h4 id="删除不可删除的属性"><a href="#删除不可删除的属性" class="header-anchor">#</a> 删除不可删除的属性：</h4> <p>在严格模式下，不能删除一个标识符引用的变量或函数。</p> <h4 id="禁止重复的参数名和变量名"><a href="#禁止重复的参数名和变量名" class="header-anchor">#</a> 禁止重复的参数名和变量名：</h4> <p>在函数参数列表中禁止使用重复的参数名，以及禁止在相同作用域内使用重复的变量名。</p> <h4 id="禁止八进制字面量"><a href="#禁止八进制字面量" class="header-anchor">#</a> 禁止八进制字面量：</h4> <p>在严格模式下，以 0 开头的数字会被当作十进制数，而不是八进制数。</p> <h4 id="禁止-this-指向全局对象"><a href="#禁止-this-指向全局对象" class="header-anchor">#</a> 禁止 this 指向全局对象：</h4> <p>在全局作用域和函数内部，默认情况下 this 指向全局对象。在严格模式下，在全局作用域内使用 this 会返回 undefined。</p> <h4 id="函数调用时的-this"><a href="#函数调用时的-this" class="header-anchor">#</a> 函数调用时的 this：</h4> <p>在严格模式下，函数作为普通函数调用时（不是作为对象的方法调用），函数内部的 this 值为 undefined，而非严格模式下为全局对象。</p> <h4 id="禁止使用-with-语句"><a href="#禁止使用-with-语句" class="header-anchor">#</a> 禁止使用 with 语句：</h4> <p>with 语句在严格模式下被禁止使用，因为它可以导致代码的不明确和性能问题。</p> <h3 id="new-一个对象发生了什么-执行过程"><a href="#new-一个对象发生了什么-执行过程" class="header-anchor">#</a> new 一个对象发生了什么，执行过程</h3> <ol><li>创建一个新的空对象：一个新的空对象被创建，它将成为新实例的基础。</li> <li>将构造函数的 prototype 链接到新对象：新对象的 <strong>proto</strong> 属性被设置为构造函数的 prototype，这样新对象就能继承构造函数的属性和方法。</li> <li>执行构造函数：构造函数被调用，并且将新对象作为 this 上下文。这使得构造函数可以在新对象上设置属性和执行操作。</li> <li>返回新对象：如果构造函数没有显式地返回一个对象，则 new 表达式将返回这个新创建的对象，成为实例。</li></ol> <h2 id="css"><a href="#css" class="header-anchor">#</a> css</h2> <h3 id="css5新增特性"><a href="#css5新增特性" class="header-anchor">#</a> css5新增特性</h3> <p>CSS3（Cascading Style Sheets 3）是一种用于控制网页样式和布局的技术标准，没有单独的 CSS5 标准。然而，您可能是指 CSS3 中的一些新增特性。以下是一些 CSS3 中的新增特性：</p> <ul><li>Flexbox 布局：Flexbox 是一种弹性盒子布局模型，用于更轻松地设计复杂的布局结构，包括水平和垂直居中、分布空间等。</li> <li>Grid 布局：Grid 布局提供了一个二维的网格系统，用于创建复杂的布局结构，支持网格行列的自动调整和对齐。</li> <li>过渡（Transitions）和动画（Animations）：CSS3 引入了过渡和动画属性，允许开发人员为元素的状态变化添加平滑过渡和动画效果。</li> <li>阴影（Box Shadows）和圆角（Border Radius）：可以通过 CSS3 的属性为元素添加阴影效果和圆角边框，提升界面的美观度。</li> <li>变形（Transforms）：变形属性允许元素在不改变文档布局的情况下进行平移、旋转、缩放和倾斜等操作。</li> <li>渐变（Gradients）：CSS3 提供了线性和径向渐变，允许在元素的背景中创建平滑的颜色过渡效果。</li> <li>多列布局（Multi-column Layout）：可以将内容分成多列，创建报纸或杂志风格的布局。</li> <li>文字效果（Text Effects）：引入了一些属性，如文字阴影、文字轮廓、文字渐变等，以实现独特的文字效果。</li> <li>媒体查询（Media Queries）：允许根据不同的屏幕尺寸和设备类型应用不同的样式，实现响应式设计。</li> <li>自定义字体（@font-face）：允许开发人员使用自定义字体文件，以及在网页中加载并应用这些字体。</li></ul> <h3 id="块级元素居中的几种方式"><a href="#块级元素居中的几种方式" class="header-anchor">#</a> 块级元素居中的几种方式</h3> <p>要将块级元素居中，可以使用不同的方法，取决于具体的布局需求和样式设置。以下是一些常见的方法：</p> <ul><li><strong>使用 margin 居中</strong>： 设置左右的 margin 为 &quot;auto&quot; 可以将块级元素水平居中。</li></ul> <div class="language-css line-numbers-mode"><pre class="language-css"><code><span class="token selector">.element</span> <span class="token punctuation">{</span>
  <span class="token property">margin</span><span class="token punctuation">:</span> 0 auto<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li><strong>使用 flex 布局</strong>： 将包含块级元素的容器设置为 display: flex;，并且使用 justify-content: center; align-items: center; 来水平和垂直居中。</li></ul> <div class="language-css line-numbers-mode"><pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>
  <span class="token property">justify-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>
  <span class="token property">align-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li><strong>使用绝对定位和 transform</strong>： 将块级元素设置为绝对定位，并使用 left: 50%; top: 50%; 进行定位，然后使用 transform: translate(-50%, -50%); 来将元素中心对齐。</li></ul> <div class="language-css line-numbers-mode"><pre class="language-css"><code><span class="token selector">.element</span> <span class="token punctuation">{</span>
  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
  <span class="token property">left</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>
  <span class="token property">top</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>
  <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translate</span><span class="token punctuation">(</span>-50%<span class="token punctuation">,</span> -50%<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>或者<strong>使用 calc()</strong>： position: absolute; left: calc(50% - halfWidth); top: calc(50% - halfHeight); 也行</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code><span class="token selector">.element</span> <span class="token punctuation">{</span>
  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
  <span class="token property">left</span><span class="token punctuation">:</span> <span class="token function">calc</span><span class="token punctuation">(</span>50% - halfWidth<span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token property">top</span><span class="token punctuation">:</span> <span class="token function">calc</span><span class="token punctuation">(</span>50% - halfHeight<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li><strong>使用网格布局</strong>： 将容器设置为网格布局，使用 place-items: center; 或 align-self: center; justify-self: center; 来居中元素。</li></ul> <div class="language-css line-numbers-mode"><pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> grid<span class="token punctuation">;</span>
  <span class="token property">place-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li><strong>使用 text-align 居中内联元素</strong>： 如果块级元素内部只有内联元素，可以通过设置父级元素的 text-align: center; 来使内联元素居中。</li></ul> <div class="language-css line-numbers-mode"><pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>
  <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>选择合适的方法取决于你的布局需求和样式结构。根据不同的情况，你可以采用上述方法中的任意一种来实现块级元素的居中。</p> <h3 id="css垂直居中"><a href="#css垂直居中" class="header-anchor">#</a> css垂直居中</h3> <p>在 CSS 中实现垂直居中可能涉及多种布局方式和场景，以下是一些常见的方法：</p> <p><strong>使用行高（Line Height）</strong>： 对于单行文本内容，可以通过设置父容器的行高与容器高度相同，使文本在容器中垂直居中。</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
  <span class="token property">line-height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>使用 Flex 布局</strong>： 对容器应用 display: flex; 并设置 align-items: center; 可以实现内部元素在容器中垂直居中。</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>
  <span class="token property">align-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>使用绝对定位和 transform</strong>： 对需要垂直居中的元素应用 position: absolute;，然后使用 top: 50%; transform: translateY(-50%); 实现垂直居中。</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code><span class="token selector">.element</span> <span class="token punctuation">{</span>
  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
  <span class="token property">top</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>
  <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translateY</span><span class="token punctuation">(</span>-50%<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>使用 Grid 布局</strong>： 对容器应用 display: grid; 并设置 align-items: center; 可以实现内部元素在容器中垂直居中。</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> grid<span class="token punctuation">;</span>
  <span class="token property">align-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>使用表格布局</strong>： 对容器应用 display: table;，然后在内部元素上使用 display: table-cell; vertical-align: middle; 实现垂直居中。</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> table<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">.element</span> <span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> table-cell<span class="token punctuation">;</span>
  <span class="token property">vertical-align</span><span class="token punctuation">:</span> middle<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>这些方法适用于不同的布局需求和元素类型，具体选择哪种方法取决于实际情况和兼容性要求。同时，不同的 CSS 布局属性在不同浏览器和环境中的支持情况也需要考虑</p> <h3 id="em-rem-vm-vh的区别"><a href="#em-rem-vm-vh的区别" class="header-anchor">#</a> em，rem，vm,vh的区别</h3> <h4 id="em"><a href="#em" class="header-anchor">#</a> em：</h4> <ul><li>em 是相对长度单位，它相对于其父元素的字体大小。如果没有指定字体大小，em 会继承父元素的字体大小。</li> <li>例如，如果一个元素的字体大小为 16px，设置 1em 就等于 16px。如果父元素的字体大小为 20px，那么子元素设置 1em 将等于 20px。</li> <li>em 的一个缺点是，嵌套多层时会产生累积效应，使样式计算相对复杂。</li></ul> <h4 id="rem"><a href="#rem" class="header-anchor">#</a> rem：</h4> <ul><li>rem 也是相对长度单位，但是相对于根元素（通常是 <html> 标签）的字体大小。</html></li> <li>这意味着 rem 在整个页面中都是一致的，不会受到父元素字体大小的影响。</li> <li>rem 是一种更简单、可预测且一致的相对单位。</li></ul> <h4 id="vw-和-vh"><a href="#vw-和-vh" class="header-anchor">#</a> vw 和 vh：</h4> <ul><li>vw 表示视口宽度的百分比，vh 表示视口高度的百分比。</li> <li>视口是用户当前可见的窗口区域。</li> <li>例如，如果视口宽度是 1000px，那么 1vw 就等于 10px。</li></ul> <p><strong>综合比较这些单位：</strong></p> <ul><li>em 和 rem 主要用于字体大小和相对元素尺寸的设置。</li> <li>vw 和 vh 主要用于响应式设计，可以根据视口大小调整元素的尺寸。</li> <li>rem 相对于根元素，不会受到父元素影响，比 em 更可控。</li> <li>vw 和 vh 可以用于创建相对于视口大小的布局和元素尺寸。</li></ul> <h3 id="为什么要用scss-和其他预渲染库的对比。"><a href="#为什么要用scss-和其他预渲染库的对比。" class="header-anchor">#</a> 为什么要用scss，和其他预渲染库的对比。</h3> <p>SCSS（Sass CSS）是一种 CSS 预处理器，它扩展了普通的 CSS，提供了更多的功能和便利性。与其他预渲染库相比，SCSS 有一些优势和特点：</p> <ul><li>嵌套规则：SCSS 允许在样式中使用嵌套规则，使得样式层级更加清晰和可读。这样可以减少选择器的冗余，提高代码的可维护性。</li> <li>变量和计算：SCSS 支持使用变量存储样式属性值，从而可以在多个地方重复使用。此外，SCSS 还允许进行简单的数学计算，减少手动计算。</li> <li>混合（Mixins）：混合是一种可以重用一组样式属性的方式，类似于函数。可以定义一个混合，然后在需要的地方引用，避免重复的样式代码。</li> <li>继承（Extend）：SCSS 允许通过继承一个选择器的样式属性来创建新的选择器。这可以减少代码量并保持一致的样式。</li> <li>导入（Import）：可以将多个 SCSS 文件分开编写，然后使用 @import 导入，提高了代码的组织性和可维护性。</li> <li>条件语句和循环：SCSS 支持条件语句（如 @if、@else）和循环（如 @for、@each）等，使得样式的编写更加灵活和动态。</li> <li>函数：SCSS 允许自定义函数，用于处理样式属性值，从而可以更高效地处理样式逻辑。</li></ul> <h3 id="css权重"><a href="#css权重" class="header-anchor">#</a> css权重</h3> <h4 id="权重-specificity-的计算方式"><a href="#权重-specificity-的计算方式" class="header-anchor">#</a> 权重（specificity）的计算方式：</h4> <ul><li>内联样式的权重为 1000。</li> <li>每个 ID 选择器的权重为 100。</li> <li>每个类选择器、属性选择器和伪类选择器的权重为 10。</li> <li>每个元素选择器和伪元素选择器的权重为 1。</li></ul> <p>计算完各个选择器的权重后，组合成一个四元组（a，b，c，d）来表示权重，其中 a 代表内联样式的数量，b 代表 ID 选择器的数量，c 代表类选择器、属性选择器和伪类选择器的数量，d 代表元素选择器和伪元素选择器的数量。</p> <p>在 CSS 中，当多个样式规则同时应用于同一个元素时，浏览器会根据选择器的权重（specificity）来决定哪个样式规则优先生效。权重是一个衡量样式规则优先级的值，它由多个因素组成，通常用一个四元组（a，b，c，d）表示，其中：</p> <ul><li>a：内联样式的数量（在元素上使用 style 属性的数量）。</li> <li>b：ID 选择器的数量。</li> <li>c：类选择器、属性选择器和伪类选择器的数量。</li> <li>d：元素选择器和伪元素选择器的数量。</li></ul> <p>权重值从左到右依次递增，这意味着更左边的数字比更右边的数字具有更高的优先级。如果在不同的规则中存在相同的权重，那么后面的规则会覆盖前面的规则。</p> <p>以下是一些常见的权重示例：</p> <ul><li>内联样式（a=1，b=0，c=0，d=0）：权重为 (1, 0, 0, 0)</li> <li>ID 选择器（a=0，b=1，c=0，d=0）：权重为 (0, 1, 0, 0)</li> <li>类选择器（a=0，b=0，c=1，d=0）：权重为 (0, 0, 1, 0)</li> <li>元素选择器（a=0，b=0，c=0，d=1）：权重为 (0, 0, 0, 1)</li> <li>通用选择器 *（a=0，b=0，c=0，d=0）：权重为 (0, 0, 0, 0)</li></ul> <p>根据权重的规则，通常情况下，具有更高权重的样式规则会覆盖具有较低权重的规则。需要注意的是，这只是一个一般性的指导，实际情况可能会更复杂，因为还涉及到继承、层叠顺序等因素。</p> <h3 id="css优先级"><a href="#css优先级" class="header-anchor">#</a> css优先级</h3> <p>具体的优先级规则如下：</p> <ol><li>内联样式的权重最高。</li> <li>ID 选择器的权重较高。</li> <li>类选择器、属性选择器、伪类选择器的权重次之。</li> <li>元素选择器、伪元素选择器的权重较低。</li> <li>通用选择器和继承的样式的权重最低。</li></ol> <h3 id="bfc"><a href="#bfc" class="header-anchor">#</a> bfc</h3> <p>BFC，即“块级格式化上下文”（Block Formatting Context），是 CSS 中的一种渲染模型。BFC 是页面上一个独立的渲染区域，它内部的元素按照一定规则进行排列和布局。BFC 的存在和规则使得页面布局更加稳定，能够解决一些布局问题和样式冲突。</p> <h4 id="bfc-形成的条件有"><a href="#bfc-形成的条件有" class="header-anchor">#</a> BFC 形成的条件有：</h4> <ul><li>根元素或包含根元素的元素（比如 <html>）。</html></li> <li>浮动元素（元素的 float 不为 none）。</li> <li>绝对定位元素（元素的 position 为 absolute 或 fixed）。</li> <li>行内块元素（元素的 display 为 inline-block）。</li> <li>表格单元格（元素的 display 为 table-cell）。</li> <li>overflow 属性值不为 visible 的块级元素。</li></ul> <h4 id="bfc-的特性和作用包括"><a href="#bfc-的特性和作用包括" class="header-anchor">#</a> BFC 的特性和作用包括：</h4> <ul><li>边距塌陷的解决：在 BFC 中，相邻块级元素的垂直边距不会塌陷，这可以避免一些布局问题。</li> <li>包含浮动元素：BFC 可以使父元素包含浮动元素，不会塌陷或撑不开。</li> <li>自清除浮动：如果一个元素自身或其子元素浮动，它将形成 BFC，并且不会影响外部元素的布局。</li> <li>防止文字环绕：BFC 可以防止文字环绕浮动元素，使文字不会出现在浮动元素下方。</li> <li>分属于不同 BFC 的元素相互隔离：在不同的 BFC 内，元素的边距和浮动不会相互影响。</li></ul> <p>通过创建 BFC，开发人员可以更好地控制元素的布局和渲染，解决一些常见的布局问题，提高页面的稳定性和可维护性。</p> <h3 id="如何创建bfc"><a href="#如何创建bfc" class="header-anchor">#</a> 如何创建bfc</h3> <p>要创建 BFC（块级格式化上下文），可以通过以下方式来触发元素的 BFC 特性：</p> <ul><li>浮动元素：设置元素的 float 属性为 left 或 right，这将触发 BFC。</li> <li>绝对定位元素：设置元素的 position 属性为 absolute 或 fixed，这将触发 BFC。</li> <li>块级容器：块级容器是一个元素，它内部的子元素形成一个独立的 BFC。常见的块级容器包括具有非默认 display 值的元素，如 display: inline-block、display: table-cell 等。</li> <li>overflow 属性不为 visible 的块级元素：设置元素的 overflow 属性为 auto、hidden 或 scroll，这将触发 BFC。</li> <li>CSS3 Flexbox 容器：设置元素的 display 属性为 flex 或 inline-flex，容器内部的子元素将形成一个 BFC。</li> <li>CSS3 Grid 容器：设置元素的 display 属性为 grid 或 inline-grid，容器内部的子元素将形成一个 BFC。</li></ul> <h3 id="css盒子模型"><a href="#css盒子模型" class="header-anchor">#</a> css盒子模型</h3> <p>CSS 盒子模型是一种用于布局和渲染元素的基本概念，它将每个 HTML 元素视为一个矩形的盒子，该盒子由内容、内边距、边框和外边距组成。盒子模型在页面布局中起着重要作用，它影响元素在页面中的尺寸和排列。</p> <p>CSS 盒子模型分为两种不同的标准：标准盒子模型和IE 盒子模型。在标准盒子模型下，元素的尺寸（width 和 height）仅包括内容区域的尺寸，而在 IE 盒子模型下，元素的尺寸还包括了内边距和边框。</p> <p>以下是标准盒子模型的组成部分：</p> <ul><li>内容区域（Content）：表示元素内部的实际内容，例如文本、图像等。</li> <li>内边距（Padding）：位于内容区域和边框之间，用于增加元素内部的空白间隔。</li> <li>边框（Border）：围绕内容和内边距的线，用于包裹元素的可见部分。</li> <li>外边距（Margin）：位于元素边框外部，用于控制元素之间的间距。</li></ul> <p>在标准盒子模型中，元素的尺寸由内容区域的宽度和高度决定。例如，一个元素的 width 和 height 属性指定的是其内容区域的宽度和高度。
示例 CSS 代码：</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code><span class="token selector">.box</span> <span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
  <span class="token property">padding</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>
  <span class="token property">border</span><span class="token punctuation">:</span> 2px solid black<span class="token punctuation">;</span>
  <span class="token property">margin</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="css常用布局"><a href="#css常用布局" class="header-anchor">#</a> css常用布局</h3> <p>在 CSS 中，有多种常用的布局方式可以用来排列和定位页面中的元素。以下是一些常见的 CSS 布局技术：</p> <ul><li>流式布局（Flow Layout）：默认情况下，HTML 元素会按照文档流从上到下、从左到右进行排列，这种布局方式被称为流式布局。</li> <li>居中布局：将元素居中对齐，可以通过以下方法实现：
<ul><li>水平居中：使用 margin: 0 auto; 或 text-align: center;（对于内联元素）。</li> <li>垂直居中：使用 display: flex; align-items: center; 或绝对定位等方法。</li></ul></li> <li>弹性布局（Flexbox Layout）：使用 CSS3 弹性盒子布局模型，通过 display: flex; 在容器中创建弹性布局，轻松实现水平和垂直对齐、分布和顺序调整。</li> <li>网格布局（Grid Layout）：使用 CSS3 网格布局模型，通过 display: grid; 在容器中创建网格布局，可以将页面划分为行和列，实现复杂的布局需求。</li> <li>定位布局（Positioning Layout）：使用绝对定位（position: absolute;）、相对定位（position: relative;）等方法，将元素精确地定位在父元素中的指定位置。</li> <li>多列布局（Multi-column Layout）：使用 column-count 和 column-width 属性，将内容分为多列显示，类似报纸的排版。</li> <li>响应式布局（Responsive Layout）：使用媒体查询（@media）和百分比等方法，根据不同设备的屏幕大小调整页面布局，以适应不同的分辨率和屏幕尺寸。</li> <li>栅格布局（Grid Systems）：使用栅格系统，将页面分为等宽的列和行，帮助快速创建响应式布局。</li> <li>浮动布局（Float Layout）：通过 float 属性将元素从正常文档流中脱离，实现多列布局，但需要注意处理清除浮动。</li></ul> <p>这些布局技术可以根据您的项目需求和设计要求进行灵活选择和组合，以实现各种不同的页面布局效果。</p> <h3 id="rem原理-有没有考虑过浏览器兼容性"><a href="#rem原理-有没有考虑过浏览器兼容性" class="header-anchor">#</a> rem原理，有没有考虑过浏览器兼容性</h3> <p>关于 rem 单位的原理，rem 是指相对于根元素（通常是 </p><html> 元素）的字体大小的单位。它的值会根据根元素的字体大小进行计算。如果根元素的字体大小为 16px，那么 1rem 就等于 16px。<p></p> <p>例如，假设 HTML 元素的字体大小设置为 16px，而某个元素的宽度设置为 4rem，那么这个元素的宽度将等于 4 * 16px = 64px。</p> <p>关于浏览器兼容性，确实是在选择使用 CSS3 新特性时需要考虑的一个因素。不同的浏览器版本对于 CSS3 的支持程度可能有所不同，一些较老的浏览器可能无法完全支持某些新特性。因此，在使用 CSS3 布局方式时，需要考虑到目标受众所使用的浏览器，并根据情况提供适当的兼容性方案，如使用前缀、媒体查询、回退样式等。您可以通过浏览器兼容性表格或工具来查看不同属性和特性的支持情况，以确保您的布局在各种浏览器上都能正常显示和运行。</p> <h3 id="css哪些属性可以实现布局"><a href="#css哪些属性可以实现布局" class="header-anchor">#</a> CSS哪些属性可以实现布局</h3> <ul><li>display：控制元素的显示类型，如 block、inline、inline-block、flex、grid 等。</li> <li>position：控制元素的定位方式，如 static、relative、absolute、fixed。</li> <li>top、right、bottom、left：与 position: absolute 或 position: fixed 一起使用，控制元素相对于其定位父元素的位置。</li> <li>float：将元素从正常文档流中脱离，实现元素的浮动布局。</li> <li>clear：用于清除浮动，避免浮动元素造成的影响。</li> <li>width、height：控制元素的宽度和高度。</li> <li>max-width、max-height、min-width、min-height：设置元素的最大和最小尺寸。</li> <li>margin：设置元素的外边距，影响元素与其他元素的间距。</li> <li>padding：设置元素的内边距，影响元素内部内容与边框的距离。</li> <li>box-sizing：控制元素的盒子模型，如 content-box、border-box。</li> <li>flexbox 相关属性：flex、flex-direction、justify-content、align-items、align-content 等用于创建弹性布局。</li> <li>grid 相关属性：grid、grid-template-columns、grid-template-rows、grid-gap 等用于创建网格布局。</li> <li>text-align、vertical-align：水平和垂直对齐文本内容或内联元素。</li> <li>position 相关属性：top、right、bottom、left、z-index 等用于定位布局。</li> <li>transform：用于实现元素的变换，如旋转、缩放、平移等。</li> <li>overflow：控制元素内容溢出时的处理方式，如滚动条的显示与隐藏。</li> <li>column 相关属性：column-count、column-width 等用于实现多列布局。</li> <li>white-space：控制文本的换行和空白处理方式。</li></ul> <h3 id="flex-布局-常用的属性有哪些"><a href="#flex-布局-常用的属性有哪些" class="header-anchor">#</a> flex 布局，常用的属性有哪些？</h3> <ul><li>display：将容器设置为弹性容器，通过 display: flex; 或 display: inline-flex; 来启用 Flex 布局。</li> <li>flex-direction：指定主轴的方向，可以是 row（默认，水平排列）、column（垂直排列）、row-reverse（反向水平排列）或 column-reverse（反向垂直排列）。</li> <li>flex-wrap：控制元素在主轴上的换行方式，可以是 nowrap（默认，不换行）、wrap（换行）或 wrap-reverse（反向换行）。</li> <li>flex-flow：是 flex-direction 和 flex-wrap 的缩写，用于同时设置主轴方向和换行方式。</li> <li>justify-content：控制元素在主轴上的对齐方式，可以是 flex-start（默认，起始对齐）、flex-end（末尾对齐）、center（居中对齐）、space-between（两端对齐，元素之间的间隔相等）、space-around（元素周围的间隔相等）或 space-evenly（元素周围的间隔和元素之间的间隔都相等）。</li> <li>align-items：控制元素在侧轴上的对齐方式，可以是 stretch（默认，拉伸对齐，使元素高度相等）、flex-start（起始对齐）、flex-end（末尾对齐）、center（居中对齐）或 baseline（基线对齐）。</li> <li>align-content：控制多行的对齐方式，当有多行元素时生效，可以是 flex-start（起始对齐）、flex-end（末尾对齐）、center（居中对齐）、space-between（两端对齐，行之间的间隔相等）、space-around（行周围的间隔相等）或 stretch（拉伸对齐，使行高度相等）。</li> <li>flex：用于设置元素的伸缩比例，可以为一个非负数，用来分配多余的空间或缩小不足的空间。</li></ul> <h3 id="flex-1-是什么意思"><a href="#flex-1-是什么意思" class="header-anchor">#</a> flex : 1 是什么意思？</h3> <p>是的，当使用 flex: 1; 时，如果容器的可用空间不足以容纳所有具有 flex: 1; 的弹性元素，这些元素会自动缩小，以适应容器的可用空间。</p> <ul><li>flex: 1; 表示元素将占据剩余的可用空间，但如果容器的空间不足以容纳所有 flex: 1; 的元素，浏览器会自动调整这些元素的宽度（或高度，取决于主轴方向），使它们适应容器的空间。这是 Flex 布局的特性之一，使得布局在不同尺寸的容器中都能适应。</li></ul> <h3 id="css的定位详解-position-static-relative-stiky-absolute"><a href="#css的定位详解-position-static-relative-stiky-absolute" class="header-anchor">#</a> css的定位详解？position static relative stiky absolute</h3> <ul><li>position: static; 元素在正常文档流中，不会受 top、right、bottom、left 的影响。</li> <li>position: relative; 元素在正常文档流中，可以使用 top、right、bottom、left 进行相对定位。</li> <li>position: absolute; 元素脱离文档流，相对于最近的非静态定位的祖先元素进行绝对定位。</li> <li>position: fixed; 元素脱离文档流，相对于浏览器窗口进行固定定位，始终保持可见。</li> <li>position: sticky; 元素根据正常文档流定位，在滚动到特定阈值时变为固定定位。</li></ul> <h3 id="box-sizing-属性"><a href="#box-sizing-属性" class="header-anchor">#</a> box-sizing 属性？</h3> <p>box-sizing 属性有两个可能的值：</p> <h4 id="content-box-默认值"><a href="#content-box-默认值" class="header-anchor">#</a> content-box（默认值）：</h4> <ul><li>元素的宽度和高度仅包括内容的宽度和高度，不包括内边距、边框和外边距。</li> <li>也就是说，元素的总宽度和高度等于内容宽度和高度加上内边距和边框的宽度。</li></ul> <h4 id="border-box"><a href="#border-box" class="header-anchor">#</a> border-box：</h4> <ul><li>元素的宽度和高度包括内容、内边距和边框的宽度，不包括外边距。</li> <li>也就是说，元素的总宽度和高度等于内容宽度和高度，包括内边距和边框的宽度。</li></ul> <p>使用 box-sizing 属性可以更精确地控制元素的尺寸，尤其在设计响应式布局时非常有用。例如，如果设置了 box-sizing: border-box;，那么在调整元素的内边距或边框宽度时，元素的总宽度和高度不会变化，从而更容易进行布局的调整。</p> <h3 id="css-中的伪类和伪元素"><a href="#css-中的伪类和伪元素" class="header-anchor">#</a> CSS 中的伪类和伪元素</h3> <p>CSS 中的伪类和伪元素是用于选择和样式化 HTML 元素的特殊方式。它们可以让你在不添加额外 HTML 元素的情况下，对文档的特定部分应用样式。以下是对伪类和伪元素的详细解释：</p> <h4 id="伪类-pseudo-classes"><a href="#伪类-pseudo-classes" class="header-anchor">#</a> 伪类（Pseudo-classes）：</h4> <p>伪类是用于选择元素的特定状态或位置的选择器。它们以一个冒号（:）开始，然后是选择器的名称。一些常见的伪类包括：</p> <ul><li>:hover：选择鼠标悬停在元素上的状态。</li> <li>:active：选择鼠标点击正在被点击的元素时的状态。</li> <li>:focus：选择当前获取焦点的元素，如表单元素。</li> <li>:nth-child(n)：选择父元素的第 n 个子元素。</li> <li>:first-child、:last-child：选择父元素的第一个或最后一个子元素。</li> <li>:not(selector)：选择不匹配给定选择器的元素。</li> <li>:checked：选择已选中的复选框或单选按钮。
等等...</li></ul> <h4 id="伪元素-pseudo-elements"><a href="#伪元素-pseudo-elements" class="header-anchor">#</a> 伪元素（Pseudo-elements）：</h4> <p>伪元素是用于在元素的某个位置插入内容或样式的选择器。它们以两个冒号（::）开始，然后是选择器的名称。一些常见的伪元素包括：</p> <ul><li>::before：在元素的内容前插入内容，可以用来创建装饰性的元素。</li> <li>::after：在元素的内容后插入内容，同样可以用于装饰性元素。</li> <li>::first-line：选择元素的第一行内容。</li> <li>::first-letter：选择元素的第一个字符。</li> <li>::selection：选择用户选择的文本部分。</li> <li>::placeholder：选择输入框的占位文本</li></ul> <p>示例用法：</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code><span class="token comment">/* 伪类示例 */</span>
<span class="token selector">a:hover</span> <span class="token punctuation">{</span>
  <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">li:nth-child(odd)</span> <span class="token punctuation">{</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> lightgray<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">input:checked + label</span> <span class="token punctuation">{</span>
  <span class="token property">font-weight</span><span class="token punctuation">:</span> bold<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 伪元素示例 */</span>
<span class="token selector">p::before</span> <span class="token punctuation">{</span>
  <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">&quot;&gt;&gt; &quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">h1::after</span> <span class="token punctuation">{</span>
  <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">&quot; &lt;&lt;&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">p::first-letter</span> <span class="token punctuation">{</span>
  <span class="token property">font-size</span><span class="token punctuation">:</span> 2em<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><h2 id="react"><a href="#react" class="header-anchor">#</a> react</h2> <h3 id="react与vue有什么不同"><a href="#react与vue有什么不同" class="header-anchor">#</a> react与vue有什么不同</h3> <p><strong>生态系统和社区:</strong>
React 由 Facebook 开发，并且拥有庞大的社区支持。React 生态系统包括许多相关的库和工具，如 Redux、React Router 等。
Vue 由尤雨溪（Evan You）开发，也有一个活跃的社区。Vue 的核心库以及配套的 Vue Router 和 Vuex（用于状态管理）都是由 Vue 团队维护的。
<strong>学习曲线:</strong>
Vue 被设计成易于上手，适合新手入门。Vue 的文档清晰且易于理解，它提供的指令和概念相对简单。
React 的学习曲线相对陡峭一些，因为它使用了 JSX（JavaScript XML）语法以及一些更抽象的概念。但是，一旦你理解了 React 的核心概念，它可以让你更深入地理解前端开发的原理。
<strong>组件通信:</strong>
在 React 中，组件通信通常需要使用 props 和 state 进行父子组件之间的传递数据，以及通过回调函数进行交互。
在 Vue 中，组件通信也可以使用 props 和自定义事件进行父子组件之间的传递数据，或者使用 Vuex 进行更复杂的状态管理。
<strong>模板语法:</strong>
Vue 使用了类似 HTML 的模板语法，使得模板和组件之间的关系更加直观。模板可以直接在 HTML 中编写。
React 使用 JSX 语法，将 HTML 和 JavaScript 结合在一起，这样可以在 JavaScript 中直接构建 UI，但需要习惯这种混合的语法。
<strong>状态管理:</strong>
React 可以使用内置的 useState 钩子或第三方库（如 Redux）来管理应用状态。
Vue 在组件之间共享状态时，可以使用 props 和 emit 进行通信，或者使用 Vuex 进行集中的状态管理。
<strong>响应式系统:</strong>
Vue 使用其内部的响应式系统来跟踪数据的变化，并在数据发生变化时更新视图。
React 使用 Virtual DOM 和称为 &quot;reconciliation&quot; 的过程来实现高效的 UI 更新。
<strong>生命周期:</strong>
React 组件的生命周期包含多个钩子函数，用于在组件的不同生命周期阶段执行操作。
Vue 组件的生命周期也包含多个钩子函数，但在某些方面更加简单和直观。</p> <h3 id="state和props"><a href="#state和props" class="header-anchor">#</a> state和props</h3> <p>在 React 中，props（属性）和 state（状态）是两个核心的概念，用于管理和传递组件的数据。它们分别用于不同的用途和场景。</p> <h4 id="props-属性"><a href="#props-属性" class="header-anchor">#</a> Props（属性）：</h4> <ul><li>props 是从父组件传递给子组件的数据，用于在组件之间传递信息。</li> <li>props 是只读的，子组件无法直接修改父组件传递的 props。</li> <li>props 可以包含任何数据，包括基本数据类型、对象、函数等。</li> <li>通过 this.props 或在函数组件中通过参数访问传递的 props。</li></ul> <p>示例：</p> <div class="language-ts line-numbers-mode"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">ParentComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React</span><span class="token punctuation">.</span>Component <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">&lt;</span>ChildComponent name<span class="token operator">=</span><span class="token string">&quot;Alice&quot;</span> age<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">25</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">ChildComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React</span><span class="token punctuation">.</span>Component <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
        My name <span class="token keyword">is</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>name<span class="token punctuation">}</span> and <span class="token constant">I</span> am <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>age<span class="token punctuation">}</span> years old<span class="token punctuation">.</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h4 id="state-状态"><a href="#state-状态" class="header-anchor">#</a> State（状态）：</h4> <ul><li>state 是组件内部的状态数据，用于管理组件的可变数据。</li> <li>state 是可以在组件内部进行修改的，通过 this.setState 方法来更新。</li> <li>通常用于在组件内部存储和管理与用户交互相关的数据。</li> <li>通过构造函数初始化或使用 useState 钩子来定义组件的初始状态。</li></ul> <p>示例：</p> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token keyword">class</span> <span class="token class-name">Counter</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function-variable function">increment</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
        Count: </span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count<span class="token punctuation">}</span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>increment<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Increment</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>### setState
在 React 中，setState 是用于更新组件状态（state）的方法。setState 方法不仅会更新状态的值，还会触发组件的重新渲染，以确保 UI 反映最新的状态数据。以下是关于 setState 方法的一些重要信息：</p> <ol><li>使用方式：
在类组件中，可以通过调用 this.setState(newState) 来更新组件的状态。newState 是一个包含要更新的状态属性的对象。</li> <li>异步更新：
React 中的 setState 是异步操作。这意味着调用 setState 后，React 并不会立即更新状态，而是将更新放入队列中，稍后在合适的时机执行更新。</li> <li>回调函数：
setState 可以接受一个回调函数作为第二个参数，在状态更新完毕并且组件重新渲染后调用。</li> <li>函数形式的 setState：
setState 也可以接受一个函数作为参数，而不仅仅是一个对象。这个函数接收当前的状态和当前的 props 作为参数，并返回一个新的状态对象。</li></ol> <p>示例使用方式：</p> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token keyword">class</span> <span class="token class-name">Counter</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function-variable function">increment</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 使用对象形式更新状态</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 使用函数形式更新状态</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token parameter">prevState</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">count</span><span class="token operator">:</span> prevState<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
        Count: </span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count<span class="token punctuation">}</span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>increment<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Increment</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><h3 id="怎么创建一个组件"><a href="#怎么创建一个组件" class="header-anchor">#</a> 怎么创建一个组件</h3> <p>在 React 中，您可以通过定义一个类组件或函数组件来创建一个新的组件。以下是创建这两种类型组件的示例：</p> <h4 id="创建类组件"><a href="#创建类组件" class="header-anchor">#</a> 创建类组件：</h4> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">MyComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
        </span><span class="token punctuation">{</span><span class="token comment">/* 组件的内容和 UI */</span><span class="token punctuation">}</span><span class="token plain-text">
        Hello, I am a class component.
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> MyComponent<span class="token punctuation">;</span> <span class="token comment">// 导出组件，以便在其他文件中使用</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h4 id="创建函数组件"><a href="#创建函数组件" class="header-anchor">#</a> 创建函数组件：</h4> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
      </span><span class="token punctuation">{</span><span class="token comment">/* 组件的内容和 UI */</span><span class="token punctuation">}</span><span class="token plain-text">
      Hello, I am a function component.
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> MyComponent<span class="token punctuation">;</span> <span class="token comment">// 导出组件，以便在其他文件中使用</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>在上述示例中，我们定义了一个名为 MyComponent 的组件，它可以在其他文件中导入和使用。组件可以返回 JSX 元素，这些元素定义了组件的外观和 UI。</p> <p>要使用这些组件，您只需在其他文件中导入它并将其放入需要的位置：</p> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> ReactDOM <span class="token keyword">from</span> <span class="token string">'react-dom'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> MyComponent <span class="token keyword">from</span> <span class="token string">'./MyComponent'</span><span class="token punctuation">;</span> <span class="token comment">// 路径根据实际情况进行调整</span>

ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">MyComponent</span></span> <span class="token punctuation">/&gt;</span></span><span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>### 类组件和函数组件
在 React 中，有两种主要的组件类型：类组件和函数组件。这两种组件类型都可以用来创建用户界面，但它们在语法和用法上存在一些区别。</p> <h4 id="类组件"><a href="#类组件" class="header-anchor">#</a> 类组件：</h4> <ul><li>类组件是使用 ES6 的类语法来创建的。</li> <li>必须继承自 React.Component 类。</li> <li>可以使用构造函数（constructor）来初始化状态和绑定方法。</li> <li>可以使用生命周期方法（如 componentDidMount、componentDidUpdate 等）来处理组件的生命周期事件。</li> <li>可以使用 this.setState 方法来更新组件的状态。</li> <li>适用于复杂的逻辑、状态管理和生命周期控制。</li></ul> <p>示例：</p> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> Component <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">ClassComponent</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function-variable function">increment</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
        Count: </span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count<span class="token punctuation">}</span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>increment<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Increment</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><h4 id="函数组件"><a href="#函数组件" class="header-anchor">#</a> 函数组件：</h4> <ul><li>函数组件是纯函数，接收 props 参数并返回 JSX 元素。</li> <li>在 React 16.8 之后引入了钩子（Hooks）机制，使函数组件可以拥有状态和处理生命周期。</li> <li>使用 useState 钩子来定义状态。</li> <li>使用 useEffect 钩子来处理生命周期事件，如 componentDidMount、componentDidUpdate 等。</li> <li>适用于简单的组件、UI 渲染和无状态逻辑。</li></ul> <p>示例：</p> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> useState<span class="token punctuation">,</span> useEffect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">FunctionComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> <span class="token function-variable function">increment</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// componentDidMount 和 componentDidUpdate 的逻辑</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
      Count: </span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>increment<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Increment</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>根据项目需求和个人偏好，您可以选择使用类组件或函数组件。在 React 16.8 之后，函数组件通过引入钩子机制，使得在大多数情况下函数组件可以实现类似类组件的功能。</p> <p>### 类组件和函数组件是怎么传递参数的
无论是类组件还是函数组件，都可以通过 props 对象来传递参数给子组件。props 是一种用于在组件之间传递数据的机制，允许父组件向子组件传递值或函数。
### react中的常用方法
在 React 中，有一些常用的方法和模式，用于处理组件的生命周期、状态管理、事件处理等。以下是一些 React 中常用的方法和技术：</p> <h4 id="生命周期方法"><a href="#生命周期方法" class="header-anchor">#</a> 生命周期方法：</h4> <ul><li>componentDidMount：组件渲染后调用，适合进行初始化操作和异步数据获取。</li> <li>componentDidUpdate：组件更新后调用，可用于处理状态变化时的操作。</li> <li>componentWillUnmount：组件将被卸载时调用，适合清理工作和取消异步操作。</li></ul> <h4 id="状态管理"><a href="#状态管理" class="header-anchor">#</a> 状态管理：</h4> <ul><li>useState：函数组件中引入的钩子，用于在函数组件中定义和管理状态。</li> <li>this.state：类组件中用于管理状态的属性。</li> <li>this.setState：用于更新状态的方法，会触发组件重新渲染。</li></ul> <h4 id="事件处理"><a href="#事件处理" class="header-anchor">#</a> 事件处理：</h4> <ul><li>在 JSX 中，可以使用 onClick、onChange 等属性来添加事件处理函数。</li> <li>事件处理函数的参数是一个事件对象，可以通过 event.target 获取触发事件的元素。</li></ul> <h4 id="条件渲染"><a href="#条件渲染" class="header-anchor">#</a> 条件渲染：</h4> <ul><li>使用条件语句（如 if、else）来决定渲染哪些 JSX 元素。</li> <li>使用三元运算符进行简单的条件渲染。</li></ul> <h4 id="列表渲染"><a href="#列表渲染" class="header-anchor">#</a> 列表渲染：</h4> <ul><li>使用 map 方法将数组映射为一组 JSX 元素，从而实现列表渲染。</li></ul> <h4 id="表单处理"><a href="#表单处理" class="header-anchor">#</a> 表单处理：</h4> <ul><li>使用受控组件（将表单元素的值与组件的状态关联）来管理表单数据。</li> <li>使用 onChange 事件来监听表单元素值的变化。</li></ul> <h4 id="传递参数和数据"><a href="#传递参数和数据" class="header-anchor">#</a> 传递参数和数据：</h4> <ul><li>使用 props 属性来将数据从父组件传递给子组件。</li> <li>使用回调函数来在子组件中向父组件传递数据或触发事件。</li></ul> <h4 id="样式处理"><a href="#样式处理" class="header-anchor">#</a> 样式处理：</h4> <ul><li>使用 className 属性来添加 CSS 类名。</li> <li>使用行内样式（style 属性）来添加样式，注意样式属性采用驼峰命名。</li></ul> <h4 id="路由"><a href="#路由" class="header-anchor">#</a> 路由：</h4> <ul><li>使用第三方库（如 React Router）来实现前端路由，实现单页面应用。</li></ul> <h4 id="组件通信"><a href="#组件通信" class="header-anchor">#</a> 组件通信：</h4> <ul><li>使用 props 和回调函数来实现父子组件之间的通信。</li> <li>使用状态管理库（如 Redux、Mobx）来管理应用的全局状态。</li></ul> <h3 id="react之间怎么通信的"><a href="#react之间怎么通信的" class="header-anchor">#</a> react之间怎么通信的</h3> <h4 id="props-属性-传递"><a href="#props-属性-传递" class="header-anchor">#</a> Props（属性）传递：</h4> <p>使用 props 属性将数据从父组件传递到子组件。子组件可以通过 this.props（在类组件中）或函数参数（在函数组件中）访问传递的数据。</p> <h4 id="回调函数"><a href="#回调函数" class="header-anchor">#</a> 回调函数：</h4> <p>父组件可以将函数作为 props 传递给子组件，子组件可以在适当的时机调用该函数来向父组件传递数据或触发事件。</p> <h4 id="状态提升"><a href="#状态提升" class="header-anchor">#</a> 状态提升：</h4> <p>如果多个组件共享相同的数据，可以将这些数据提升到它们的共同父组件的状态中，然后通过 props 传递给各个子组件。</p> <h4 id="context-上下文"><a href="#context-上下文" class="header-anchor">#</a> Context（上下文）：</h4> <p>使用 React 的 Context 机制，可以在组件树中传递数据，避免将数据逐层传递给所有中间组件。</p> <h4 id="状态管理库"><a href="#状态管理库" class="header-anchor">#</a> 状态管理库：</h4> <p>使用第三方状态管理库（如 Redux、Mobx）来管理应用的全局状态，以便于多个组件之间共享和通信。</p> <h4 id="自定义事件"><a href="#自定义事件" class="header-anchor">#</a> 自定义事件：</h4> <p>使用自定义事件机制，父组件可以触发自定义事件并传递数据，子组件可以监听这些事件来响应。</p> <h4 id="订阅-发布模式"><a href="#订阅-发布模式" class="header-anchor">#</a> 订阅-发布模式：</h4> <p>使用订阅-发布模式（如使用 PubSub.js 库）来实现组件之间的解耦和通信。</p> <h4 id="react-router"><a href="#react-router" class="header-anchor">#</a> React Router：</h4> <p>使用第三方库 React Router 来实现页面之间的切换和路由，进行页面级别的通信。</p> <h2 id="计算机基础八股文"><a href="#计算机基础八股文" class="header-anchor">#</a> 计算机基础八股文</h2> <h3 id="进程和线程的区别与联系"><a href="#进程和线程的区别与联系" class="header-anchor">#</a> 进程和线程的区别与联系</h3> <h4 id="进程-vs-线程"><a href="#进程-vs-线程" class="header-anchor">#</a> 进程 vs. 线程</h4> <ol><li>定义：
进程：独立的执行单位，包括程序、数据、资源和执行环境。
线程：进程内的子任务，共享进程的资源，包括内存和文件。</li> <li>资源分配：
进程：拥有独立的地址空间、文件描述符等资源。
线程：共享进程的资源，包括内存和文件。</li> <li>切换开销：
进程：切换开销相对较大，需要保存和恢复整个进程的上下文。
线程：切换开销相对较小，因为线程共享了大部分上下文。</li> <li>独立性：
进程：独立性强，一个进程的崩溃不会影响其他进程。
线程：共享资源，一个线程的崩溃可能影响整个进程的稳定性。</li> <li>并发性：
进程和线程都可以并发执行，提高系统资源利用率和响应性。</li> <li>通信方式：
进程：通信需要显式的 IPC 机制。
线程：相对容易地共享数据，可以直接访问共享资源。</li> <li>创建开销：
进程：创建开销相对较大。
线程：创建开销相对较小。</li></ol> <p>总之，进程是独立的执行单位，拥有自己的资源和环境，进程间通信需要额外的机制。线程是进程内的子任务，共享进程的资源，线程间通信相对容易。选择使用进程还是线程取决于应用的需求，进程适用于独立的任务，线程适用于任务之间需要共享资源和协作的情况。</p> <h3 id="进程间通信方式-进程间如何进行通信-说一下应用场景"><a href="#进程间通信方式-进程间如何进行通信-说一下应用场景" class="header-anchor">#</a> 进程间通信方式，进程间如何进行通信？说一下应用场景？</h3> <p>进程间通信（Inter-Process Communication，IPC）是指不同进程之间交换数据、共享资源或进行协作的机制。在操作系统中，不同的进程可能需要相互通信来实现各种功能。以下是一些常见的进程间通信方式以及它们的应用场景：</p> <h4 id="管道-pipe"><a href="#管道-pipe" class="header-anchor">#</a> 管道（Pipe）：</h4> <ul><li>管道是一种单向通信机制，可用于在两个相关的进程之间传递数据。通常是父进程创建一个管道，在创建子进程后，子进程可以读取或写入管道。</li> <li>应用场景：用于父子进程之间的通信，如 shell 中的命令管道（例如：ls | grep）。</li></ul> <h4 id="消息队列-message-queue"><a href="#消息队列-message-queue" class="header-anchor">#</a> 消息队列（Message Queue）：</h4> <ul><li>消息队列是一种消息传递机制，允许进程通过队列发送和接收消息。每个消息都具有优先级，可以异步通信。</li> <li>应用场景：多个进程之间异步通信，如进程间数据交换、事件通知等。</li></ul> <h4 id="共享内存-shared-memory"><a href="#共享内存-shared-memory" class="header-anchor">#</a> 共享内存（Shared Memory）：</h4> <ul><li>共享内存允许多个进程访问同一块内存区域，进程可以直接读写内存，不需要复制数据。需要通过信号量等机制实现同步和互斥。</li> <li>应用场景：多个进程需要高效地共享大量数据，如数据库管理系统。</li></ul> <h4 id="信号量-semaphore"><a href="#信号量-semaphore" class="header-anchor">#</a> 信号量（Semaphore）：</h4> <ul><li>信号量是一种用于进程间同步的通信方式，可以控制进程的访问权和顺序。</li> <li>应用场景：限制资源的访问数量，如连接池管理。</li></ul> <h4 id="套接字-socket"><a href="#套接字-socket" class="header-anchor">#</a> 套接字（Socket）：</h4> <ul><li>套接字是一种用于网络通信的通信方式，也可以在同一台计算机的不同进程之间使用，实现进程间通信。</li> <li>应用场景：进程在网络上通信，或者需要在不同主机上的进程间通信。</li></ul> <h4 id="rpc-remote-procedure-call"><a href="#rpc-remote-procedure-call" class="header-anchor">#</a> RPC（Remote Procedure Call）：</h4> <ul><li>远程过程调用允许一个进程调用另一个进程的函数，就像调用本地函数一样。</li> <li>应用场景：分布式系统中，多个进程需要调用远程服务，如 Web 服务。</li></ul> <h4 id="文件映射-file-mapping"><a href="#文件映射-file-mapping" class="header-anchor">#</a> 文件映射（File Mapping）：</h4> <ul><li>文件映射允许多个进程将一个文件映射到内存中，实现对文件内容的共享访问。</li> <li>应用场景：多个进程需要共享大型文件数据。</li></ul> <h3 id="管道是如何通信的-全双工、半双工、单工-三者之间的区别"><a href="#管道是如何通信的-全双工、半双工、单工-三者之间的区别" class="header-anchor">#</a> 管道是如何通信的？全双工、半双工、单工？？三者之间的区别</h3> <p>管道（Pipe）是一种进程间通信的机制，它允许两个相关的进程在一个方向上进行数据传递。管道可以实现全双工、半双工和单工通信，这三者之间的区别在于通信的方式和能力：</p> <h4 id="全双工通信"><a href="#全双工通信" class="header-anchor">#</a> 全双工通信：</h4> <ul><li>全双工通信允许两个进程同时进行双向数据传递，就像同时进行输入和输出一样。</li> <li>在全双工通信中，管道可以在两个方向上传递数据，进程 A 可以向管道写入数据，并由进程 B 读取，同时进程 B 也可以向管道写入数据，并由进程 A 读取。</li> <li>全双工通信更加灵活，适用于需要同时进行双向数据传递的场景。</li> <li><h4 id="半双工通信"><a href="#半双工通信" class="header-anchor">#</a> 半双工通信：</h4></li> <li>半双工通信只允许两个进程在某个时刻进行单向数据传递，即进程 A 向管道写入数据，然后进程 B 读取，或者反之。</li> <li>在半双工通信中，数据只能在一个方向上传递，进程需要按顺序交替地进行写入和读取。</li> <li>半双工通信相对简单，适用于需要依次进行单向数据传递的场景。</li></ul> <h4 id="单工通信"><a href="#单工通信" class="header-anchor">#</a> 单工通信：</h4> <ul><li>单工通信只允许数据在一个方向上传递，没有反向传递的能力。进程 A 向管道写入数据，进程 B 读取数据，但不能反过来。</li> <li>单工通信最简单，但通信的灵活性受到限制，只能实现单向数据传递。</li></ul> <h3 id="计算机进程的调度方式"><a href="#计算机进程的调度方式" class="header-anchor">#</a> 计算机进程的调度方式</h3> <ol><li>先来先服务调度（FCFS，First-Come-First-Served）：</li></ol> <ul><li>这是最简单的调度方式，按照进程到达的先后顺序进行调度。即先进入队列的进程先执行，直到进程执行完成。</li> <li>缺点：可能导致短进程被长进程阻塞，产生“饥饿”问题。</li></ul> <ol start="2"><li>短作业优先调度（SJF，Shortest Job First）：</li></ol> <ul><li>选择最短执行时间的进程优先执行，可以减少平均等待时间。</li> <li>缺点：难以准确预测进程的执行时间，容易产生“无限等待”。</li></ul> <ol start="3"><li>优先级调度：</li></ol> <ul><li>每个进程被分配一个优先级，优先级高的进程先执行。可根据进程的属性、重要性等进行优先级划分。</li> <li>缺点：可能导致优先级较低的进程长时间等待，产生“优先级反转”。</li></ul> <ol start="4"><li>时间片轮转调度（Round Robin）：</li></ol> <ul><li>将 CPU 时间划分成固定大小的时间片，每个进程轮流执行一个时间片。当时间片用完，进程被放回队列尾部等待。</li> <li>适用于多任务环境，公平地分配 CPU 时间，但长进程可能仍然导致等待。</li></ul> <ol start="5"><li>多级反馈队列调度：</li></ol> <ul><li>将进程分成多个队列，每个队列拥有不同的优先级。进程开始在高优先级队列执行，若用完时间片则移到低优先级队列。</li> <li>适用于既要保证短进程快速执行，又要防止长进程饥饿。</li></ul> <ol start="6"><li>最高响应比优先调度：</li></ol> <ul><li>选择具有最高响应比（等待时间 / 执行时间）的进程优先执行，可以兼顾长短进程。</li> <li>避免了 SJF 的“无限等待”问题，但需要实时计算响应比。</li></ul> <h3 id="linux查看进程和端口"><a href="#linux查看进程和端口" class="header-anchor">#</a> linux查看进程和端口</h3> <h4 id="查看进程信息"><a href="#查看进程信息" class="header-anchor">#</a> 查看进程信息</h4> <ol><li>ps 命令：</li></ol> <ul><li>ps 命令可以用来查看当前正在运行的进程。以下是一些常用的 ps 命令选项：</li> <li>ps aux：显示所有用户的所有进程信息。</li> <li>ps aux | grep &lt;进程名或关键字&gt;：通过管道和 grep 命令过滤特定进程名或关键字的信息。</li></ul> <ol start="2"><li>top 命令：</li></ol> <ul><li>top 命令可以实时地显示系统中运行的进程信息，包括 CPU、内存等使用情况。</li> <li>按 q 键退出 top 命令。</li></ul> <h4 id="查看端口信息"><a href="#查看端口信息" class="header-anchor">#</a> 查看端口信息：</h4> <ol><li>netstat 命令：</li></ol> <ul><li>netstat 命令用于查看网络状态和连接。以下是一些常用的 netstat 命令选项：</li> <li>netstat -tuln：列出当前监听的 TCP 和 UDP 端口。</li> <li>netstat -tuln | grep &lt;端口号&gt;：通过管道和 grep 命令过滤特定端口号的信息。</li></ul> <ol start="2"><li>ss 命令：</li></ol> <ul><li>ss 命令也用于查看网络套接字状态和连接，功能类似于 netstat。</li> <li>例如，ss -tuln 列出监听的 TCP 和 UDP 端口。</li></ul> <ol start="3"><li>lsof 命令：</li></ol> <ul><li>lsof 命令用于显示当前打开的文件和进程信息。可以用来查看哪些进程正在使用哪些端口。</li> <li>例如，lsof -i :&lt;端口号&gt; 查看使用特定端口的进程信息。</li></ul> <h3 id="计算机是如何管理内存的-提示-虚拟内存-段、页、段页-以及物理内存-为什么要有虚拟内存"><a href="#计算机是如何管理内存的-提示-虚拟内存-段、页、段页-以及物理内存-为什么要有虚拟内存" class="header-anchor">#</a> 计算机是如何管理内存的？（提示：虚拟内存:段、页、段页；以及物理内存）？为什么要有虚拟内存？</h3> <p>计算机的内存管理方式包括物理内存管理和虚拟内存管理。这些方式是操作系统用来有效地分配、保护和操作系统中可用内存的方法。以下是这两种内存管理方式的详细解释：</p> <h4 id="物理内存管理"><a href="#物理内存管理" class="header-anchor">#</a> 物理内存管理：</h4> <p>物理内存管理涉及操作系统如何管理实际的硬件内存模块。其主要任务是将进程和数据加载到物理内存中，并确保它们能够被高效地访问和操作。以下是物理内存管理的主要内容：</p> <ul><li>内存分配：操作系统负责将可用的物理内存分配给不同的进程。这可以通过内存分区、内存页框等方式来实现。</li> <li>内存保护：操作系统确保不同进程的内存空间是隔离的，一个进程无法直接访问其他进程的内存。这通过使用特权级别、分段、权限位等方法来实现。</li> <li>地址映射：操作系统负责将程序中的虚拟地址映射到物理内存中的实际地址。这涉及页表或段表等数据结构的使用。</li> <li>内存回收：当进程终止或释放内存时，操作系统需要将其占用的物理内存释放，以供其他进程使用。</li></ul> <h4 id="虚拟内存管理"><a href="#虚拟内存管理" class="header-anchor">#</a> 虚拟内存管理：</h4> <p>虚拟内存管理是为了解决物理内存不足和多任务环境下的内存管理问题。它通过将物理内存与磁盘空间结合，为每个进程提供一个虚拟的、更大的地址空间。以下是虚拟内存管理的主要内容：</p> <ul><li>分页技术：虚拟内存将虚拟地址空间和物理内存都分割成固定大小的页。操作系统维护页表，用于虚拟页和物理页的映射。</li> <li>页面置换：当物理内存不足时，操作系统可能需要将一部分数据从物理内存交换到磁盘上，以腾出空间给其他进程。这被称为页面置换算法。</li> <li>页面文件：磁盘上的一部分空间被用作页面文件，用于存储被交换出的页。当需要时，这些页可以从磁盘加载回物理内存。</li> <li>页面访问权限：虚拟内存管理允许为不同的页面设置不同的访问权限，以增强内存保护。</li></ul> <h4 id="虚拟内存的作用"><a href="#虚拟内存的作用" class="header-anchor">#</a> 虚拟内存的作用：</h4> <ul><li>多任务支持：虚拟内存允许多个程序同时运行，即使物理内存不足以容纳它们。</li> <li>内存保护：每个进程的虚拟地址空间被隔离，防止一个程序访问其他程序的内存。</li> <li>更大的地址空间：每个进程可以拥有比实际物理内存更大的虚拟地址空间。</li> <li>内存共享：多个进程可以共享同一份代码，减少重复占用内存。</li> <li>磁盘交换：如果物理内存不足，操作系统可以将部分不常用的数据交换到磁盘上，从而腾出更多的物理内存。</li></ul> <h3 id="软件设计原则"><a href="#软件设计原则" class="header-anchor">#</a> 软件设计原则</h3> <ol><li>单一职责原则（Single Responsibility Principle，SRP）：
每个类或模块应该有且仅有一个职责。这有助于保持代码的可读性和维护性。</li> <li>开闭原则（Open/Closed Principle，OCP）：
软件实体（类、模块等）应该对扩展开放，对修改关闭。意味着可以通过添加新的功能来扩展系统，而无需修改现有的代码。</li> <li>里氏替换原则（Liskov Substitution Principle，LSP）：
子类应该能够替换父类，而不影响程序的正确性。换句话说，子类应该符合父类的行为规范。</li> <li>接口隔离原则（Interface Segregation Principle，ISP）：
不应该强迫一个类实现它不需要的接口。应该将大接口拆分成多个小接口，以适应不同的需求。</li> <li>依赖倒置原则（Dependency Inversion Principle，DIP）：
高层模块不应该依赖于低层模块，而是应该依赖于抽象。抽象不应该依赖于具体实现，而是具体实现应该依赖于抽象。</li> <li>迪米特法则（Law of Demeter，LoD）：
一个对象应该与其它对象保持最少的直接关联。这有助于减少类之间的耦合性，提高代码的灵活性。</li> <li>合成/聚合复用原则（Composite/Aggregate Reuse Principle，CARP）：
优先使用合成和聚合，而不是继承，来实现代码的复用。这有助于避免继承的一些问题，如紧耦合和复杂性。</li> <li>最小知识原则（Law of Demeter，LoD）：
对象之间只与直接的朋友通信，不与陌生对象通信。降低对象之间的耦合性，提高代码的稳定性。</li> <li>可替换原则（Substitution Principle，LSP）：
设计时要考虑到代码的可替换性，使得可以轻松地替换组件、模块或类，而不影响整体系统的功能。</li> <li>追踪职责分离原则（Separated Responsibility Principle，SRP）：
将不同的职责分离到不同的组件、模块或类中，以保持代码的清晰性和可维护性。</li></ol> <h3 id="了解的设计模式"><a href="#了解的设计模式" class="header-anchor">#</a> 了解的设计模式</h3> <p>设计模式是在软件开发中常见的解决问题的模式或模板，它们提供了一种经过验证的方法来解决特定类型的问题。设计模式帮助开发人员在不同情况下复用经验丰富的解决方案，提高代码的可维护性、可扩展性和可读性。以下是一些常见的设计模式：</p> <ol><li>单例模式（Singleton Pattern）：
确保一个类只有一个实例，并提供全局访问点。适用于需要共享资源或状态的情况，如配置管理、日志记录等。</li> <li>工厂模式（Factory Pattern）：
将对象的创建从客户端代码中分离出来，通过工厂类创建对象。适用于需要创建不同类型对象的情况，可以减少代码的重复性。</li> <li>观察者模式（Observer Pattern）：
定义对象之间的一对多关系，当一个对象改变状态时，其所有依赖对象都会收到通知并自动更新。适用于需要实现发布-订阅模型的情况。</li> <li>策略模式（Strategy Pattern）：
定义一组算法，将其封装成独立的类，使得它们可以互相替换。适用于需要在运行时根据不同情况选择不同算法的情况。</li> <li>适配器模式（Adapter Pattern）：
将一个类的接口转换成客户端所期望的另一个接口。适用于不兼容接口之间的协调。</li> <li>装饰器模式（Decorator Pattern）：
动态地给对象添加新的功能，通过将装饰器对象包裹在原始对象周围。适用于避免使用子类来扩展功能的情况。</li> <li>模板方法模式（Template Method Pattern）：
定义一个算法的骨架，将一些步骤的具体实现延迟到子类中。适用于实现一系列算法时保持一致性的情况。</li> <li>状态模式（State Pattern）：
允许对象在内部状态改变时改变它的行为。适用于对象的行为取决于其内部状态的情况。</li> <li>代理模式（Proxy Pattern）：
提供一个代理对象，控制对原始对象的访问。适用于需要在访问原始对象前后执行一些操作的情况。</li> <li>迭代器模式（Iterator Pattern）：
提供一种顺序访问一个聚合对象中各个元素的方法。适用于需要遍历集合对象的情况。</li></ol> <h3 id="tcp三次握手-为什么要三次握手"><a href="#tcp三次握手-为什么要三次握手" class="header-anchor">#</a> tcp三次握手，为什么要三次握手</h3> <h4 id="tcp-三次握手的步骤如下"><a href="#tcp-三次握手的步骤如下" class="header-anchor">#</a> TCP 三次握手的步骤如下：</h4> <p>TCP 三次握手（Three-Way Handshake）是建立 TCP 连接的过程，确保客户端和服务器之间能够正确地进行数据通信。</p> <ol><li>客户端向服务器发送连接请求（SYN）：客户端发送一个带有 SYN（同步序列号）标志的数据包给服务器，表示客户端想要建立连接。</li> <li>服务器收到请求并回复（SYN + ACK）：服务器收到连接请求后，会发送一个带有 SYN 和 ACK（确认序号）标志的数据包给客户端，表示服务器接受了连接请求，并准备好建立连接。</li> <li>客户端回复确认（ACK）：客户端收到服务器的确认后，会发送一个带有 ACK 标志的数据包给服务器，表示客户端接受了服务器的确认，连接已建立。</li></ol> <h4 id="三次握手的目的是解决网络中可能出现的以下问题"><a href="#三次握手的目的是解决网络中可能出现的以下问题" class="header-anchor">#</a> 三次握手的目的是解决网络中可能出现的以下问题：</h4> <ol><li>确认双方是否可达：在进行数据通信之前，客户端和服务器需要确认彼此是否可以正常通信。第一次握手中，客户端向服务器发送一个请求，以测试服务器是否可达。</li> <li>避免已失效的连接请求引发错误：在网络中，可能会有延迟或者丢失的情况发生，导致之前的连接请求在一段时间后才到达服务器。如果客户端发送的连接请求已经失效，服务器会收到一个无效的请求，可能会误认为客户端要建立连接。通过三次握手，可以减少这种错误的发生。</li> <li>防止重复连接：在网络中，可能存在重复的连接请求，例如客户端由于网络延迟而多次发送连接请求。通过三次握手，服务器可以避免处理重复的连接请求。</li></ol> <h3 id="tcp和udp的区别以及各自的应用场景"><a href="#tcp和udp的区别以及各自的应用场景" class="header-anchor">#</a> tcp和udp的区别以及各自的应用场景</h3> <h4 id="tcp-传输控制协议"><a href="#tcp-传输控制协议" class="header-anchor">#</a> TCP（传输控制协议）：</h4> <ul><li>靠性：TCP 提供可靠的、面向连接的通信。它使用确认和重传机制来确保数据的可靠传输，以及顺序性和数据完整性。</li> <li>接导向：在通信前，TCP 建立一个连接，然后在通信结束后释放连接。这种连接导向的特性保证了数据的传输和接收的有序性。</li> <li>式传输：TCP 提供面向字节流的传输方式，将数据分割成小的数据块，然后传输。</li> <li>塞控制：TCP 通过使用拥塞窗口和滑动窗口等机制，自动调整数据传输速率，以避免网络拥塞。</li> <li>用场景：适用于需要可靠数据传输、顺序性、数据完整性的场景，如文件传输、电子邮件、网页浏览等。</li></ul> <h4 id="udp-用户数据报协议"><a href="#udp-用户数据报协议" class="header-anchor">#</a> UDP（用户数据报协议）：</h4> <ul><li>不可靠性：UDP 是一种无连接的、不可靠的协议。它不提供确认、重传和流量控制等机制，数据传输可能会出现丢失、重复和乱序。</li> <li>低延迟：由于没有连接建立和维护的开销，UDP 具有较低的传输延迟，适用于需要快速传输的场景。</li> <li>数据报传输：UDP 使用数据报进行传输，每个数据报都是独立的，不会像 TCP 那样分割成字节流。</li> <li>适用场景：适用于实时性要求较高、允许丢失一些数据的场景，如语音通话、视频流、实时游戏等。</li></ul> <p>总的来说，TCP 提供了可靠的连接导向通信，确保数据的可靠传输和顺序性，适用于对数据完整性有要求的场景。而UDP 提供了低延迟的无连接传输，适用于实时性要求较高的场景。在实际应用中，根据需求选择合适的协议可以优化网络传输效率和性能。</p> <h3 id="哪些协议基于tcp或udp"><a href="#哪些协议基于tcp或udp" class="header-anchor">#</a> 哪些协议基于TCP或UDP</h3> <h4 id="基于tcp的协议"><a href="#基于tcp的协议" class="header-anchor">#</a> 基于TCP的协议：</h4> <p>HTTP（超文本传输协议）：用于在客户端和服务器之间传输网页内容和数据。
HTTPS（安全超文本传输协议）：加密的 HTTP，用于安全地传输敏感数据。
FTP（文件传输协议）：用于在客户端和服务器之间传输文件。
SMTP（简单邮件传输协议）：用于发送电子邮件。
POP3（邮局协议版本3）：用于接收电子邮件。
IMAP（互联网邮件访问协议）：用于接收和管理电子邮件。</p> <h4 id="基于udp的协议"><a href="#基于udp的协议" class="header-anchor">#</a> 基于UDP的协议：</h4> <p>DNS（域名系统）：用于将域名解析为 IP 地址。
DHCP（动态主机配置协议）：用于自动分配 IP 地址和其他网络配置。
SNMP（简单网络管理协议）：用于网络设备的监控和管理。
TFTP（简单文件传输协议）：类似于 FTP，但更简单，用于在客户端和服务器之间传输小文件。
NTP（网络时间协议）：用于同步计算机的时间。
Syslog（系统日志协议）：用于收集和传输系统日志信息。</p> <h3 id="tcp如何保证传输的可靠性-滑动窗口具体是什么样的-tcp-通过确认和重传、序号和确认号、滑动窗口等机制来保证传输的可靠性。"><a href="#tcp如何保证传输的可靠性-滑动窗口具体是什么样的-tcp-通过确认和重传、序号和确认号、滑动窗口等机制来保证传输的可靠性。" class="header-anchor">#</a> tcp如何保证传输的可靠性？滑动窗口具体是什么样的？（TCP 通过确认和重传、序号和确认号、滑动窗口等机制来保证传输的可靠性。）</h3> <p><strong>TCP（传输控制协议）通过一系列机制来保证传输的可靠性：</strong></p> <ol><li><p>序号和确认号：每个TCP报文段都有一个序号（Sequence Number）和确认号（Acknowledgment Number）。发送方将数据划分为一系列的数据块（段），每个段都有一个唯一的序号。接收方收到数据后，会发送一个带有确认号的ACK报文段，表示已经成功接收了指定序号之前的所有数据。如果发送方在一定时间内没有收到确认，会进行重传。</p></li> <li><p>确认和重传：发送方在发送数据后等待接收方的确认。如果发送方在一定时间内未收到确认，就会认为数据丢失或出错，然后会进行重传。</p></li> <li><p>滑动窗口：滑动窗口是一种流量控制和拥塞控制的机制，用于控制发送方发送数据的速率，确保网络不会因为过多的数据而发生拥塞。滑动窗口分为发送窗口和接收窗口，发送窗口控制发送方发送数据的数量，接收窗口控制接收方能够接收的数据数量。</p></li></ol> <p><strong>滑动窗口的概念如下：</strong></p> <ul><li>发送窗口：发送方维护一个发送窗口，表示允许发送的最大序号的范围。发送方将位于发送窗口内的数据发送给接收方。</li> <li>接收窗口：接收方维护一个接收窗口，表示期望接收的数据范围。接收方只接收位于接收窗口内并且具有正确序号的数据。</li></ul> <p>滑动窗口的大小会根据网络的状况进行调整，如果网络拥塞，窗口大小会减小以减少传输速率，从而避免进一步拥塞。如果网络畅通，窗口大小可以增大，提高传输速率。</p> <p>综上所述，TCP通过使用序号、确认号、确认和重传机制，以及滑动窗口等手段来保证数据的可靠传输。这些机制共同确保了数据的顺序性、完整性和可靠性。</p> <h3 id="面向对象三个特征介绍一下-封装继承多态"><a href="#面向对象三个特征介绍一下-封装继承多态" class="header-anchor">#</a> 面向对象三个特征介绍一下，封装继承多态</h3> <p>面向对象编程（Object-Oriented Programming，OOP）是一种编程范式，其中包括封装、继承和多态这三个主要特征。</p> <h4 id="封装-encapsulation"><a href="#封装-encapsulation" class="header-anchor">#</a> 封装（Encapsulation）：</h4> <p>封装是将数据（属性）和操作（方法）封装在一个类中，同时对外部隐藏实现细节，只暴露必要的接口。这样可以防止外部直接访问和修改对象的内部状态，通过定义公共接口来控制访问权限。封装提供了更好的模块化，减少了耦合，同时也提高了代码的可维护性和可重用性。</p> <h4 id="继承-inheritance"><a href="#继承-inheritance" class="header-anchor">#</a> 继承（Inheritance）：</h4> <p>继承是指一个类可以从另一个类继承属性和方法，从而创建一个新的类。被继承的类称为父类（或基类），继承的类称为子类（或派生类）。子类可以继承父类的属性和方法，还可以添加新的属性和方法，或者覆盖父类的方法。继承提供了代码重用的机制，可以构建层次化的类结构。</p> <h4 id="多态-polymorphism"><a href="#多态-polymorphism" class="header-anchor">#</a> 多态（Polymorphism）：</h4> <p>多态是指不同的对象可以对同一消息做出不同的响应。在多态中，一个父类引用可以指向子类的对象，从而通过父类的接口来调用子类的方法。多态实现了代码的通用性，可以处理不同类型的对象，从而减少了重复的代码。多态可以通过继承和接口实现，提供了更灵活的代码设计和扩展。</p> <p>这三个特征是面向对象编程的核心概念，它们相互配合，使得代码更具有结构性、可维护性和可扩展性。封装确保了对象的内部状态安全，继承实现了代码重用和层次化设计，多态实现了通用性和灵活性。</p> <h3 id="链表有什么特点-应用场景"><a href="#链表有什么特点-应用场景" class="header-anchor">#</a> 链表有什么特点，应用场景</h3> <p>链表（Linked List）是一种常见的数据结构，用于存储一系列元素，这些元素通过节点（Node）连接在一起，每个节点包含数据和指向下一个节点的引用（指针）。</p> <h4 id="链表的主要特点包括"><a href="#链表的主要特点包括" class="header-anchor">#</a> 链表的主要特点包括：</h4> <p>动态性：链表的大小可以在运行时动态地增加或减少，相比数组等静态数据结构更具灵活性。
内存占用：链表只在需要时分配内存，每个节点只需要存储数据和指向下一个节点的指针，相比数组更节省内存。
插入和删除：链表在插入和删除元素时效率高，只需要改变节点间的指针指向即可，而数组插入和删除可能需要移动大量元素。
不连续存储：链表中的节点可以分散在内存中的任意位置，不像数组需要连续的内存空间。</p> <h4 id="链表的应用场景包括"><a href="#链表的应用场景包括" class="header-anchor">#</a> 链表的应用场景包括：</h4> <ul><li>内存管理：操作系统中的内存分配通常使用链表来维护空闲内存块，以便高效地分配和释放内存。</li> <li>实现其他数据结构：许多其他数据结构，如栈、队列和哈希表等，可以使用链表来实现。</li> <li>垃圾回收：编程语言中的垃圾回收机制使用链表来跟踪和管理不再使用的对象。</li> <li>模拟表格：链表可以用来实现表格、电子表格等数据结构。</li> <li>网络协议：链表可以用于实现各种网络协议中的数据包。</li></ul> <p>需要注意的是，链表的访问效率较低，因为要遍历链表才能访问特定位置的元素。在某些场景下，链表的优点（动态性、高效的插入和删除操作）可能会使它成为更好的选择。</p> <h3 id="死锁、悲观锁、乐观锁"><a href="#死锁、悲观锁、乐观锁" class="header-anchor">#</a> 死锁、悲观锁、乐观锁</h3> <p>死锁（Deadlock）、悲观锁（Pessimistic Locking）和乐观锁（Optimistic Locking）都是与并发编程相关的概念。</p> <h4 id="死锁"><a href="#死锁" class="header-anchor">#</a> 死锁：</h4> <p>死锁是指在多线程或多进程环境下，每个线程或进程都在等待其他线程或进程释放资源，从而导致所有线程或进程都无法继续执行的状态。死锁通常涉及多个资源，每个资源都被一个线程或进程占用，同时又在等待其他资源。死锁是并发编程中一种常见的问题，需要谨慎设计和管理资源的获取和释放。</p> <h4 id="悲观锁"><a href="#悲观锁" class="header-anchor">#</a> 悲观锁：</h4> <p>悲观锁是一种较保守的锁策略，它假设在多线程环境下，数据会被其他线程修改，因此在访问数据之前会先获取锁。悲观锁的典型应用是使用数据库的行级锁，当一个线程正在操作数据时，它会锁定数据，其他线程必须等待锁释放后才能访问。</p> <h4 id="乐观锁"><a href="#乐观锁" class="header-anchor">#</a> 乐观锁：</h4> <p>乐观锁是一种较乐观的锁策略，它假设在多线程环境下，数据不会被其他线程频繁修改。因此，线程可以在不加锁的情况下读取数据，并在更新数据时检查是否有其他线程修改过数据。如果没有修改，就可以顺利更新；如果有修改，就需要重新读取并重新尝试更新。</p> <p>悲观锁和乐观锁都是处理并发访问数据的机制，根据应用场景和需求的不同，选择合适的锁策略。悲观锁会导致频繁的锁争用，但确保数据的一致性和安全性；而乐观锁则可以提高并发性，但需要处理可能的冲突和重试。</p> <h3 id="临界资源是什么"><a href="#临界资源是什么" class="header-anchor">#</a> 临界资源是什么</h3> <p>临界资源（Critical Resource）是指在多线程或多进程环境中，由于其特殊性质，需要进行互斥访问的共享资源。这意味着同一时刻只能有一个线程或进程访问该资源，以避免数据不一致或竞争条件等问题。</p> <p>临界资源可能是程序中的数据、文件、硬件设备、网络连接等，当多个线程或进程需要同时访问或修改这些资源时，可能会导致数据不一致、错误或崩溃等问题。为了保证数据的正确性和稳定性，需要对临界资源进行有效的同步控制，通常通过锁机制来实现。</p> <p>常见的例子包括：</p> <ul><li>在多线程程序中，多个线程需要访问共享的数据结构，如链表、队列等。</li> <li>在多进程环境中，多个进程需要访问共享的文件或数据库。</li> <li>在操作系统中，多个进程或线程需要竞争获取某个资源，如打印机、CPU 时间等。</li></ul> <p>通过使用锁、信号量、互斥量等同步机制，可以确保在任何时刻只有一个线程或进程能够访问临界资源，从而避免了潜在的并发问题。</p> <h3 id="讲一下锁、信号量、互斥量等同步机制"><a href="#讲一下锁、信号量、互斥量等同步机制" class="header-anchor">#</a> 讲一下锁、信号量、互斥量等同步机制</h3> <p>锁、信号量和互斥量是用于实现多线程或多进程并发控制的同步机制，用于保证临界资源的互斥访问。它们在不同的场景下有不同的特点和用法。</p> <h4 id="锁-lock"><a href="#锁-lock" class="header-anchor">#</a> 锁（Lock）：</h4> <p>锁是一种基本的同步机制，用于控制对共享资源的访问。在多线程环境下，锁可以阻止多个线程同时访问同一个资源，从而保证数据的一致性和正确性。常见的锁包括互斥锁（Mutex）和读写锁（Read-Write Lock）。互斥锁只允许一个线程访问临界资源，而读写锁允许多个线程同时读取资源，但只允许一个线程进行写操作。</p> <h4 id="信号量-semaphore-2"><a href="#信号量-semaphore-2" class="header-anchor">#</a> 信号量（Semaphore）：</h4> <p>信号量是一种更通用的同步机制，可以控制对多个资源的访问。信号量维护一个计数器，表示可用资源的数量。当一个线程或进程访问资源时，信号量会递减计数器，当计数器为零时，其他线程或进程就会被阻塞，直到有资源可用时才能继续。信号量常用于控制同时访问资源的数量，如线程池中的线程数量控制。</p> <h4 id="互斥量-mutex"><a href="#互斥量-mutex" class="header-anchor">#</a> 互斥量（Mutex）：</h4> <p>互斥量是一种特殊的锁，用于实现互斥访问共享资源。互斥量保证同一时刻只有一个线程可以访问资源，其他线程必须等待互斥量被释放。互斥量通常是二进制的，即只有两种状态：锁定和解锁。</p> <p>这些同步机制都有助于避免多个线程或进程对临界资源的并发访问，从而避免数据不一致、竞争条件和死锁等问题。在使用这些机制时，需要根据具体的场景和需求来选择合适的同步策略，以确保并发程序的正确性和性能。</p> <h3 id="常见调度算法说一下"><a href="#常见调度算法说一下" class="header-anchor">#</a> 常见调度算法说一下</h3> <p>在计算机科学中，调度算法用于管理和分配系统资源，以便有效地执行任务和进程。以下是一些常见的调度算法：</p> <ul><li>先来先服务（FCFS，First-Come, First-Served）： 按照任务或进程到达的顺序进行调度。简单易实现，但可能会导致长任务等待时间增加。</li> <li>最短作业优先（SJF，Shortest Job First）： 选择估计执行时间最短的任务进行调度。可以最小化平均等待时间，但可能会出现长任务被饿死的情况。</li> <li>优先级调度： 为每个任务分配一个优先级，根据优先级高低进行调度。可能导致优先级较低的任务长时间等待。</li> <li>时间片轮转（Round Robin）： 将 CPU 时间分成小的时间片，每个任务按顺序获得一个时间片，然后轮转到下一个任务。适用于多任务系统，公平地分配 CPU 时间。</li> <li>多级反馈队列（Multilevel Feedback Queue）： 将任务划分为多个队列，每个队列拥有不同的优先级。优先级较高的队列先执行，而任务在队列之间进行迁移，以平衡长任务和短任务的响应时间。</li> <li>最高响应比优先（HRRN，Highest Response Ratio Next）： 计算任务等待时间和服务时间的比率，选择响应比最高的任务进行调度。可以避免长任务等待时间过长。</li> <li>最早截止时间优先（EDF，Earliest Deadline First）： 根据任务的截止时间，选择截止时间最早的任务进行调度。适用于实时系统，以确保任务的截止时间得到满足。</li> <li>最小剩余时间优先（SRTF，Shortest Remaining Time First）： 在 SJF 的基础上，每次选择剩余执行时间最短的任务进行调度，适用于抢占式调度。</li></ul> <p>这些调度算法各有优缺点，适用于不同的应用场景。选择合适的调度算法取决于系统的需求、任务的特性以及性能指标的优先级。</p> <h2 id="模块化、组件化、优化、安全性"><a href="#模块化、组件化、优化、安全性" class="header-anchor">#</a> 模块化、组件化、优化、安全性</h2> <h3 id="对hooks的理解"><a href="#对hooks的理解" class="header-anchor">#</a> 对hooks的理解</h3> <p>React Hooks 是 React 16.8 版本引入的一种新特性，它们允许在无需编写 class 组件的情况下，在函数组件中使用 React 的状态（state）和生命周期等特性。Hooks 在编写、重用和测试组件方面提供了更灵活的方式，使函数组件能够拥有类似于 class 组件的功能。</p> <p>Hooks 提供了一系列的预定义函数，每个函数都用于处理不同的功能。以下是一些常用的 React Hooks：</p> <ul><li>useState：用于在函数组件中添加状态。它返回一个状态值和一个更新状态的函数，可以通过解构赋值来使用。</li> <li>useEffect：用于处理副作用（例如数据获取、订阅、DOM 操作等）。它在组件渲染之后执行，可以模拟类组件的生命周期方法（componentDidMount、componentDidUpdate、componentWillUnmount）。</li> <li>useContext：用于在组件中访问 React 的上下文（Context）。</li> <li>useReducer：类似于 useState，但用于处理复杂的状态逻辑，通常与 useContext 一起使用。</li> <li>useCallback：用于缓存函数引用，以避免不必要的函数重新创建。</li> <li>useMemo：用于缓存计算结果，以优化性能。</li> <li>useRef：用于获取 DOM 元素的引用或在组件渲染之间存储数据。</li> <li>useLayoutEffect：与 useEffect 类似，但在 DOM 更新之后同步执行，可以用于处理 DOM 操作。</li> <li>useImperativeHandle：用于自定义暴露给父组件的实例值。</li></ul> <p>Hooks 使代码更简洁、可读性更高，且在处理状态逻辑和副作用时更加灵活。它们还能够减少嵌套层级，促进逻辑的组织和重用，让组件更容易进行测试和维护。总之，Hooks 是 React 编程中重要的进步，使函数组件更强大且更易于管理。</p> <h3 id="react的hooks-原理的东西有看过吗"><a href="#react的hooks-原理的东西有看过吗" class="header-anchor">#</a> react的hooks，原理的东西有看过吗</h3> <p>React Hooks 是基于 React 的 Fiber 架构实现的，它的核心思想是在函数组件中实现状态管理和副作用处理，使函数组件具备类组件的功能。</p> <p>React Fiber 是 React 16 引入的一种新的协调机制，它改变了 React 的更新流程，使得 React 可以更好地处理异步渲染，提高性能。Hooks 利用了 Fiber 的特性，使得在函数组件中使用状态和生命周期的功能成为可能。</p> <p><strong>Hooks 的原理主要包括以下几点：</strong></p> <ul><li>Hooks 的数据结构：React 内部维护了一个 Hooks 数组，其中保存了当前组件中所有使用的 Hooks。每个 Hook 都有一个唯一的标识符，React 使用这些标识符来追踪每个 Hook 的状态。</li> <li>Hooks 的调用规则：Hooks 只能在函数组件的最顶层调用，不能在条件语句、循环或嵌套函数中调用。这是为了确保每次组件渲染时 Hooks 的调用顺序保持一致。</li> <li>useState 的原理：useState 实际上是一个函数，它会返回一个包含当前状态和更新状态的函数的数组。React 使用 Hooks 数组中的索引来确定当前组件使用的是哪个 useState。</li> <li>useEffect 的原理：useEffect 利用 Fiber 架构中的工作单元（work unit）来处理副作用。当组件进行更新时，React 会将 useEffect 中的副作用函数添加到工作单元中，然后在适当的时机执行这些函数。</li> <li>自定义 Hooks 的原理：自定义 Hooks 实际上是一个函数，它可以使用其他 Hooks 来组合出新的功能。自定义 Hooks 只是普通函数，但在命名上使用 &quot;use&quot; 前缀，这样 React 就能识别它们。</li></ul> <p>总之，React Hooks 的原理是基于 Fiber 架构和一系列规则来实现的，它通过特定的调用规则和数据结构，使得在函数组件中使用状态、生命周期和副作用等功能成为可能，从而提升了 React 组件的编写和管理体验。</p> <h3 id="webpack是干什么的-webpack是怎么创建项目的"><a href="#webpack是干什么的-webpack是怎么创建项目的" class="header-anchor">#</a> webpack是干什么的？webpack是怎么创建项目的？</h3> <p>Webpack 是一个现代的 JavaScript 应用程序静态模块打包工具，它可以将项目中的各种资源（如 JavaScript、CSS、图片等）视为模块，然后通过配置定义打包、转换、优化等操作，最终将这些模块打包成一个或多个输出文件，用于在浏览器中运行。</p> <p>Webpack 的主要功能包括：</p> <ul><li>模块打包：Webpack 可以将项目中的各种模块打包成一个或多个输出文件，将不同的模块组合到一起，使得应用程序可以按需加载和运行。</li> <li>依赖管理：Webpack 可以识别模块之间的依赖关系，并按照正确的顺序加载这些依赖，确保应用程序可以正确地运行。</li> <li>代码分割：Webpack 支持将应用程序代码分割成多个小块，可以实现按需加载，提高页面加载速度和性能。</li> <li>资源转换：Webpack 可以使用加载器（Loaders）来处理不同类型的资源，如将 ES6 代码转换成 ES5、将 Sass 转换成 CSS，或者将图片转换成 Base64 编码。</li> <li>插件系统：Webpack 支持丰富的插件系统，开发者可以使用插件来进行代码压缩、优化、提取 CSS、生成 HTML 等操作。</li></ul> <h3 id="webpack能处理什么类型的文件-不能处理什么类型的文件"><a href="#webpack能处理什么类型的文件-不能处理什么类型的文件" class="header-anchor">#</a> webpack能处理什么类型的文件？不能处理什么类型的文件？</h3> <p>Webpack 可以处理多种类型的文件，主要包括以下几种：</p> <ul><li>JavaScript 文件：Webpack 最常用的功能是处理 JavaScript 文件。它可以将多个 JavaScript 模块打包成一个或多个输出文件，并支持 ES6/ESNext 的语法转换和代码压缩。</li> <li>CSS 文件：Webpack 可以处理 CSS 文件，包括将 CSS 文件中的样式提取到单独的文件、压缩 CSS 代码等。</li> <li>样式预处理器：Webpack 支持处理使用 LESS、Sass 或 Stylus 等样式预处理器编写的样式文件，通过加载器将它们转换为普通的 CSS。</li> <li>图片和字体文件：Webpack 可以处理图片、图标和字体等文件，可以将它们转换成 Base64 编码，或者将它们复制到输出目录中。</li> <li>HTML 文件：Webpack 可以处理 HTML 文件，通常用于生成包含构建后的输出文件的 HTML 文件。</li> <li>其他资源文件：Webpack 还可以处理其他类型的资源文件，如 JSON 数据、CSV 文件等。</li></ul> <p>Webpack 并不是适用于所有类型的文件，它主要用于处理前端项目中的资源文件。Webpack 不太适合处理二进制文件（如视频、音频等）或后端服务器代码。对于这些文件，通常需要使用其他工具或技术进行处理。</p> <h3 id="了解-webpack-的-loader-和-plugin-吗-它们是怎么实现的"><a href="#了解-webpack-的-loader-和-plugin-吗-它们是怎么实现的" class="header-anchor">#</a> 了解 Webpack 的 loader 和 plugin 吗？它们是怎么实现的？</h3> <h3 id="说说你的理解-ui-组件和业务组件有什么区别"><a href="#说说你的理解-ui-组件和业务组件有什么区别" class="header-anchor">#</a> 说说你的理解 UI 组件和业务组件有什么区别？</h3> <h4 id="ui-组件-presentational-组件"><a href="#ui-组件-presentational-组件" class="header-anchor">#</a> UI 组件（Presentational 组件）：</h4> <ul><li>关注外观和交互：UI 组件主要关注页面的外观和交互，它们负责展示数据、处理用户输入，以及呈现界面元素。</li> <li>复用性较高：UI 组件通常是可复用的，它们可以在不同的页面和应用中被多次使用。</li> <li>没有业务逻辑：UI 组件通常不包含业务逻辑，它们只负责展示和处理用户界面的内容。</li> <li>无状态组件：UI 组件通常是无状态的，它们不会维护内部状态，只接收外部传入的 props 并进行渲染。</li> <li>命名简单：UI 组件的命名通常以功能为主，例如 Button、Input、Header 等。</li></ul> <h4 id="业务组件-container-组件"><a href="#业务组件-container-组件" class="header-anchor">#</a> 业务组件（Container 组件）：</h4> <ul><li>关注数据流和业务逻辑：业务组件主要关注数据的流动和业务逻辑的处理，它们负责管理数据状态、处理数据逻辑，以及协调多个 UI 组件之间的交互。</li> <li>复用性相对较低：业务组件可能在不同的应用中无法直接复用，因为它们通常与具体的业务场景紧密相关。</li> <li>包含业务逻辑：业务组件包含了与应用程序特定的业务逻辑相关的代码，例如数据获取、处理、状态管理等。</li> <li>有状态组件：业务组件通常是有状态的，因为它们需要维护数据状态，并根据业务需求进行更新。</li> <li>命名较具体：业务组件的命名通常反映了其所属的具体业务领域，例如 UserManagement、ProductDetails 等。</li></ul> <h3 id="如何设计复用的逻辑"><a href="#如何设计复用的逻辑" class="header-anchor">#</a> 如何设计复用的逻辑?</h3> <ol><li>抽象公共功能为函数或模块：
将通用的功能逻辑抽象成函数或模块，可以使这些逻辑在不同的场景中被复用。例如，将常用的数据格式化函数、网络请求封装、验证逻辑等抽象成独立的函数，供不同的组件或模块使用。</li> <li>使用高阶组件（HOC）：
高阶组件是一个函数，接受一个组件作为参数，并返回一个新的组件。它可以将通用的逻辑（例如数据获取、认证）封装成 HOC，然后在多个组件中使用。这样可以将逻辑与组件的 UI 分离，提高代码的可复用性。</li> <li>使用 Render Props 模式：
Render Props 是一种设计模式，通过将一个组件的渲染逻辑封装在函数中，然后将这个函数传递给另一个组件的 render prop 中，从而实现逻辑的复用。这可以使组件更灵活，并允许在不同的场景中共享逻辑。</li> <li>自定义 Hooks：
自定义 Hooks 是一种用于共享逻辑的方式。通过创建自定义 Hooks，可以将相关的逻辑状态和副作用封装起来，然后在多个组件中重复使用。这种方式可以在不同组件间共享状态和行为。</li> <li>组件库和 UI 库：
创建自己的组件库或使用现有的 UI 库，将通用的 UI 组件和样式封装起来。这样，可以在不同的项目中重用这些组件，从而减少重复开发。</li> <li>抽象数据管理逻辑：
如果项目需要管理复杂的数据状态，可以使用状态管理库（如 Redux、Mobx、Vuex）来抽象数据管理逻辑。这些库可以帮助你将数据状态从组件中分离出来，以实现数据的可复用性。</li> <li>良好的命名和文档：
设计可复用逻辑时，要使用清晰、描述性的命名，以便其他开发人员理解和使用。同时，编写详细的文档和示例，使其他人能够轻松理解和应用你的逻辑。</li> <li>测试可复用性：
在设计可复用逻辑时，要进行单元测试和集成测试，确保逻辑在不同场景下能够正确工作。测试可以帮助发现潜在的问题，并提高逻辑的稳定性。</li></ol> <h3 id="为什么选择服务端进行渲染"><a href="#为什么选择服务端进行渲染" class="header-anchor">#</a> 为什么选择服务端进行渲染?</h3> <p>选择服务器端渲染（Server-Side Rendering，SSR）的主要原因是为了改善页面加载速度、搜索引擎优化（SEO）以及提供更好的用户体验。以下是一些选择服务器端渲染的优势：</p> <ul><li>更快的首次加载速度： 在客户端渲染（Client-Side Rendering，CSR）中，浏览器需要下载完整的 JavaScript 代码后才能开始渲染页面，这可能会导致较慢的首次加载速度。而在服务器端渲染中，服务器会在返回 HTML 响应时就已经渲染好了部分页面内容，从而减少了客户端加载和渲染的时间，加快了首次加载速度。</li> <li>更好的 SEO： 搜索引擎通常可以更好地处理服务器端渲染的页面，因为它们可以直接获取到页面的静态 HTML 内容，而不需要等待 JavaScript 加载完成。这有助于提高网站在搜索引擎中的可见性和排名。</li> <li>更好的用户体验： 服务器端渲染可以提供更快的页面加载速度，用户不需要等待很长时间才能看到内容。此外，由于部分页面已经在服务器上渲染，用户可以更快地与页面进行交互。</li> <li>有助于解决性能问题： 在一些情况下，大量的客户端渲染可能会导致性能问题，特别是在移动设备上。服务器端渲染可以减轻客户端的渲染负担，提供更平滑的用户体验。</li></ul> <p>尽管服务器端渲染有很多优点，但也需要权衡其复杂性和对服务器资源的要求。服务器端渲染可能需要更多的服务器资源和更复杂的架构来处理请求，因此需要仔细考虑项目的需求和预期的用户体验，以确定是否选择服务器端渲染。在某些情况下，也可以使用混合的渲染方式，即在特定页面上使用服务器端渲染，而其他页面仍使用客户端渲染。</p> <h3 id="为什么服务端渲染有利于seo"><a href="#为什么服务端渲染有利于seo" class="header-anchor">#</a> 为什么服务端渲染有利于seo</h3> <p>服务端渲染（Server-Side Rendering，SSR）有利于 SEO（Search Engine Optimization，搜索引擎优化）的原因主要是因为搜索引擎可以更容易地理解和索引服务器端渲染的页面内容。以下是一些说明为什么 SSR 有利于 SEO 的因素：</p> <ol><li>页面内容完整性：在客户端渲染（Client-Side Rendering，CSR）中，页面一开始是一个空的 HTML 文档，然后通过 JavaScript 加载和渲染内容。但是搜索引擎的爬虫并不像浏览器一样执行 JavaScript，因此 CSR 的页面在初始渲染时可能没有内容，从而导致搜索引擎无法正确理解页面的内容。而在 SSR 中，页面在服务器端已经渲染完整，搜索引擎可以直接获取内容。</li> <li>更好的搜索引擎索引：搜索引擎爬虫可以直接获取 SSR 页面的 HTML 内容，并将其添加到索引中，从而更准确地理解页面的内容和结构。这有助于页面在搜索结果中的排名和展示。</li> <li>快速加载时间：SSR 可以提供更快的初始加载时间，因为页面在服务器端已经渲染好，用户可以直接看到内容，无需等待 JavaScript 的加载和执行。搜索引擎会考虑页面的加载时间作为排名的一个因素，因此快速的初始加载对 SEO 是有益的。</li> <li>提供元数据：在 SSR 中，可以在服务器端生成页面的元数据，如页面标题、描述和关键字等，这些信息有助于搜索引擎正确地理解页面的内容并生成有意义的搜索结果。</li> <li>避免隐藏内容问题：在 CSR 中，某些内容可能需要用户与页面交互后才会显示，搜索引擎爬虫无法执行这些交互操作，可能会导致部分内容被忽略。在 SSR 中，这些内容会在服务器端渲染，确保搜索引擎能够正确获取全部内容。</li></ol> <h3 id="非服务端渲染能做seo吗-浏览器爬虫原理是什么。"><a href="#非服务端渲染能做seo吗-浏览器爬虫原理是什么。" class="header-anchor">#</a> 非服务端渲染能做seo吗，浏览器爬虫原理是什么。</h3> <p>非服务端渲染（如客户端渲染，CSR）也可以通过一些方法来支持 SEO，但相比于服务端渲染（SSR），它在 SEO 方面的效果可能会稍逊一筹。浏览器爬虫会尝试执行 JavaScript 来获取内容，但仍存在一些限制和挑战。</p> <p>浏览器爬虫原理主要是模拟浏览器行为，通过执行页面中的 JavaScript 来获取页面内容。然后，它们会分析 DOM 结构、提取文本内容、链接和元数据等信息，将这些信息添加到搜索引擎的索引中。浏览器爬虫通常会使用 Webkit 引擎（如 Google Chrome）来执行 JavaScript，并获取页面渲染后的内容。</p> <p>然而，浏览器爬虫存在一些限制和挑战：</p> <ul><li>JavaScript 执行限制：浏览器爬虫可能不会执行所有类型的 JavaScript，特别是在加载过程中涉及到网络请求和异步操作的情况下。</li> <li>加载时间：浏览器爬虫会等待一段时间以确保页面加载完全，但如果页面加载时间过长，可能会影响爬虫获取内容的速度。</li> <li>动态内容：某些动态生成的内容可能无法被爬虫正确捕获，因为爬虫可能无法模拟所有的交互和渲染操作。</li> <li>SEO 可见性：搜索引擎爬虫可能会将页面的可见内容和隐藏内容（例如通过 JavaScript 动态加载的内容）作为不同的权重考虑。</li></ul> <h3 id="如果有大规模访问你的接口-或是有爬虫如何进行处理和优化"><a href="#如果有大规模访问你的接口-或是有爬虫如何进行处理和优化" class="header-anchor">#</a> 如果有大规模访问你的接口，或是有爬虫如何进行处理和优化?</h3> <h4 id="限制频率和访问次数"><a href="#限制频率和访问次数" class="header-anchor">#</a> 限制频率和访问次数：</h4> <p>实施限制访问频率和访问次数的策略，如使用 API 密钥、访问令牌、IP 限制等。这可以防止单个用户或爬虫对接口进行滥用。</p> <h4 id="ip-黑白名单"><a href="#ip-黑白名单" class="header-anchor">#</a> IP 黑白名单：</h4> <p>使用 IP 黑白名单来控制哪些 IP 可以访问接口，以阻止或允许特定 IP 的访问。这可以用于封禁恶意爬虫或允许特定的合法爬虫。</p> <h4 id="用户认证和授权"><a href="#用户认证和授权" class="header-anchor">#</a> 用户认证和授权：</h4> <p>要求用户进行身份认证并授予访问权限，以便只有合法用户能够访问接口。这可以防止未经授权的访问和爬虫滥用。</p> <h4 id="使用反爬虫策略"><a href="#使用反爬虫策略" class="header-anchor">#</a> 使用反爬虫策略：</h4> <p>使用技术和算法来识别和阻止爬虫，例如设置验证码、人机验证、浏览器指纹等。这可以有效减少恶意爬虫的访问。</p> <h4 id="使用缓存"><a href="#使用缓存" class="header-anchor">#</a> 使用缓存：</h4> <p>通过缓存接口响应数据来减轻服务器的负载。合适的缓存策略可以减少对数据库和其他资源的频繁访问。</p> <h4 id="分布式架构"><a href="#分布式架构" class="header-anchor">#</a> 分布式架构：</h4> <p>使用分布式架构来处理大规模的访问量，可以通过负载均衡和分布式缓存来平衡负载，确保系统的可伸缩性和稳定性。</p> <h4 id="数据压缩和精简"><a href="#数据压缩和精简" class="header-anchor">#</a> 数据压缩和精简：</h4> <p>在响应数据中使用压缩和精简的格式，如 Gzip 压缩和 JSON 精简，以减少数据传输的开销。</p> <h4 id="监控和分析"><a href="#监控和分析" class="header-anchor">#</a> 监控和分析：</h4> <p>实施监控和分析，及时发现异常访问行为和访问模式，以便采取适当的措施。</p> <h4 id="限制敏感信息"><a href="#限制敏感信息" class="header-anchor">#</a> 限制敏感信息：</h4> <p>避免将敏感信息直接暴露在接口中，尤其是对于容易被爬虫获取的信息，可以采取加密、脱敏等措施。</p> <h4 id="定期维护和更新"><a href="#定期维护和更新" class="header-anchor">#</a> 定期维护和更新：</h4> <p>定期检查和更新接口的安全性和性能，及时修复漏洞和优化性能。</p> <h3 id="如何做首屏优化"><a href="#如何做首屏优化" class="header-anchor">#</a> 如何做首屏优化?</h3> <h4 id="压缩和精简代码"><a href="#压缩和精简代码" class="header-anchor">#</a> 压缩和精简代码：</h4> <p>通过压缩和精简 HTML、CSS 和 JavaScript 代码，减少文件大小，从而加快页面加载速度。</p> <h4 id="使用浏览器缓存"><a href="#使用浏览器缓存" class="header-anchor">#</a> 使用浏览器缓存：</h4> <p>设置合适的缓存策略，利用浏览器缓存来存储页面资源，让用户在再次访问页面时能够更快地加载。</p> <h4 id="使用cdn加速"><a href="#使用cdn加速" class="header-anchor">#</a> 使用CDN加速：</h4> <p>使用内容分发网络（CDN）来分发页面资源，使用户可以从距离更近的服务器获取资源，提高加载速度。</p> <h4 id="懒加载和预加载"><a href="#懒加载和预加载" class="header-anchor">#</a> 懒加载和预加载：</h4> <p>对于非首屏关键内容，采用懒加载技术，只在用户需要时加载，以减少首次加载时间。同时，预加载首屏所需资源，使其在用户浏览前提前加载。</p> <h4 id="异步加载"><a href="#异步加载" class="header-anchor">#</a> 异步加载：</h4> <p>将页面中的 JavaScript 异步加载，以避免阻塞页面的渲染。可以使用async 或 defer 属性来控制脚本的加载行为。</p> <h4 id="优化图片"><a href="#优化图片" class="header-anchor">#</a> 优化图片：</h4> <p>对图片进行压缩、格式转换，使用适当的图片格式（如 WebP），并设置合适的图片尺寸，以减少图片加载时间。</p> <h4 id="减少请求次数"><a href="#减少请求次数" class="header-anchor">#</a> 减少请求次数：</h4> <p>将多个 CSS 或 JavaScript 文件合并成一个，减少 HTTP 请求次数，从而加快资源加载速度。</p> <h4 id="服务器端渲染-ssr"><a href="#服务器端渲染-ssr" class="header-anchor">#</a> 服务器端渲染（SSR）：</h4> <p>使用服务器端渲染技术，将页面在服务器端预先渲染，减少客户端渲染时间，提高页面加载速度。</p> <h4 id="避免阻塞资源"><a href="#避免阻塞资源" class="header-anchor">#</a> 避免阻塞资源：</h4> <p>将 JavaScript 放在页面底部，避免阻塞页面的渲染。对于 CSS，可以使用内联样式或将关键样式放在 </p><head> 部分。<p></p> <h4 id="优化字体加载"><a href="#优化字体加载" class="header-anchor">#</a> 优化字体加载：</h4> <p>使用 Web 字体时，选择适当的加载策略，如使用系统字体作为备选字体，或异步加载字体以防止影响页面加载速度。</p> <h4 id="使用优化工具"><a href="#使用优化工具" class="header-anchor">#</a> 使用优化工具：</h4> <p>使用各种优化工具，如 Google PageSpeed Insights、WebPageTest 等，分析和评估页面性能，并根据建议进行优化。</p> <h4 id="监控和持续优化"><a href="#监控和持续优化" class="header-anchor">#</a> 监控和持续优化：</h4> <p>定期监控页面的性能指标，如加载时间、首屏时间等，根据数据持续优化页面性能。</p> <h3 id="如何保证token的安全"><a href="#如何保证token的安全" class="header-anchor">#</a> 如何保证token的安全?</h3> <h4 id="使用-https"><a href="#使用-https" class="header-anchor">#</a> 使用 HTTPS：</h4> <p>使用安全套接字层协议（HTTPS）来加密数据传输，防止数据在网络中被窃取或篡改。</p> <h4 id="token-的存储方式"><a href="#token-的存储方式" class="header-anchor">#</a> Token 的存储方式：</h4> <p>尽量避免将敏感信息直接存储在 Token 中，如密码等。在服务器端，将用户数据和权限信息存储在安全的数据库中，Token 只存储标识信息。</p> <h4 id="token-的过期时间"><a href="#token-的过期时间" class="header-anchor">#</a> Token 的过期时间：</h4> <p>设置 Token 的过期时间，确保 Token 在一段时间后失效，以减少 Token 被滥用的风险。在过期后需要重新认证和获取新的 Token。</p> <h4 id="使用-jwt-json-web-token-时注意事项"><a href="#使用-jwt-json-web-token-时注意事项" class="header-anchor">#</a> 使用 JWT（JSON Web Token）时注意事项：</h4> <p>使用 JWT 时，确保 Payload 中不包含敏感信息。对于不需要加密的信息，可以将其放在 Payload 中。对于需要加密的信息，可以在 Payload 中使用签名保护数据完整性。</p> <h4 id="token-的签名和加密"><a href="#token-的签名和加密" class="header-anchor">#</a> Token 的签名和加密：</h4> <p>使用签名和加密技术，确保 Token 在传输过程中不被篡改。例如，可以使用 HMAC（Hash-based Message Authentication Code）来生成签名。</p> <h4 id="限制-token-的使用范围"><a href="#限制-token-的使用范围" class="header-anchor">#</a> 限制 Token 的使用范围：</h4> <p>使用权限控制，确保 Token 只能访问特定资源和接口。对于不同权限级别的用户，应根据需要控制其访问权限。</p> <h4 id="防止-csrf-攻击"><a href="#防止-csrf-攻击" class="header-anchor">#</a> 防止 CSRF 攻击：</h4> <p>在实现认证时，要使用 CSRF（Cross-Site Request Forgery）防护措施，以防止攻击者利用用户的身份发送恶意请求。</p> <h4 id="安全存储-token"><a href="#安全存储-token" class="header-anchor">#</a> 安全存储 Token：</h4> <p>在客户端存储 Token 时，可以使用 HTTP-only 和 Secure 标志来提高安全性。HTTP-only 标志可以防止 JavaScript 访问 Cookie，Secure 标志可以保证只在 HTTPS 连接中传输 Cookie。</p> <h4 id="实现注销机制"><a href="#实现注销机制" class="header-anchor">#</a> 实现注销机制：</h4> <p>提供注销功能，使用户能够主动撤销 Token，从而防止 Token 被滥用。在注销后，Token 应该立即失效。</p> <h4 id="监控和日志记录"><a href="#监控和日志记录" class="header-anchor">#</a> 监控和日志记录：</h4> <p>定期监控 Token 的使用情况，记录异常活动并采取必要的措施。记录 Token 的生成、验证和失效等操作，以便追踪和调查问题。</p> <h4 id="定期更新-token"><a href="#定期更新-token" class="header-anchor">#</a> 定期更新 Token：</h4> <p>定期更换 Token，以减少 Token 被窃取或滥用的风险。可以使用刷新 Token 机制来获取新的 Token。</p> <h4 id="教育用户安全性"><a href="#教育用户安全性" class="header-anchor">#</a> 教育用户安全性：</h4> <p>告知用户不要轻易泄露 Token，避免在不安全的地方使用 Token（如 URL、日志等）。</p> <h3 id="babel-有了解过吗"><a href="#babel-有了解过吗" class="header-anchor">#</a> babel 有了解过吗？</h3> <p>Babel 是一个用于将最新版本的 JavaScript 代码转换成向后兼容版本的工具。它可以将使用最新 ECMAScript 标准的代码转换为在旧版本浏览器中运行的代码，以及在当前流行的 JavaScript 环境中运行的代码</p> <h3 id="前端哪些地方需要做性能优化-前端如何做性能优化"><a href="#前端哪些地方需要做性能优化-前端如何做性能优化" class="header-anchor">#</a> 前端哪些地方需要做性能优化,前端如何做性能优化</h3> <h4 id="页面加载速度"><a href="#页面加载速度" class="header-anchor">#</a> 页面加载速度：</h4> <p>减少 HTTP 请求：合并和压缩文件，减少页面需要的资源文件数量。
使用浏览器缓存：利用浏览器缓存来缓存静态资源，减少重复加载。
使用内容分发网络（CDN）：将资源部署到全球各地的服务器，加速资源的传输和加载。</p> <h4 id="图片优化"><a href="#图片优化" class="header-anchor">#</a> 图片优化：</h4> <p>压缩图片：使用适当的工具将图片压缩，减小图片文件大小。
使用适当的图片格式：选择合适的图片格式，如 WebP，以达到更好的压缩效果。</p> <h4 id="代码优化"><a href="#代码优化" class="header-anchor">#</a> 代码优化：</h4> <p>代码压缩和合并：使用工具将 JavaScript 和 CSS 代码进行压缩和合并，减小文件大小。
延迟加载：将不关键的脚本延迟加载，以减少初始页面加载时间。
异步加载：使用 async 或 defer 属性加载脚本，以减少对页面渲染的阻塞。</p> <h4 id="dom-操作优化"><a href="#dom-操作优化" class="header-anchor">#</a> DOM 操作优化：</h4> <p>最小化 DOM 操作：减少频繁的 DOM 操作，可以减少页面重新渲染的开销。
使用事件委托：将事件监听器绑定在父元素上，通过事件冒泡捕获子元素的事件。</p> <h4 id="网络请求优化"><a href="#网络请求优化" class="header-anchor">#</a> 网络请求优化：</h4> <p>减少请求次数：合并多个请求，减少网络请求次数。
使用 HTTP/2：利用 HTTP/2 的多路复用特性，提高资源并行加载的效率。</p> <h4 id="渲染性能优化"><a href="#渲染性能优化" class="header-anchor">#</a> 渲染性能优化：</h4> <p>避免强制同步布局和重绘：减少频繁的布局和渲染操作，以优化渲染性能。
使用 CSS 动画和过渡：避免使用 JavaScript 实现动画，尽量使用 CSS 动画和过渡。</p> <h4 id="移动端优化"><a href="#移动端优化" class="header-anchor">#</a> 移动端优化：</h4> <p>使用响应式设计：针对不同屏幕尺寸和设备类型提供适当的布局和样式。
使用移动端优化的图片：根据屏幕尺寸和设备像素比选择适当的图片大小和分辨率。</p> <h4 id="服务端渲染-ssr"><a href="#服务端渲染-ssr" class="header-anchor">#</a> 服务端渲染（SSR）：</h4> <p>使用服务器端渲染技术，将部分或全部页面在服务器上预渲染，减少客户端渲染时间。</p> <h4 id="监控和分析-2"><a href="#监控和分析-2" class="header-anchor">#</a> 监控和分析：</h4> <p>使用性能监控工具：定期监控页面性能，识别潜在的性能问题。
使用浏览器开发者工具：利用浏览器的性能分析工具来分析页面加载过程。</p> <h4 id="优化移动网络和缓慢网络情况"><a href="#优化移动网络和缓慢网络情况" class="header-anchor">#</a> 优化移动网络和缓慢网络情况：</h4> <p>使用懒加载：将非关键内容延迟加载，以减少初始页面加载时间。
使用离线缓存：实现离线访问功能，使用户在无网络情况下也能浏览页面。</p> <h3 id="如何分析一个页面的性能"><a href="#如何分析一个页面的性能" class="header-anchor">#</a> 如何分析一个页面的性能</h3> <p>分析页面性能是优化前端应用的重要步骤，可以通过以下方法来进行：</p> <h4 id="使用浏览器开发者工具"><a href="#使用浏览器开发者工具" class="header-anchor">#</a> 使用浏览器开发者工具：</h4> <p>现代浏览器都提供了强大的开发者工具，其中包含性能分析功能。在 Chrome 中，可以使用 &quot;Performance&quot; 面板来记录页面加载过程，并分析网络请求、渲染时间、CPU 使用等数据。</p> <h4 id="使用在线工具"><a href="#使用在线工具" class="header-anchor">#</a> 使用在线工具：</h4> <p>有许多在线性能分析工具可供使用，如 Google PageSpeed Insights、WebPageTest、GTmetrix 等。这些工具可以根据网页 URL 提供详细的性能报告，包括加载时间、优化建议等。</p> <h4 id="使用-lighthouse"><a href="#使用-lighthouse" class="header-anchor">#</a> 使用 Lighthouse：</h4> <p>Lighthouse 是 Google 开发的开源工具，可以在 Chrome 开发者工具中使用。它可以评估网页的性能、可访问性、最佳实践等方面，并提供改进建议。</p> <h4 id="监控工具"><a href="#监控工具" class="header-anchor">#</a> 监控工具：</h4> <p>使用性能监控工具（如 New Relic、Sentry 等）来实时监控网页的性能指标，例如加载时间、请求次数、错误率等。</p> <h4 id="自定义监测"><a href="#自定义监测" class="header-anchor">#</a> 自定义监测：</h4> <p>可以在代码中埋点，手动记录页面加载时间、关键操作的耗时等信息，然后将这些数据发送到监控系统进行分析。</p> <h4 id="网络面板"><a href="#网络面板" class="header-anchor">#</a> 网络面板：</h4> <p>使用浏览器开发者工具的 &quot;Network&quot; 面板，可以查看网络请求的时间线，了解每个请求的耗时、大小等。</p> <h4 id="内存和-cpu-分析"><a href="#内存和-cpu-分析" class="header-anchor">#</a> 内存和 CPU 分析：</h4> <p>使用浏览器开发者工具的 &quot;Performance&quot; 面板，可以分析页面的内存和 CPU 使用情况，找出可能的性能瓶颈。</p> <h4 id="移动设备模拟"><a href="#移动设备模拟" class="header-anchor">#</a> 移动设备模拟：</h4> <p>使用开发者工具的移动设备模拟功能，可以模拟不同移动设备上的页面加载性能，帮助优化移动端体验。</p> <h3 id="从开发者视角看-有哪些性能指标、性能指标如何测出来的"><a href="#从开发者视角看-有哪些性能指标、性能指标如何测出来的" class="header-anchor">#</a> 从开发者视角看，有哪些性能指标、性能指标如何测出来的</h3> <h4 id="页面加载时间-page-load-time"><a href="#页面加载时间-page-load-time" class="header-anchor">#</a> 页面加载时间（Page Load Time）：</h4> <p>这是页面从开始加载到加载完毕所需的时间。可以使用浏览器开发者工具的 &quot;Network&quot; 面板或性能分析工具来测量。也可以通过 JavaScript 计算页面完全加载所需的时间。</p> <h4 id="首次渲染时间-first-paint-first-meaningful-paint"><a href="#首次渲染时间-first-paint-first-meaningful-paint" class="header-anchor">#</a> 首次渲染时间（First Paint / First Meaningful Paint）：</h4> <p>这是页面首次开始绘制内容的时间。可以使用浏览器开发者工具的性能分析功能来测量，也可以使用 Lighthouse 等工具进行评估。</p> <h4 id="首次可交互时间-first-interactive-time"><a href="#首次可交互时间-first-interactive-time" class="header-anchor">#</a> 首次可交互时间（First Interactive Time）：</h4> <p>这是页面在首次渲染后，用户可以进行交互的时间点。可以使用性能分析工具或浏览器开发者工具的 &quot;Performance&quot; 面板来测量。</p> <h4 id="domcontentloaded-时间"><a href="#domcontentloaded-时间" class="header-anchor">#</a> DOMContentLoaded 时间：</h4> <p>这是页面的 DOM 树构建完毕并且所有的资源已加载完成的时间点。可以使用性能分析工具或浏览器开发者工具的 &quot;Network&quot; 面板测量。</p> <h4 id="资源加载时间"><a href="#资源加载时间" class="header-anchor">#</a> 资源加载时间：</h4> <p>可以测量各个资源（图片、样式、脚本等）的加载时间，以及资源的并行加载情况。浏览器开发者工具的 &quot;Network&quot; 面板可以查看资源的加载时间线。</p> <h4 id="渲染性能-render-performance"><a href="#渲染性能-render-performance" class="header-anchor">#</a> 渲染性能（Render Performance）：</h4> <p>可以测量页面的渲染性能，包括每帧的渲染时间、帧率等。浏览器开发者工具的 &quot;Performance&quot; 面板可以提供有关渲染性能的信息。</p> <h4 id="cpu-和内存使用"><a href="#cpu-和内存使用" class="header-anchor">#</a> CPU 和内存使用：</h4> <p>可以测量页面在加载和交互过程中的 CPU 和内存使用情况。浏览器开发者工具的 &quot;Performance&quot; 面板可以查看相关信息。</p> <h4 id="网络请求和带宽利用率"><a href="#网络请求和带宽利用率" class="header-anchor">#</a> 网络请求和带宽利用率：</h4> <p>可以测量网络请求的数量、大小和带宽利用率。浏览器开发者工具的 &quot;Network&quot; 面板可以查看相关数据。</p> <h4 id="错误和异常情况"><a href="#错误和异常情况" class="header-anchor">#</a> 错误和异常情况：</h4> <p>可以监测页面加载过程中的错误和异常情况，如 JavaScript 错误、HTTP 错误等。浏览器开发者工具的 &quot;Console&quot; 面板可以查看错误信息。</p> <h4 id="用户体验数据"><a href="#用户体验数据" class="header-anchor">#</a> 用户体验数据：</h4> <p>可以收集用户体验数据，如页面加载时间、交互响应时间等，以了解实际用户在不同条件下的使用体验。</p> <p>以上指标可以通过浏览器开发者工具、性能分析工具、在线工具、监控工具等进行测量和分析。不同指标能够帮助开发者了解页面性能的各个方面，从而更好地进行性能优化。</p> <h3 id="从用户角度看-还有哪些指标-web有哪些性能指标"><a href="#从用户角度看-还有哪些指标-web有哪些性能指标" class="header-anchor">#</a> 从用户角度看，还有哪些指标,web有哪些性能指标</h3> <ul><li>加载时间（Page Load Time）</li> <li>首次渲染时间（First Paint / First Meaningful Paint）</li> <li>首次可交互时间（First Interactive Time）</li> <li>页面响应时间（Page Response Time）</li> <li>页面动画的流畅性</li> <li>内容加载顺序</li> <li>页面稳定性（Stability）</li> <li>移动端适配</li> <li>可访问性（Accessibility）</li></ul> <h3 id="移动端应用有哪些性能指标"><a href="#移动端应用有哪些性能指标" class="header-anchor">#</a> 移动端应用有哪些性能指标</h3> <ul><li>应用启动时间（App Launch Time）</li> <li>页面切换速度（Screen Transition Speed）</li> <li>网络请求速度（Network Request Speed）</li> <li>页面渲染速度（Rendering Speed）</li> <li>内存占用（Memory Usage）</li> <li>CPU 使用率（CPU Usage）</li> <li>电池消耗（Battery Consumption）</li> <li>页面加载速度（Page Load Speed）</li> <li>应用大小（App Size）</li> <li>应用闪退率（Crash Rate）</li> <li>可访问性和可用性（Accessibility and Usability）</li> <li>响应速度（Response Time）</li></ul> <h3 id="http请求过多就说明性能差吗"><a href="#http请求过多就说明性能差吗" class="header-anchor">#</a> http请求过多就说明性能差吗</h3> <p>不一定。虽然过多的 HTTP 请求可以导致性能下降，但并不是所有情况下都会直接导致性能差。HTTP 请求过多可能会对性能产生影响，但需要考虑多个因素：</p> <ol><li>网络带宽和延迟：
过多的 HTTP 请求可能会占用更多的网络带宽，特别是在低速网络条件下。此外，每个请求都需要经过网络延迟，这可能导致页面加载时间增加。</li> <li>请求响应时间：
每个 HTTP 请求都需要服务器处理和响应，过多的请求可能会导致服务器负担增加，响应时间变慢，影响页面加载速度。</li> <li>浏览器并发连接数限制：
大多数浏览器对同时打开的连接数有限制，过多的请求可能会导致浏览器阻塞其他请求，从而影响页面加载和渲染。</li> <li>资源大小：
请求过多的资源可能会导致页面大小增加，从而影响加载时间和用户体验。</li> <li>缓存机制：
如果合理使用缓存机制，可以减少对相同资源的重复请求，从而减轻服务器和网络的压力。</li> <li>异步加载：
合理使用异步加载技术，可以并行加载资源，减少等待时间。</li> <li>域名分片：
将资源分布在多个域名下，可以增加浏览器并发加载资源的数量，加快页面加载。</li> <li>CDN 使用：
使用内容分发网络（CDN）可以将资源分布在全球多个节点上，提高资源加载速度。</li></ol> <h3 id="cdn缓存查询步骤"><a href="#cdn缓存查询步骤" class="header-anchor">#</a> CDN缓存查询步骤</h3> <p>CDN（内容分发网络）的缓存查询步骤可以概括为以下几个步骤：</p> <ol><li>DNS 解析：
当用户访问一个网站时，浏览器首先会执行 DNS 解析，将域名转换为服务器 IP 地址。</li> <li>CDN 路由选择：
CDN 会根据用户的地理位置、网络状况等选择最近的节点（边缘服务器）来处理请求。这一步又称为“就近选址”。</li> <li>边缘服务器缓存查询：
边缘服务器会检查是否有与用户请求相对应的缓存内容。如果有，将返回缓存内容，这就是缓存命中。</li> <li>缓存命中：
如果边缘服务器找到了与用户请求匹配的缓存内容，就会返回缓存内容。这是一种高效的情况，因为无需从源服务器获取内容。</li> <li>缓存未命中：
如果边缘服务器没有找到缓存内容，或者缓存已过期，它会发送请求到源服务器，以获取最新的内容。</li> <li>源服务器响应：
源服务器收到请求后，会根据请求返回相应的内容。这个内容可能会经过一些处理，例如 Gzip 压缩、图片优化等。</li> <li>边缘服务器缓存更新：
当源服务器返回内容后，边缘服务器会将内容存储在缓存中，以便将来的请求可以命中缓存。</li> <li>内容传递给用户：
最终，边缘服务器将内容传递给用户，用户在浏览器中展示网页内容。</li></ol> <h3 id="大图片怎么优化-比如一个超大的地图-怎么检测一个大图片"><a href="#大图片怎么优化-比如一个超大的地图-怎么检测一个大图片" class="header-anchor">#</a> 大图片怎么优化（比如一个超大的地图）：怎么检测一个大图片</h3> <h4 id="压缩图片"><a href="#压缩图片" class="header-anchor">#</a> 压缩图片：</h4> <p>使用图片压缩工具，如 Photoshop、TinyPNG、ImageOptim 等，可以将图片的文件大小减小，同时尽量保持图片质量。</p> <h4 id="选择合适的格式"><a href="#选择合适的格式" class="header-anchor">#</a> 选择合适的格式：</h4> <p>根据图片的内容选择合适的图片格式。JPEG 格式适用于照片和渐变图像，PNG 格式适用于图标和透明图片，WebP 是一种现代的高效图片格式。</p> <h4 id="分割图片"><a href="#分割图片" class="header-anchor">#</a> 分割图片：</h4> <p>如果图片过大，可以考虑将其分割成多个小图，然后通过 CSS 或 JavaScript 将它们拼接在一起。</p> <h4 id="使用图片瓦片-image-tiles"><a href="#使用图片瓦片-image-tiles" class="header-anchor">#</a> 使用图片瓦片（Image Tiles）：</h4> <p>对于大地图等情况，可以将图片拆分成多个小瓦片，然后根据用户视口加载相应的瓦片，以减少加载时间。</p> <h4 id="懒加载"><a href="#懒加载" class="header-anchor">#</a> 懒加载：</h4> <p>使用懒加载技术，只在用户滚动到图片可见区域时加载图片，而不是一开始就加载所有图片。</p> <h4 id="使用-css-sprites"><a href="#使用-css-sprites" class="header-anchor">#</a> 使用 CSS Sprites：</h4> <p>对于多个小图标，可以将它们合并成一张图片，然后通过 CSS 的背景定位来显示不同的图标。</p> <h4 id="使用矢量图形"><a href="#使用矢量图形" class="header-anchor">#</a> 使用矢量图形：</h4> <p>对于图标和简单的图形，考虑使用矢量图形（SVG），它们可以缩放而不会失真。</p> <h4 id="响应式图片"><a href="#响应式图片" class="header-anchor">#</a> 响应式图片：</h4> <p>使用不同尺寸的图片，根据不同设备和屏幕尺寸选择合适的图片加载，以减少不必要的带宽消耗。</p> <h4 id="检测大图片是否需要优化可以通过以下方式进行"><a href="#检测大图片是否需要优化可以通过以下方式进行" class="header-anchor">#</a> <strong>检测大图片是否需要优化可以通过以下方式进行：</strong></h4> <h4 id="图片大小分析"><a href="#图片大小分析" class="header-anchor">#</a> 图片大小分析：</h4> <p>使用图片编辑工具或在线图片压缩工具，查看图片的大小并分析是否可以进一步减小。</p> <h4 id="页面性能工具"><a href="#页面性能工具" class="header-anchor">#</a> 页面性能工具：</h4> <p>使用页面性能分析工具（如 Google PageSpeed Insights、Lighthouse）来检测页面加载性能，其中可能会提供优化建议，包括图片优化。</p> <h4 id="网络开发者工具"><a href="#网络开发者工具" class="header-anchor">#</a> 网络开发者工具：</h4> <p>浏览器的开发者工具中提供网络面板，可以查看每个图片的大小、加载时间和请求情况，从而判断哪些图片需要优化。</p> <h4 id="在线图片优化工具"><a href="#在线图片优化工具" class="header-anchor">#</a> 在线图片优化工具：</h4> <p>使用在线图片优化工具，上传图片并获得优化后的版本，通常会显示优化前后的文件大小和质量。</p> <h3 id="假如你知道是一个大图片怎么优化-懒加载-预加载-分片"><a href="#假如你知道是一个大图片怎么优化-懒加载-预加载-分片" class="header-anchor">#</a> 假如你知道是一个大图片怎么优化，懒加载，预加载，分片</h3> <h4 id="懒加载-lazy-loading"><a href="#懒加载-lazy-loading" class="header-anchor">#</a> 懒加载（Lazy Loading）：</h4> <p>懒加载是一种延迟加载图片的技术，只有当用户滚动到图片可见区域时才加载图片。这可以减少初始页面加载时间，尤其对于大图片而言效果显著。通过以下方式实现懒加载：</p> <ul><li>使用 loading=&quot;lazy&quot; 属性（HTML5 属性），浏览器会自动延迟加载图片。</li> <li>使用 JavaScript 监听滚动事件，当图片进入视口时，动态加载图片。</li></ul> <h4 id="预加载-preloading"><a href="#预加载-preloading" class="header-anchor">#</a> 预加载（Preloading）：</h4> <p>预加载是提前加载可能会在未来出现的资源，可以加快用户访问其他页面时的加载速度。对于大图片，可以在首屏加载完毕后，利用空闲时间加载其他页面可能需要的大图片。</p> <h4 id="分片-image-slicing"><a href="#分片-image-slicing" class="header-anchor">#</a> 分片（Image Slicing）：</h4> <p>对于大图片，可以将其分割成多个小片段，称为图片瓦片（Image Tiles）。然后，根据用户当前视口位置和缩放等级，动态加载相应的瓦片。这样可以实现图片的分批加载，提高用户体验。</p> <h3 id="分片怎么保证顺序和不丢失-网络原因导致丢失了怎么办"><a href="#分片怎么保证顺序和不丢失-网络原因导致丢失了怎么办" class="header-anchor">#</a> 分片怎么保证顺序和不丢失，网络原因导致丢失了怎么办</h3> <p>分片加载大图片时确保顺序和不丢失是一个复杂的问题，需要在前端和后端进行一些处理来实现可靠的分片加载。以下是一些方法来保证分片顺序和处理丢失的情况：</p> <ol><li>分片顺序保证：</li></ol> <ul><li>在前端：前端需要按照预定的顺序请求分片，并等待每个分片加载完毕后再请求下一个分片。可以使用递归、Promise 链或 async/await 等方式确保顺序。</li> <li>在后端：后端需要按照请求的分片顺序返回相应的分片内容。可以根据请求参数或请求头中的分片序号来确定要返回哪个分片。</li></ul> <ol start="2"><li>分片丢失处理：</li></ol> <ul><li>超时和重试：在前端，如果请求某个分片超时或失败，可以使用超时机制进行重试。在后端，可以检测到丢失请求并重新发送丢失的分片。</li> <li>完整性校验：每个分片都可以附带一个哈希值，用于校验分片的完整性。如果某个分片的哈希值不匹配，说明分片可能丢失或损坏，需要重新请求。</li> <li>错误处理和日志记录：前端和后端都应该有完善的错误处理机制，记录可能出现的错误，以便进行问题追踪和修复。</li></ul> <ol start="3"><li>断点续传：
在分片加载中，可以使用断点续传的方式。如果因为网络问题导致分片丢失，用户可以重新发起请求，后端可以从上次丢失的位置继续传送分片，避免从头开始加载。</li> <li>丢失分片重建：
如果因为网络问题丢失了很多分片，可以提供一个重建机制，允许用户重新请求所有分片，后端将重新生成完整的分片序列。</li></ol> <h3 id="图片懒加载怎么做得-有哪些常见方案"><a href="#图片懒加载怎么做得-有哪些常见方案" class="header-anchor">#</a> 图片懒加载怎么做得？有哪些常见方案？</h3> <p>图片懒加载是一种优化技术，用于推迟加载页面中的图片，只有当图片进入用户的视口（可见区域）时才开始加载，以减少初始页面加载时间。以下是一些常见的图片懒加载方案：</p> <ol><li>使用 loading=&quot;lazy&quot; 属性（HTML5 属性）：
在 HTML5 中，可以使用 loading=&quot;lazy&quot; 属性将懒加载应用于图片标签。当浏览器支持该属性时，图片会在进入视口时自动加载。这是一种非常简单的实现方式。</li></ol> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>image.jpg<span class="token punctuation">&quot;</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Image<span class="token punctuation">&quot;</span></span> <span class="token attr-name">loading</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>lazy<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ol start="2"><li>基于 Intersection Observer API：
Intersection Observer API 允许开发者监听元素是否进入用户视口。通过该 API，可以检测到图片何时进入视口，然后开始加载图片。这是一种更强大和灵活的懒加载方式。</li> <li>使用 JavaScript 监听滚动事件：
这是一种传统的方法，通过监听滚动事件，判断图片是否进入视口，然后加载图片。然而，相比于 Intersection Observer API，这种方法可能需要更多的处理，因为需要计算元素位置和滚动位置。</li></ol> <h3 id="说一下数据检测的几种方式。你知道原理吗"><a href="#说一下数据检测的几种方式。你知道原理吗" class="header-anchor">#</a> 说一下数据检测的几种方式。你知道原理吗？</h3> <p>数据检测是在前端开发中常用的技术，用于监测数据的变化或合法性。以下是几种常见的数据检测方式以及它们的原理：</p> <ul><li>手动检测： 这是一种最基础的数据检测方式，开发者通过编写逻辑代码来手动检测数据的变化。当需要检测数据是否发生变化时，开发者需要编写比较逻辑来比较新旧数据的差异。</li> <li>脏检查（Dirty Checking）： 脏检查是一种自动化的数据检测方式，它通过定期轮询数据模型，比较新旧数据来检测是否发生变化。当发现数据发生变化时，会触发相应的更新操作。AngularJS 1.x 中的数据绑定机制就采用了脏检查的方式。</li> <li>数据劫持（Data Binding）： 数据劫持是一种在数据访问时劫持数据的方式，当访问数据时，会触发 getter 函数，在修改数据时，会触发 setter 函数。这样可以在数据发生变化时自动通知相应的更新操作。Vue.js 中的双向数据绑定就是基于数据劫持实现的。</li> <li>观察者模式（Observer Pattern）： 观察者模式是一种设计模式，用于实现对象之间的一对多依赖关系。当一个对象的状态发生变化时，所有依赖于它的对象都会得到通知并自动更新。在数据检测中，可以使用观察者模式来建立数据和视图之间的关系，当数据变化时，通知相关的视图进行更新。</li> <li>Proxy 对象： Proxy 是 JavaScript 中的一个内置对象，可以用来拦截并定制对象的操作。通过使用 Proxy 对象，可以监测对象的读取、赋值、删除等操作，并在操作发生时触发相应的逻辑。Vue.js 3 中使用 Proxy 来实现响应式数据。</li></ul> <p>不同的数据检测方式原理上有所不同，但它们的共同目标都是实现数据变化时的自动更新操作，以提升开发效率和用户体验。</p> <h3 id="跨端如何开发"><a href="#跨端如何开发" class="header-anchor">#</a> 跨端如何开发</h3> <ol><li>响应式设计：
使用响应式设计和布局技术，确保你的网站能够在不同设备和屏幕尺寸上适应良好。这种方式适合于不需要大量定制化移动端功能的项目。</li> <li>使用框架：</li></ol> <ul><li>React Native：使用React Native可以将React技术用于移动应用开发，共享大部分代码，同时支持构建原生应用。</li> <li>Flutter：Flutter是Google开发的UI框架，可以用于构建跨平台移动应用和Web应用。</li> <li>Vue.js + Vue Native：结合Vue.js和Vue Native可以实现跨Web和移动端的开发。</li></ul> <ol start="3"><li>PWA（Progressive Web Apps）：
PWA允许你将Web应用制作成更像原生应用的形式，用户可以将应用添加到主屏幕，离线访问，具备更好的用户体验。</li> <li>Hybrid App开发：
使用Hybrid App框架，如Ionic、Cordova等，将Web技术嵌入到原生容器中，以构建跨平台应用。这种方式通常更接近Web开发，但也有一些限制。</li> <li>通用组件库：
开发一个通用的UI组件库，可以在Web和移动端共享使用，从而保持一致的设计和用户体验。</li> <li>适配和兼容性测试：
确保你的应用在不同平台上有良好的适配和兼容性。可能需要根据不同平台的特点进行一些样式和功能的调整。</li> <li>平台特定代码：
对于一些需要平台特定功能的情况，可能需要编写一些平台特定的代码。这是权衡，根据项目需求来决定是否值得。</li> <li>移动端和Web端分开开发：
对于一些要求高度定制化和复杂功能的项目，可能需要分开开发移动端和Web端，分别针对不同的平台进行开发。</li></ol> <h3 id="xss攻击和csrf攻击"><a href="#xss攻击和csrf攻击" class="header-anchor">#</a> xss攻击和csrf攻击</h3> <p>XSS（跨站脚本攻击）和CSRF（跨站请求伪造攻击）都是常见的网络安全攻击类型，针对的是Web应用程序的漏洞。它们分别利用用户浏览器的特性，从而在用户不知情的情况下执行恶意操作或发起非授权请求。</p> <h4 id="xss-跨站脚本攻击"><a href="#xss-跨站脚本攻击" class="header-anchor">#</a> XSS（跨站脚本攻击）：</h4> <p>XSS攻击是指攻击者通过向Web页面插入恶意脚本，当其他用户浏览该页面时，恶意脚本会在用户浏览器中执行。XSS攻击分为三种类型：</p> <ul><li>存储型（Persistent XSS）：攻击者将恶意脚本存储到服务器端，其他用户浏览页面时脚本会从服务器加载并执行。</li> <li>反射型（Reflected XSS）：攻击者将恶意脚本作为参数附加在URL中，当用户点击恶意链接时，脚本会被执行。</li> <li>DOM型（DOM-based XSS）：攻击利用浏览器解析DOM（文档对象模型）时的漏洞，执行恶意脚本。
防范XSS攻击的方法包括输入验证、输出编码、使用CSP（内容安全策略）等。</li></ul> <h4 id="csrf-跨站请求伪造攻击"><a href="#csrf-跨站请求伪造攻击" class="header-anchor">#</a> CSRF（跨站请求伪造攻击）：</h4> <p>CSRF攻击是指攻击者利用用户已登录的状态，在用户不知情的情况下发起恶意请求。攻击者诱使用户在自己的站点上执行某些操作，从而触发用户已登录的Web应用发送恶意请求。</p> <p>CSRF攻击通常发生在用户已登录的状态下，攻击者通过构造恶意链接或其他方式，将恶意请求发送给受害者的浏览器。如果用户在未经意的情况下点击了这些链接，恶意请求会被发送到目标站点。</p> <p>防范CSRF攻击的方法包括使用CSRF令牌（Token）、检查Referer头、使用SameSite Cookie属性等。</p> <h3 id="csrf攻击怎么实施和防范"><a href="#csrf攻击怎么实施和防范" class="header-anchor">#</a> csrf攻击怎么实施和防范</h3> <p>CSRF（跨站请求伪造攻击）是一种攻击方式，攻击者通过利用用户的登录状态，诱使用户在不知情的情况下执行恶意请求。以下是CSRF攻击的实施和防范方法：</p> <h4 id="csrf攻击的实施"><a href="#csrf攻击的实施" class="header-anchor">#</a> CSRF攻击的实施：</h4> <ul><li>构造恶意请求：攻击者构造一个恶意的请求，包括目标站点的URL和可能需要的参数。</li> <li>诱使用户点击链接：攻击者将构造好的恶意请求链接发布在诱人的地方，例如社交媒体、论坛等。</li> <li>用户点击链接：受害者在登录目标站点后点击了恶意链接，导致恶意请求被发送到目标站点。</li></ul> <h4 id="csrf攻击的防范"><a href="#csrf攻击的防范" class="header-anchor">#</a> CSRF攻击的防范：</h4> <ul><li>使用CSRF令牌（Token）：将一个随机生成的令牌嵌入到请求中，令牌只在用户访问页面时生成，并存储在用户的会话中。在提交请求时，需要同时提交这个令牌，服务器会验证令牌的有效性。</li> <li>检查Referer头：服务器可以检查请求的Referer头，确保请求是从同一个站点发起的，但这不是绝对可靠，因为Referer头可以被伪造。</li> <li>使用SameSite Cookie属性：设置Cookie的SameSite属性，限制Cookie只能在相同站点的请求中发送，从而降低了CSRF攻击的风险。</li> <li>使用双重验证：对于敏感操作，要求用户进行双重验证，例如输入密码、短信验证码等，以确保用户意愿。</li></ul> <h3 id="注入攻击"><a href="#注入攻击" class="header-anchor">#</a> 注入攻击？</h3> <p>注入攻击是一种常见的网络安全威胁，它利用了应用程序未正确验证、过滤或转义用户输入数据的漏洞，从而使攻击者能够在应用程序中插入恶意代码或指令。注入攻击可能导致应用程序崩溃、敏感数据泄露、未授权访问等问题。</p> <h4 id="以下是一些常见的注入攻击类型"><a href="#以下是一些常见的注入攻击类型" class="header-anchor">#</a> 以下是一些常见的注入攻击类型：</h4> <ol><li>SQL注入：
攻击者通过在输入字段中插入恶意SQL代码，使应用程序错误地执行恶意数据库查询。这可能导致数据库泄露、数据修改、身份验证绕过等问题。</li> <li>XSS（跨站脚本攻击）：
被动攻击者可以注入恶意脚本到Web应用程序的输出中，当其他用户浏览页面时，恶意脚本会在用户浏览器中执行，从而实现窃取信息、会话劫持等。</li> <li>OS命令注入：
攻击者通过注入恶意操作系统命令，使应用程序错误地执行恶意操作系统命令。这可能导致服务器被入侵、系统信息泄露等。</li> <li>LDAP注入：
在应用程序未正确过滤用户输入时，攻击者可以通过在LDAP查询中插入恶意数据，从而绕过身份验证、访问受限数据等。</li> <li>XML注入：
攻击者通过在XML输入中插入恶意数据，可能导致XML解析器错误地处理数据，造成敏感信息泄露、拒绝服务等问题。</li></ol> <h4 id="防范注入攻击的方法包括"><a href="#防范注入攻击的方法包括" class="header-anchor">#</a> 防范注入攻击的方法包括：</h4> <ul><li>输入验证和过滤：确保对用户输入进行严格的验证和过滤，防止恶意代码插入。</li> <li>参数化查询：对于SQL查询等操作，使用参数化查询来防止SQL注入。</li> <li>输入转义：将用户输入进行适当的转义，防止恶意代码被执行。</li> <li>最小权限原则：将数据库、系统等权限控制在最小化范围内，限制攻击者可能造成的损害。</li></ul> <h3 id="如果路径中有类似-a-b-tostring-这种情况-你怎么考虑。-答-这是一种注入攻击的方式-然后说说自己对注入攻击的一些看法和防止手段"><a href="#如果路径中有类似-a-b-tostring-这种情况-你怎么考虑。-答-这是一种注入攻击的方式-然后说说自己对注入攻击的一些看法和防止手段" class="header-anchor">#</a> 如果路径中有类似 a.b.toString 这种情况，你怎么考虑。（答：这是一种注入攻击的方式，然后说说自己对注入攻击的一些看法和防止手段）</h3> <p>路径中出现类似 a.b.toString 这种情况可能会引发注入攻击的问题。这种情况下，如果没有对输入进行正确的验证和过滤，攻击者可能通过构造恶意输入来执行意外的操作。</p> <p>对于注入攻击，我认为：</p> <ul><li>安全意识和教育很重要：开发者应该充分了解注入攻击的原理和可能造成的后果，从而在编写代码时能够注意避免潜在的风险。</li> <li>输入验证和过滤：对于所有的用户输入，都需要进行严格的验证和过滤，确保输入数据的合法性和安全性。</li> <li>参数化查询：对于涉及数据库操作的情况，应该使用参数化查询，而不是拼接SQL字符串，以防止SQL注入。</li> <li>输入转义：对于用户输入中可能包含的特殊字符，应该进行适当的转义，以避免恶意代码的执行。</li> <li>最小权限原则：应该将权限控制在最小化的范围内，避免攻击者利用注入攻击获取不应该访问的信息。</li></ul> <h3 id="移动端适配"><a href="#移动端适配" class="header-anchor">#</a> 移动端适配</h3> <ol><li>响应式设计：
使用CSS媒体查询和弹性布局，根据不同屏幕尺寸和设备特性调整页面布局和样式。这可以让页面在不同设备上自动适应。</li> <li>Viewport设置：
使用Viewport meta标签来控制移动设备上的视口大小和缩放。设置width=device-width可以让页面按设备宽度进行渲染。</li> <li>流式布局：
使用百分比或其他相对单位来设置元素的宽度和高度，以确保页面在不同屏幕尺寸下流畅地适应。</li> <li>图片适配：
使用max-width: 100%确保图片在小屏幕上不会超出其父容器，同时可以使用不同分辨率的图片，根据设备加载不同大小的图片。</li> <li>媒体查询：
使用CSS媒体查询针对不同的屏幕尺寸、方向和特性应用不同的样式，以优化用户体验。</li> <li>移动优先设计：
首先为移动设备设计布局和样式，然后使用媒体查询逐步适配更大屏幕设备。</li> <li>Flexbox和Grid布局：
使用Flexbox和Grid布局可以更方便地实现复杂的布局，同时适应不同的屏幕尺寸。</li> <li>字体适配：
使用rem、em等相对单位来设置字体大小，以便在不同设备上保持一致的阅读体验。</li> <li>移动端特性考虑：
考虑到移动设备的触摸屏幕、手势操作等特性，适配交互元素和事件。</li> <li>测试和调试：
在多个移动设备和浏览器上测试你的页面，使用开发者工具进行调试，确保页面在各种情况下都能正常工作。</li></ol> <h2 id="手撕算法题"><a href="#手撕算法题" class="header-anchor">#</a> 手撕算法题</h2> <h3 id="斐波那契数列用两种以上方式实现"><a href="#斐波那契数列用两种以上方式实现" class="header-anchor">#</a> 斐波那契数列用两种以上方式实现</h3> <ol><li>递归</li></ol> <div class="language-ts line-numbers-mode"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">fibonacciRecursive</span><span class="token punctuation">(</span>n<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token function">fibonacciRecursive</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fibonacciRecursive</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> n <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// 想要计算的斐波那契数列项数</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Fibonacci(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>n<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">): </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token function">fibonacciRecursive</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><ol start="2"><li>迭代方式</li></ol> <div class="language-ts line-numbers-mode"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">fibonacciIterative</span><span class="token punctuation">(</span>n<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">let</span> prev <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> current <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> next <span class="token operator">=</span> prev <span class="token operator">+</span> current<span class="token punctuation">;</span>
    prev <span class="token operator">=</span> current<span class="token punctuation">;</span>
    current <span class="token operator">=</span> next<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> current<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> n <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// 想要计算的斐波那契数列项数</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Fibonacci(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>n<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">): </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token function">fibonacciIterative</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><h3 id="判断链表是否相交"><a href="#判断链表是否相交" class="header-anchor">#</a> 判断链表是否相交</h3> <p>下面是使用 TypeScript 实现判断两个链表是否相交的代码示例。假设链表节点结构为：</p> <div class="language-ts line-numbers-mode"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>
  val<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  next<span class="token operator">:</span> ListNode <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>val<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>然后，我们可以实现一个函数来判断两个链表是否相交：</p> <div class="language-ts line-numbers-mode"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">areLinkedListsIntersecting</span><span class="token punctuation">(</span>headA<span class="token operator">:</span> ListNode <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span> headB<span class="token operator">:</span> ListNode <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>headA <span class="token operator">||</span> <span class="token operator">!</span>headB<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 至少有一个链表为空，肯定不相交</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">let</span> pA<span class="token operator">:</span> ListNode <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">=</span> headA<span class="token punctuation">;</span>
  <span class="token keyword">let</span> pB<span class="token operator">:</span> ListNode <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">=</span> headB<span class="token punctuation">;</span>

  <span class="token comment">// 遍历链表，当其中一个链表到达末尾时，将其指向另一个链表的头部继续遍历</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>pA <span class="token operator">!==</span> pB<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    pA <span class="token operator">=</span> pA <span class="token operator">?</span> pA<span class="token punctuation">.</span>next <span class="token operator">:</span> headB<span class="token punctuation">;</span>
    pB <span class="token operator">=</span> pB <span class="token operator">?</span> pB<span class="token punctuation">.</span>next <span class="token operator">:</span> headA<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 如果相交，pA 和 pB 会在交点处相等</span>
  <span class="token keyword">return</span> pA <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>如果返回 true，则表示两个链表相交；如果返回 false，则表示两个链表不相交。</p> <h3 id="如果输入有环呢"><a href="#如果输入有环呢" class="header-anchor">#</a> 如果输入有环呢</h3> <div class="language-ts line-numbers-mode"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>head<span class="token operator">:</span> ListNode <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">let</span> slow<span class="token operator">:</span> ListNode <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">=</span> head<span class="token punctuation">;</span>
  <span class="token keyword">let</span> fast<span class="token operator">:</span> ListNode <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">=</span> head<span class="token punctuation">;</span>

  <span class="token keyword">while</span> <span class="token punctuation">(</span>fast <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    slow <span class="token operator">=</span> slow<span class="token operator">!</span><span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>slow <span class="token operator">===</span> fast<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 存在环</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">areLinkedListsIntersectingWithCycle</span><span class="token punctuation">(</span>headA<span class="token operator">:</span> ListNode <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span> headB<span class="token operator">:</span> ListNode <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>headA <span class="token operator">||</span> <span class="token operator">!</span>headB<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 至少有一个链表为空，肯定不相交</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 判断链表是否存在环</span>
  <span class="token keyword">const</span> hasCycleA <span class="token operator">=</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>headA<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> hasCycleB <span class="token operator">=</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>headB<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>hasCycleA <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>hasCycleB <span class="token operator">||</span> <span class="token operator">!</span>hasCycleA <span class="token operator">&amp;&amp;</span> hasCycleB<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 一个有环一个无环，肯定不相交</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">let</span> pA<span class="token operator">:</span> ListNode <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">=</span> headA<span class="token punctuation">;</span>
  <span class="token keyword">let</span> pB<span class="token operator">:</span> ListNode <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">=</span> headB<span class="token punctuation">;</span>

  <span class="token comment">// 遍历链表，当其中一个链表到达末尾时，将其指向另一个链表的头部继续遍历</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>pA <span class="token operator">!==</span> pB<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    pA <span class="token operator">=</span> pA <span class="token operator">?</span> pA<span class="token punctuation">.</span>next <span class="token operator">:</span> headB<span class="token punctuation">;</span>
    pB <span class="token operator">=</span> pB <span class="token operator">?</span> pB<span class="token punctuation">.</span>next <span class="token operator">:</span> headA<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>pA <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> pB <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 两个链表没有交点</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 如果相交，pA 和 pB 会在交点处相等</span>
  <span class="token keyword">return</span> pA <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br></div></div><h3 id="两个栈实现队列"><a href="#两个栈实现队列" class="header-anchor">#</a> 两个栈实现队列</h3> <p>使用两个栈来实现队列的操作，可以通过在栈之间转移元素来模拟队列的先进先出（FIFO）特性。具体实现如下：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">QueueWithTwoStacks</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>stack1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 用于入队操作</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>stack2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 用于出队操作</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 入队</span>
  <span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>stack1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 出队</span>
  <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果 stack2 不为空，直接从 stack2 出队</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>stack2<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 如果 stack2 为空，将 stack1 的元素逐个转移到 stack2，实现元素顺序的倒置</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>stack1<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>stack2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>stack1<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 从 stack2 出队</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>stack2<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p>这里，enqueue 操作将元素推入 stack1，而 dequeue 操作则从 stack2 出队，如果 stack2 不为空则直接出队，否则先将 stack1 的元素转移到 stack2，然后再从 stack2 出队。</p> <p>这种方式模拟了队列的先进先出特性，使用两个栈实现了队列的基本操作。需要注意的是，由于涉及元素的移动操作，可能会影响性能，特别是在大量操作时。</p> <h3 id="两个队列模拟栈"><a href="#两个队列模拟栈" class="header-anchor">#</a> 两个队列模拟栈</h3> <div class="language-ts line-numbers-mode"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">MyStack</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> queue1<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">private</span> queue2<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>queue1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>queue2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">push</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>queue2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>queue1<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>queue2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>queue1<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">!</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>queue1<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>queue2<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>queue2<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>queue1<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 交换队列</span>
  <span class="token punctuation">}</span>

  <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>queue1<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 栈为空，返回特定值</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>queue1<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">!</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>queue1<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 栈为空，返回特定值</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>queue1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>queue1<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 2</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 2</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 false</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br></div></div><p>在上述代码中，我们使用两个队列 queue1 和 queue2 来模拟栈的行为。在 push 操作中，我们将新元素先放入 queue2，然后将 queue1 中的元素依次出队并放入 queue2，最后交换 queue1 和 queue2。这样就实现了栈的先进后出特性。</p> <p>需要注意的是，根据具体需求，可能需要对一些操作进行错误处理。在示例中，pop 和 top 操作在栈为空时返回 -1，你可以根据实际情况进行调整。</p> <h3 id="实现一个数组的排序-用三种方法"><a href="#实现一个数组的排序-用三种方法" class="header-anchor">#</a> 实现一个数组的排序，用三种方法</h3> <ul><li>冒泡排序（Bubble Sort）：重复地比较相邻的元素并交换，将最大（或最小）元素“冒泡”到数组末尾（或开头）。时间复杂度为 O(n^2)，适用于小数据集。</li> <li>选择排序（Selection Sort）：在未排序部分中选择最小（或最大）元素并交换到已排序部分。时间复杂度为 O(n^2)，适用于小数据集。</li> <li>插入排序（Insertion Sort）：逐个将元素插入已排序的数组部分中，构建有序数组。时间复杂度为 O(n^2)，对于部分有序的数据集效果较好。</li> <li>快速排序（Quick Sort）：基于分治思想，选择一个基准元素，将数组分成两部分并递归地对每部分进行排序。平均时间复杂度为 O(n log n)，在大多数情况下表现优秀。</li> <li>归并排序（Merge Sort）：将数组分成两半，递归地对每半进行排序，然后将两个有序的子数组合并为一个有序数组。时间复杂度为 O(n log n)，稳定且适用于大数据集。</li> <li>堆排序（Heap Sort）：利用堆数据结构，构建最大堆或最小堆，将堆顶元素与末尾元素交换并重建堆。时间复杂度为 O(n log n)，适用于大数据集。</li></ul> <h3 id="快速排序"><a href="#快速排序" class="header-anchor">#</a> 快速排序</h3> <p>快速排序（Quick Sort）是一种常用的高效的排序算法，其原理基于分治（Divide and Conquer）策略。它的核心思想是通过选取一个基准元素，将数组划分为两个子数组，一个子数组中的所有元素小于基准，另一个子数组中的所有元素大于基准，然后递归地对子数组进行排序。</p> <p>快速排序过程如下：</p> <ul><li>选择基准元素：从数组中选择一个元素作为基准（通常选择第一个元素）。</li> <li>分区：将数组中的其他元素与基准元素进行比较，将小于基准的元素放在左侧，大于基准的元素放在右侧。</li> <li>递归排序：对左侧和右侧的子数组递归执行快速排序。</li> <li>合并：将左侧子数组、基准元素和右侧子数组合并在一起，得到排序后的数组。</li></ul> <div class="language-ts line-numbers-mode"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> arr<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">const</span> pivot <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> left <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> right <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      left<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      right<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token function">quickSort</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> pivot<span class="token punctuation">,</span> <span class="token operator">...</span><span class="token function">quickSort</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> unsortedArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> sortedArray <span class="token operator">=</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>unsortedArray<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sortedArray<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 [1, 2, 3, 4, 7, 9]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><h3 id="归并排序"><a href="#归并排序" class="header-anchor">#</a> 归并排序</h3> <h3 id="逆序数查找"><a href="#逆序数查找" class="header-anchor">#</a> 逆序数查找</h3> <h3 id="将对象数组转换为树形结构。"><a href="#将对象数组转换为树形结构。" class="header-anchor">#</a> 将对象数组转换为树形结构。</h3> <div class="language-ts line-numbers-mode"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{</span>
  id<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  children<span class="token operator">?</span><span class="token operator">:</span> TreeNode<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">arrayToTree</span><span class="token punctuation">(</span>arr<span class="token operator">:</span> TreeNode<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> TreeNode<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> map<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> TreeNode <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> tree<span class="token operator">:</span> TreeNode<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

  <span class="token comment">// 构建节点映射</span>
  arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>node <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    map<span class="token punctuation">[</span>node<span class="token punctuation">.</span>id<span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token punctuation">;</span>
    node<span class="token punctuation">.</span>children <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 构建树形结构</span>
  arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>node <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>id <span class="token keyword">in</span> map<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> parent <span class="token operator">=</span> map<span class="token punctuation">[</span>node<span class="token punctuation">.</span>id<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>id <span class="token operator">!==</span> node<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        parent<span class="token punctuation">.</span>name <span class="token operator">=</span> node<span class="token punctuation">.</span>name<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

      <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>id <span class="token operator">!==</span> node<span class="token punctuation">.</span>parentId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>map<span class="token punctuation">[</span>node<span class="token punctuation">.</span>parentId<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          map<span class="token punctuation">[</span>node<span class="token punctuation">.</span>parentId<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> id<span class="token operator">:</span> node<span class="token punctuation">.</span>parentId<span class="token punctuation">,</span> name<span class="token operator">:</span> <span class="token string">''</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
          map<span class="token punctuation">[</span>node<span class="token punctuation">.</span>parentId<span class="token punctuation">]</span><span class="token punctuation">.</span>children <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        map<span class="token punctuation">[</span>node<span class="token punctuation">.</span>parentId<span class="token punctuation">]</span><span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        tree<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> tree<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> flatData <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token string">'1'</span><span class="token punctuation">,</span> name<span class="token operator">:</span> <span class="token string">'Node 1'</span><span class="token punctuation">,</span> parentId<span class="token operator">:</span> <span class="token string">''</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token string">'2'</span><span class="token punctuation">,</span> name<span class="token operator">:</span> <span class="token string">'Node 2'</span><span class="token punctuation">,</span> parentId<span class="token operator">:</span> <span class="token string">'1'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token string">'3'</span><span class="token punctuation">,</span> name<span class="token operator">:</span> <span class="token string">'Node 3'</span><span class="token punctuation">,</span> parentId<span class="token operator">:</span> <span class="token string">'1'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token string">'4'</span><span class="token punctuation">,</span> name<span class="token operator">:</span> <span class="token string">'Node 4'</span><span class="token punctuation">,</span> parentId<span class="token operator">:</span> <span class="token string">'2'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token string">'5'</span><span class="token punctuation">,</span> name<span class="token operator">:</span> <span class="token string">'Node 5'</span><span class="token punctuation">,</span> parentId<span class="token operator">:</span> <span class="token string">'2'</span> <span class="token punctuation">}</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> treeData <span class="token operator">=</span> <span class="token function">arrayToTree</span><span class="token punctuation">(</span>flatData<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>treeData<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出转换后的树形结构</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br></div></div><h3 id="手撕函数柯里化"><a href="#手撕函数柯里化" class="header-anchor">#</a> 手撕函数柯里化</h3> <p>函数柯里化（Currying）是一种将多参数函数转化为一系列单参数函数的技术。下面是使用 TypeScript 实现函数柯里化的示例代码：</p> <div class="language-ts line-numbers-mode"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">curry</span><span class="token punctuation">(</span>fn<span class="token operator">:</span> <span class="token builtin">Function</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">curried</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>args<span class="token punctuation">.</span>length <span class="token operator">&gt;=</span> fn<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token operator">...</span>moreArgs<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">curried</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>moreArgs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span>a<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> c<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> curriedAdd <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span>add<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> addFive <span class="token operator">=</span> <span class="token function">curriedAdd</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> addTen <span class="token operator">=</span> <span class="token function">addFive</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">addTen</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 30</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>在上面的示例中，curry 函数接受一个函数 fn 作为参数，然后返回一个新的函数 curried。当调用 curried 函数时，它会根据传入的参数数量判断是否执行原始函数 fn，如果参数数量足够，则执行原始函数，否则返回一个接受更多参数的新的 curried 函数。</p> <p>我们使用 curry 函数将三参数的 add 函数转换为可以逐步传入参数的柯里化版本。首先，我们通过 curriedAdd(5) 创建一个接受两个参数的新函数 addFive，然后通过 addFive(10) 创建一个接受一个参数的新函数 addTen，最终通过调用 addTen(15) 完成函数柯里化，输出结果为 30。</p> <h2 id="实操题"><a href="#实操题" class="header-anchor">#</a> 实操题</h2> <h3 id="js闭包-写一个计数器函数-每次调用打印"><a href="#js闭包-写一个计数器函数-每次调用打印" class="header-anchor">#</a> js闭包？写一个计数器函数，每次调用打印++</h3> <div class="language-ts line-numbers-mode"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">createCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    count<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> counter <span class="token operator">=</span> <span class="token function">createCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 1</span>
<span class="token function">counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 2</span>
<span class="token function">counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 3</span>
<span class="token comment">// ...</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>在上述示例中，createCounter 函数返回一个内部函数，这个内部函数可以访问外部作用域中的 count 变量。每次调用 counter 函数，count 的值会递增，并且通过闭包的机制，保持了对外部作用域的引用，使得计数器值得以保留。</p> <p>这样，每次调用 counter 函数时，都会在控制台打印递增的计数值。这个例子展示了闭包如何在函数内部保留外部作用域的状态，并在函数调用之间保持持久性。</p> <h3 id="写一下防抖节流"><a href="#写一下防抖节流" class="header-anchor">#</a> 写一下防抖节流？</h3> <p>防抖（Debounce）:</p> <p>防抖函数会等待一段时间，在这段时间内如果事件再次触发，则计时会被重置，函数的执行会被推迟。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">func<span class="token punctuation">,</span> delay</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> timer<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 使用防抖函数</span>
<span class="token keyword">const</span> debouncedFunction <span class="token operator">=</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Debounced function is executed.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 触发事件时调用防抖函数</span>
<span class="token function">debouncedFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>节流（Throttle）:</p> <p>节流函数会限制函数在一定时间内的执行频率，保证函数在一定时间间隔内执行。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token parameter">func<span class="token punctuation">,</span> delay</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> lastTime <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> currentTime <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>currentTime <span class="token operator">-</span> lastTime <span class="token operator">&gt;=</span> delay<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
      lastTime <span class="token operator">=</span> currentTime<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 使用节流函数</span>
<span class="token keyword">const</span> throttledFunction <span class="token operator">=</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Throttled function is executed.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 触发事件时调用节流函数</span>
<span class="token function">throttledFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>在这两个示例中，func 是要进行防抖或节流处理的函数，delay 是设置的等待时间或时间间隔。你可以根据需要调整这些函数的实现和使用方式。记住，防抖和节流都是为了优化频繁触发的事件，具体使用哪种方法取决于你的需求。</p> <h3 id="设计一个函数getnewurl-参数是一个url和query-返回一个url和参数拼接之后的新url-类似于http请求中get请求的参数放在url后面-在做之前面试官说这并不是考算法-而是考察函数设计的鲁棒性-需要多考虑边界情况。"><a href="#设计一个函数getnewurl-参数是一个url和query-返回一个url和参数拼接之后的新url-类似于http请求中get请求的参数放在url后面-在做之前面试官说这并不是考算法-而是考察函数设计的鲁棒性-需要多考虑边界情况。" class="header-anchor">#</a> 设计一个函数getNewUrl，参数是一个url和query，返回一个url和参数拼接之后的新url（类似于http请求中get请求的参数放在url后面），在做之前面试官说这并不是考算法，而是考察函数设计的鲁棒性，需要多考虑边界情况。</h3> <p>考虑函数设计的鲁棒性，我们需要考虑各种可能的情况，如参数是否为空、url是否已经包含查询参数、参数是否包含特殊字符等。下面是一个使用 TypeScript 实现的 getNewUrl 函数，考虑了一些边界情况：</p> <div class="language-ts line-numbers-mode"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">getNewUrl</span><span class="token punctuation">(</span>url<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> query<span class="token operator">:</span> Record<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>url<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'URL cannot be empty.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">let</span> newUrl <span class="token operator">=</span> url<span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>query<span class="token punctuation">)</span><span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    newUrl <span class="token operator">+=</span> url<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span><span class="token string">'?'</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">'&amp;'</span> <span class="token operator">:</span> <span class="token string">'?'</span><span class="token punctuation">;</span>

    <span class="token keyword">const</span> queryParams <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span>query<span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">[</span>key<span class="token punctuation">,</span> value<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token function">encodeURIComponent</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token function">encodeURIComponent</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">'&amp;'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    newUrl <span class="token operator">+=</span> queryParams<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> newUrl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> baseUrl <span class="token operator">=</span> <span class="token string">'https://example.com'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> queryParams <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">'John Doe'</span><span class="token punctuation">,</span>
  age<span class="token operator">:</span> <span class="token string">'30'</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> newUrl <span class="token operator">=</span> <span class="token function">getNewUrl</span><span class="token punctuation">(</span>baseUrl<span class="token punctuation">,</span> queryParams<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newUrl<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 https://example.com?name=John%20Doe&amp;age=30</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><p>在这个示例中，getNewUrl 函数接受一个 URL 和一个查询参数对象 query 作为参数，然后根据不同情况构建新的 URL 并返回。函数会检查 URL 是否为空，如果查询参数非空，则会根据是否已经存在查询参数来添加 '?' 或 '&amp;'，然后将查询参数编码后拼接到 URL 中。</p> <h3 id="手写-实现图片加载失败后-显示另一个地址内容"><a href="#手写-实现图片加载失败后-显示另一个地址内容" class="header-anchor">#</a> 手写，实现图片加载失败后，显示另一个地址内容</h3> <p>当图片加载失败时，我们可以通过添加一个 onerror 事件处理程序来捕捉加载失败的情况，并在处理程序中替换为另一个地址的内容。下面是一个示例，使用 TypeScript 实现了这个功能：</p> <div class="language-ts line-numbers-mode"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">handleImageError</span><span class="token punctuation">(</span>imageElement<span class="token operator">:</span> HTMLImageElement<span class="token punctuation">,</span> fallbackUrl<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  imageElement<span class="token punctuation">.</span><span class="token function-variable function">onerror</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    imageElement<span class="token punctuation">.</span>src <span class="token operator">=</span> fallbackUrl<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> imageUrl <span class="token operator">=</span> <span class="token string">'https://example.com/image.jpg'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> fallbackImageUrl <span class="token operator">=</span> <span class="token string">'https://example.com/fallback-image.jpg'</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> image <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'img'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> HTMLImageElement<span class="token punctuation">;</span>
image<span class="token punctuation">.</span>src <span class="token operator">=</span> imageUrl<span class="token punctuation">;</span>
document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>image<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">handleImageError</span><span class="token punctuation">(</span>image<span class="token punctuation">,</span> fallbackImageUrl<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h3 id="手写instancof方法"><a href="#手写instancof方法" class="header-anchor">#</a> 手写instancof方法</h3> <p>instanceof 运算符用于检查一个对象是否属于某个类或构造函数的实例。下面是使用 TypeScript 手动实现 instanceof 方法的示例：</p> <div class="language-ts line-numbers-mode"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">customInstanceOf</span><span class="token punctuation">(</span>obj<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span> constructor<span class="token operator">:</span> <span class="token builtin">Function</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> prototype <span class="token operator">=</span> constructor<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>

  <span class="token keyword">while</span> <span class="token punctuation">(</span>obj <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">===</span> prototype<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    obj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">customInstanceOf</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> Person<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 true</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">customInstanceOf</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> Object<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 true</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">customInstanceOf</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token builtin">Array</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 输出 false</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>在这个示例中，customInstanceOf 函数接受一个对象 obj 和一个构造函数 constructor 作为参数，然后通过遍历对象的原型链来判断是否为给定构造函数的实例。如果找到匹配的构造函数的原型，则返回 true，否则返回 false。</p> <h3 id="手写promise-all"><a href="#手写promise-all" class="header-anchor">#</a> 手写promise.all</h3> <p>Promise.all 方法用于并行执行多个 Promise，当所有的 Promise 都成功完成时，返回一个包含所有 Promise 结果的新 Promise；如果任意一个 Promise 失败，返回的 Promise 会被拒绝，并将第一个拒绝的 Promise 的原因作为拒绝的原因。下面是使用 TypeScript 手动实现 Promise.all 的示例：</p> <div class="language-ts line-numbers-mode"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">customPromiseAll</span><span class="token punctuation">(</span>promises<span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">&gt;</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token builtin">Promise</span></span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>promises<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">const</span> results<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> resolvedCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    promises<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>promise<span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      promise
        <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>result <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
          results<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> result<span class="token punctuation">;</span>
          resolvedCount<span class="token operator">++</span><span class="token punctuation">;</span>

          <span class="token keyword">if</span> <span class="token punctuation">(</span>resolvedCount <span class="token operator">===</span> promises<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">resolve</span><span class="token punctuation">(</span>results<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span>reject<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> promise1 <span class="token operator">=</span> <span class="token builtin">Promise</span><span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> promise2 <span class="token operator">=</span> <span class="token builtin">Promise</span><span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> promise3 <span class="token operator">=</span> <span class="token builtin">Promise</span><span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">customPromiseAll</span><span class="token punctuation">(</span><span class="token punctuation">[</span>promise1<span class="token punctuation">,</span> promise2<span class="token punctuation">,</span> promise3<span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>results <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>results<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 [1, 2, 3]</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span>error <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br></div></div><h3 id="手写一个-promise-的并发控制"><a href="#手写一个-promise-的并发控制" class="header-anchor">#</a> 手写一个 Promise 的并发控制</h3> <div class="language-ts line-numbers-mode"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">concurrentPromise</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>promises<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> concurrency<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> results<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> currentIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token builtin">Promise</span></span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">function</span> <span class="token function">executeNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>currentIndex <span class="token operator">&gt;=</span> promises<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span>results<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

      <span class="token keyword">const</span> currentPromise <span class="token operator">=</span> promises<span class="token punctuation">[</span>currentIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>
      currentIndex<span class="token operator">++</span><span class="token punctuation">;</span>

      <span class="token function">currentPromise</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>result <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
          results<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span>error <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
          <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">finally</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
          <span class="token function">executeNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 初始执行</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> concurrency<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">executeNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 模拟异步函数</span>
<span class="token keyword">function</span> <span class="token function">asyncFunction</span><span class="token punctuation">(</span>id<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token builtin">Promise</span></span><span class="token punctuation">(</span>resolve <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Task </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>id<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> is completed</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">resolve</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> asyncFunctions <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">asyncFunction</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">asyncFunction</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">asyncFunction</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">asyncFunction</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">asyncFunction</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token function">concurrentPromise</span><span class="token punctuation">(</span>asyncFunctions<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>results <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'All tasks are completed:'</span><span class="token punctuation">,</span> results<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span>error <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'An error occurred:'</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br></div></div><h3 id="promise版本的settimeout"><a href="#promise版本的settimeout" class="header-anchor">#</a> promise版本的settimeout</h3> <div class="language-ts line-numbers-mode"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">delay</span><span class="token punctuation">(</span>ms<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token builtin">Promise</span></span><span class="token punctuation">(</span>resolve <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> ms<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Start'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'After 2 seconds'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'End'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>在上述示例中，delay 函数接受一个毫秒数 ms 作为参数，并返回一个 Promise。在指定的时间过去后，Promise 会被解决（resolved），从而触发 .then() 方法中的回调函数执行。</p> <p>注意，delay 函数并没有阻塞线程，而是利用 Promise 的异步性质来实现延迟执行。因此，在控制台输出中，你会看到 'End' 会先于 'After 2 seconds' 打印出来。</p> <h3 id="实现一个函数fn-start-success-fail-可以进行catch-then的链式调用"><a href="#实现一个函数fn-start-success-fail-可以进行catch-then的链式调用" class="header-anchor">#</a> 实现一个函数fn({start,success,fail})可以进行catch/then的链式调用</h3> <p>你可以实现一个函数 fn，使其接受一个对象参数，其中包含 start、success 和 fail 三个函数。然后，在 start 函数中触发异步操作，在异步操作成功时调用 success 函数，在异步操作失败时调用 fail 函数。这样，你可以在调用时链式使用 .then() 和 .catch() 来处理成功和失败的情况。下面是一个 TypeScript 实现的示例：</p> <div class="language-ts line-numbers-mode"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">FnParams</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">start</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
  <span class="token function-variable function">success</span><span class="token operator">:</span> <span class="token punctuation">(</span>data<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
  <span class="token function-variable function">fail</span><span class="token operator">:</span> <span class="token punctuation">(</span>error<span class="token operator">:</span> Error<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">{</span> start<span class="token punctuation">,</span> success<span class="token punctuation">,</span> fail <span class="token punctuation">}</span><span class="token operator">:</span> FnParams<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
  <span class="token comment">// 模拟异步操作</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> randomValue <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>randomValue <span class="token operator">&gt;</span> <span class="token number">0.5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">success</span><span class="token punctuation">(</span>randomValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token function">fail</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'Operation failed'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function-variable function">start</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Starting...'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function-variable function">success</span><span class="token operator">:</span> data <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Success:'</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function-variable function">fail</span><span class="token operator">:</span> error <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'Failed:'</span><span class="token punctuation">,</span> error<span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><h3 id="手写-双向数据绑定"><a href="#手写-双向数据绑定" class="header-anchor">#</a> 手写：双向数据绑定</h3> <h3 id="手写一个vue3的倒计时组件"><a href="#手写一个vue3的倒计时组件" class="header-anchor">#</a> 手写一个vue3的倒计时组件</h3> <div class="language-vue line-numbers-mode"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>{{ remainingTime }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">setup</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">import</span> <span class="token punctuation">{</span> ref<span class="token punctuation">,</span> watchEffect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> targetTime <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span>Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">60000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 一分钟后的时间戳</span>
<span class="token keyword">const</span> currentTime <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span>Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> remainingTime <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span>targetTime<span class="token punctuation">.</span>value <span class="token operator">-</span> currentTime<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> intervalId <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    currentTime<span class="token punctuation">.</span>value <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    remainingTime<span class="token punctuation">.</span>value <span class="token operator">=</span> targetTime<span class="token punctuation">.</span>value <span class="token operator">-</span> currentTime<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    
    <span class="token keyword">if</span> <span class="token punctuation">(</span>remainingTime<span class="token punctuation">.</span>value <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">clearInterval</span><span class="token punctuation">(</span>intervalId<span class="token punctuation">)</span><span class="token punctuation">;</span>
      remainingTime<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><h3 id="css编程题-一行文字展示超出部分用省略号替代-三行文字展示超出部分用省略号替代"><a href="#css编程题-一行文字展示超出部分用省略号替代-三行文字展示超出部分用省略号替代" class="header-anchor">#</a> css编程题:一行文字展示超出部分用省略号替代；三行文字展示超出部分用省略号替代</h3> <h4 id="一行文字展示-超出部分用省略号替代"><a href="#一行文字展示-超出部分用省略号替代" class="header-anchor">#</a> 一行文字展示，超出部分用省略号替代：</h4> <div class="language-css line-numbers-mode"><pre class="language-css"><code><span class="token selector">.ellipsis-one-line</span> <span class="token punctuation">{</span>
      <span class="token property">white-space</span><span class="token punctuation">:</span> nowrap<span class="token punctuation">;</span>
      <span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span>
      <span class="token property">text-overflow</span><span class="token punctuation">:</span> ellipsis<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h4 id="三行文字展示-超出部分用省略号替代"><a href="#三行文字展示-超出部分用省略号替代" class="header-anchor">#</a> 三行文字展示，超出部分用省略号替代：</h4> <div class="language-css line-numbers-mode"><pre class="language-css"><code><span class="token selector">.ellipsis-three-lines</span> <span class="token punctuation">{</span>
      <span class="token property">display</span><span class="token punctuation">:</span> -webkit-box<span class="token punctuation">;</span>
      <span class="token property">-webkit-box-orient</span><span class="token punctuation">:</span> vertical<span class="token punctuation">;</span>
      <span class="token property">-webkit-line-clamp</span><span class="token punctuation">:</span> 3<span class="token punctuation">;</span>
      <span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span>
      <span class="token property">text-overflow</span><span class="token punctuation">:</span> ellipsis<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="js编程题-手写apply函数"><a href="#js编程题-手写apply函数" class="header-anchor">#</a> js编程题:手写apply函数</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">myApply</span><span class="token punctuation">(</span><span class="token parameter">func<span class="token punctuation">,</span> context<span class="token punctuation">,</span> args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> func <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'First argument must be a function'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  context <span class="token operator">=</span> context <span class="token operator">||</span> window<span class="token punctuation">;</span>
  <span class="token keyword">const</span> uniqueKey <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 用一个独特的键来避免属性名冲突</span>

  context<span class="token punctuation">[</span>uniqueKey<span class="token punctuation">]</span> <span class="token operator">=</span> func<span class="token punctuation">;</span>
  <span class="token keyword">const</span> result <span class="token operator">=</span> context<span class="token punctuation">[</span>uniqueKey<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">delete</span> context<span class="token punctuation">[</span>uniqueKey<span class="token punctuation">]</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 示例使用</span>
<span class="token keyword">function</span> <span class="token function">greeting</span><span class="token punctuation">(</span><span class="token parameter">message</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">' says: '</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'Alice'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">myApply</span><span class="token punctuation">(</span>greeting<span class="token punctuation">,</span> person<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'Hello, world!'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Output: Alice says: Hello, world!</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><div class="language-ts line-numbers-mode"><pre class="language-ts"><code><span class="token comment">// ts</span>
<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">myApply</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>
  <span class="token function-variable function">fn</span><span class="token operator">:</span> <span class="token punctuation">(</span>arg1<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> arg2<span class="token operator">:</span> <span class="token constant">U</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">any</span><span class="token punctuation">,</span>
  context<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span>
  args<span class="token operator">:</span> <span class="token constant">U</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">any</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">greet</span><span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> greeting<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>greeting<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">!</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">myApply</span><span class="token punctuation">(</span>greet<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'Alice'</span><span class="token punctuation">,</span> <span class="token string">'Hello'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Output: &quot;Hello, Alice!&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h3 id="用reduce实现map"><a href="#用reduce实现map" class="header-anchor">#</a> 用reduce实现map</h3> <div class="language-ts line-numbers-mode"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">myMap</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>array<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function-variable function">callback</span><span class="token operator">:</span> <span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> index<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> array<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">U</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">U</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> array<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> currentValue<span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">callback</span><span class="token punctuation">(</span>currentValue<span class="token punctuation">,</span> index<span class="token punctuation">,</span> array<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">as</span> <span class="token constant">U</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> squared <span class="token operator">=</span> <span class="token function">myMap</span><span class="token punctuation">(</span>numbers<span class="token punctuation">,</span> <span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> num <span class="token operator">*</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>squared<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Output: [1, 4, 9, 16, 25]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="css实现三角形"><a href="#css实现三角形" class="header-anchor">#</a> css实现三角形</h3> <p>您可以使用纯 CSS 来创建三角形，通常是通过利用元素的边框和透明部分来实现的。下面是两种常见的方法来创建 CSS 三角形：</p> <h4 id="利用边框"><a href="#利用边框" class="header-anchor">#</a> 利用边框：</h4> <p>使用这种方法，您可以设置一个元素的某个边框为透明，从而实现三角形效果。</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code><span class="token selector">.triangle</span> <span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">border-left</span><span class="token punctuation">:</span> 50px solid transparent<span class="token punctuation">;</span>
  <span class="token property">border-right</span><span class="token punctuation">:</span> 50px solid transparent<span class="token punctuation">;</span>
  <span class="token property">border-bottom</span><span class="token punctuation">:</span> 100px solid red<span class="token punctuation">;</span> <span class="token comment">/* 控制三角形的颜色和高度 */</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>在这个示例中，通过设置透明的左右边框和一个有颜色的底部边框，您可以创建一个红色的三角形。</p> <h4 id="利用伪元素"><a href="#利用伪元素" class="header-anchor">#</a> 利用伪元素：</h4> <p>另一种方法是使用伪元素 ::before 或 ::after 来创建三角形。</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code><span class="token selector">.triangle</span> <span class="token punctuation">{</span>
  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span> <span class="token comment">/* 控制三角形的颜色 */</span>
<span class="token punctuation">}</span>

<span class="token selector">.triangle::before</span> <span class="token punctuation">{</span>
  <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">;</span>
  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
  <span class="token property">top</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">left</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">border-width</span><span class="token punctuation">:</span> 0 50px 100px 50px<span class="token punctuation">;</span> <span class="token comment">/* 控制三角形的大小和形状 */</span>
  <span class="token property">border-style</span><span class="token punctuation">:</span> solid<span class="token punctuation">;</span>
  <span class="token property">border-color</span><span class="token punctuation">:</span> transparent transparent blue transparent<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>在这个示例中，通过为元素添加一个伪元素并设置其边框属性，您可以在原始元素上方创建一个蓝色的三角形。</p> <h4 id="原理"><a href="#原理" class="header-anchor">#</a> 原理：</h4> <p>利用边框来创建三角形的原理是利用了 CSS 边框的绘制特性，结合透明边框和有颜色的边框来形成三角形的效果。这种方法之所以能够实现三角形，是因为 CSS 边框的绘制方式允许我们控制边框的宽度、样式和颜色，从而实现不同的形状。</p> <p>具体来说，利用边框创建三角形的原理如下：</p> <ul><li>设置元素的宽度和高度为 0：通过将元素的宽度和高度设置为 0，使得元素本身不显示任何内容。</li> <li>设置透明边框：通过设置左边框和右边框为透明，使得元素的两侧不显示边框。</li> <li>设置底部边框的宽度和颜色：通过设置底部边框的宽度和颜色，形成三角形的底边。</li></ul> <p>由于元素的宽度和高度被设置为 0，实际上只有底部的边框在可见区域内。透明的左右边框则允许底边的两个角呈现出斜边的效果，从而形成了一个三角形。</p> <p>这种方法非常巧妙地利用了 CSS 边框的绘制机制，使得我们可以轻松地创建不同大小和颜色的三角形，而无需额外的 HTML 结构或复杂的样式。</p> <h2 id="反问"><a href="#反问" class="header-anchor">#</a> 反问</h2> <h3 id="什么部门"><a href="#什么部门" class="header-anchor">#</a> 什么部门</h3> <h3 id="主要技术栈"><a href="#主要技术栈" class="header-anchor">#</a> 主要技术栈</h3> <h3 id="web端和小程序端的占比"><a href="#web端和小程序端的占比" class="header-anchor">#</a> web端和小程序端的占比</h3></head></html></div></section> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新: </span> <span class="time">2023/08/23 16:43:44</span></div></footer> <!----> <div class="article-list" data-v-6845f1ce><div class="article-title" data-v-6845f1ce><a href="/timeline/" class="iconfont icon-shizhong" data-v-6845f1ce>最近更新</a></div> <div class="article-wrapper" data-v-6845f1ce><dl data-v-6845f1ce><dd data-v-6845f1ce>01</dd> <dt data-v-6845f1ce><a href="/blogs/前端/基础/跨域的几种常见解决方案.html" data-v-6845f1ce><div data-v-6845f1ce>跨域的几种常见解决方案</div></a> <span data-v-6845f1ce>04-03</span></dt></dl><dl data-v-6845f1ce><dd data-v-6845f1ce>02</dd> <dt data-v-6845f1ce><a href="/blogs/前端/react/react教程.html" data-v-6845f1ce><div data-v-6845f1ce>react教程</div></a> <span data-v-6845f1ce>03-01</span></dt></dl><dl data-v-6845f1ce><dd data-v-6845f1ce>03</dd> <dt data-v-6845f1ce><a href="/blogs/前端/技巧/前端抓包神器whistle.html" data-v-6845f1ce><div data-v-6845f1ce>前端抓包神器whistle</div></a> <span data-v-6845f1ce>09-01</span></dt></dl></div> <div data-v-6845f1ce><a href="/timeline/" class="article-more" data-v-6845f1ce>更多&gt;</a></div></div> <div class="comments-wrapper"><!----></div> <ul class="side-bar sub-sidebar-wrapper" style="width:12rem;" data-v-5ecb72e8><li class="level-2" data-v-5ecb72e8><a href="/others/summary-answer.html#项目-其他主观" class="sidebar-link reco-side-项目-其他主观" data-v-5ecb72e8>项目&amp;其他主观</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#工作中遇到的最难的问题是什么-如何解决的" class="sidebar-link reco-side-工作中遇到的最难的问题是什么-如何解决的" data-v-5ecb72e8>工作中遇到的最难的问题是什么？如何解决的？</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#项目中遇到的难点以及收获" class="sidebar-link reco-side-项目中遇到的难点以及收获" data-v-5ecb72e8>项目中遇到的难点以及收获？</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#遇到过长时间没解决的问题吗" class="sidebar-link reco-side-遇到过长时间没解决的问题吗" data-v-5ecb72e8>遇到过长时间没解决的问题吗？</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#如果你的同事出现工作上情绪的问题-你如何调节" class="sidebar-link reco-side-如果你的同事出现工作上情绪的问题-你如何调节" data-v-5ecb72e8>如果你的同事出现工作上情绪的问题，你如何调节？</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#你之前的项目是怎么做线上发布的" class="sidebar-link reco-side-你之前的项目是怎么做线上发布的" data-v-5ecb72e8>你之前的项目是怎么做线上发布的？</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#有尝试不用-vuecli-搭建过项目吗" class="sidebar-link reco-side-有尝试不用-vuecli-搭建过项目吗" data-v-5ecb72e8>有尝试不用 vueCli 搭建过项目吗？</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#你是怎么理解软件研发的生命周期的" class="sidebar-link reco-side-你是怎么理解软件研发的生命周期的" data-v-5ecb72e8>你是怎么理解软件研发的生命周期的？</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#接触过什么前端前沿技术" class="sidebar-link reco-side-接触过什么前端前沿技术" data-v-5ecb72e8>接触过什么前端前沿技术？</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#最近学习的技术点" class="sidebar-link reco-side-最近学习的技术点" data-v-5ecb72e8>最近学习的技术点？</a></li><li class="level-2" data-v-5ecb72e8><a href="/others/summary-answer.html#计算机网络" class="sidebar-link reco-side-计算机网络" data-v-5ecb72e8>计算机网络</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#http-的-get-和-post-请求有什么区别" class="sidebar-link reco-side-http-的-get-和-post-请求有什么区别" data-v-5ecb72e8>http 的 GET 和 POST 请求有什么区别？</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#为什么post会有两次请求" class="sidebar-link reco-side-为什么post会有两次请求" data-v-5ecb72e8>为什么post会有两次请求</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#http的请求头和请求体" class="sidebar-link reco-side-http的请求头和请求体" data-v-5ecb72e8>http的请求头和请求体</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#http请求头的属性有什么" class="sidebar-link reco-side-http请求头的属性有什么" data-v-5ecb72e8>http请求头的属性有什么</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#跟缓存相关的http请求头" class="sidebar-link reco-side-跟缓存相关的http请求头" data-v-5ecb72e8>跟缓存相关的http请求头</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#http1-1、http2-0的区别-http2-0相对于http1-1有哪些改进" class="sidebar-link reco-side-http1-1、http2-0的区别-http2-0相对于http1-1有哪些改进" data-v-5ecb72e8>http1.1、http2.0的区别？http2.0相对于http1.1有哪些改进</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#https和http区别" class="sidebar-link reco-side-https和http区别" data-v-5ecb72e8>https和http区别</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#https用到了非对称加密-用最通俗的语言-即便是父母也能听懂的方式-讲一下什么是非对称加密" class="sidebar-link reco-side-https用到了非对称加密-用最通俗的语言-即便是父母也能听懂的方式-讲一下什么是非对称加密" data-v-5ecb72e8>https用到了非对称加密，用最通俗的语言（即便是父母也能听懂的方式）讲一下什么是非对称加密</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#https能保证传输绝对安全吗" class="sidebar-link reco-side-https能保证传输绝对安全吗" data-v-5ecb72e8>https能保证传输绝对安全吗?</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#如何实现从http升级到https" class="sidebar-link reco-side-如何实现从http升级到https" data-v-5ecb72e8>如何实现从http升级到https</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#详细说https建立的流程" class="sidebar-link reco-side-详细说https建立的流程" data-v-5ecb72e8>详细说HTTPS建立的流程？</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#ssl加密的细节" class="sidebar-link reco-side-ssl加密的细节" data-v-5ecb72e8>ssl加密的细节</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#对称加密和非对称加密" class="sidebar-link reco-side-对称加密和非对称加密" data-v-5ecb72e8>对称加密和非对称加密</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#加密的过程有了解过吗" class="sidebar-link reco-side-加密的过程有了解过吗" data-v-5ecb72e8>加密的过程有了解过吗</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#ca机构有了解吗" class="sidebar-link reco-side-ca机构有了解吗" data-v-5ecb72e8>CA机构有了解吗</a></li><li class="level-2" data-v-5ecb72e8><a href="/others/summary-answer.html#浏览器原理" class="sidebar-link reco-side-浏览器原理" data-v-5ecb72e8>浏览器原理</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#浏览器输入url网址到网页显示的全过程" class="sidebar-link reco-side-浏览器输入url网址到网页显示的全过程" data-v-5ecb72e8>浏览器输入url网址到网页显示的全过程</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#重排、重绘" class="sidebar-link reco-side-重排、重绘" data-v-5ecb72e8>重排、重绘</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#浏览器标签页之间怎么通信" class="sidebar-link reco-side-浏览器标签页之间怎么通信" data-v-5ecb72e8>浏览器标签页之间怎么通信</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#浏览器本地存储的方式" class="sidebar-link reco-side-浏览器本地存储的方式" data-v-5ecb72e8>浏览器本地存储的方式？</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#cookie-localstorage-sessionstorage区别" class="sidebar-link reco-side-cookie-localstorage-sessionstorage区别" data-v-5ecb72e8>cookie，localStorage，sessionStorage区别？</a></li><li class="level-2" data-v-5ecb72e8><a href="/others/summary-answer.html#cookie、localstorage、sessionstorage-的区别" class="sidebar-link reco-side-cookie、localstorage、sessionstorage-的区别" data-v-5ecb72e8>cookie、localStorage、sessionStorage 的区别</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#它们会把数据存在哪-受不受同源策略制约" class="sidebar-link reco-side-它们会把数据存在哪-受不受同源策略制约" data-v-5ecb72e8>它们会把数据存在哪？受不受同源策略制约？</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#cookie常用的属性有哪些" class="sidebar-link reco-side-cookie常用的属性有哪些" data-v-5ecb72e8>cookie常用的属性有哪些？</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#cookie常用字段" class="sidebar-link reco-side-cookie常用字段" data-v-5ecb72e8>cookie常用字段</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#token和cookie怎么处理的" class="sidebar-link reco-side-token和cookie怎么处理的" data-v-5ecb72e8>token和cookie怎么处理的</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#跨域请求的方法" class="sidebar-link reco-side-跨域请求的方法" data-v-5ecb72e8>跨域请求的方法</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#怎么解决做项目遇到跨域问题-nginx代理服务器为什么能解决问题" class="sidebar-link reco-side-怎么解决做项目遇到跨域问题-nginx代理服务器为什么能解决问题" data-v-5ecb72e8>怎么解决做项目遇到跨域问题，nginx代理服务器为什么能解决问题</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#cors跨域原理-前后端需要做什么-通过设置字段来实现跨域" class="sidebar-link reco-side-cors跨域原理-前后端需要做什么-通过设置字段来实现跨域" data-v-5ecb72e8>cors跨域原理，前后端需要做什么？通过设置字段来实现跨域</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#http状态码" class="sidebar-link reco-side-http状态码" data-v-5ecb72e8>HTTP状态码</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#与缓存有关的状态码" class="sidebar-link reco-side-与缓存有关的状态码" data-v-5ecb72e8>与缓存有关的状态码</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#http状态码-302、404、500、304" class="sidebar-link reco-side-http状态码-302、404、500、304" data-v-5ecb72e8>http状态码：302、404、500、304</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#http的缓存机制" class="sidebar-link reco-side-http的缓存机制" data-v-5ecb72e8>HTTP的缓存机制</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#http缓存-设置强缓存有效期" class="sidebar-link reco-side-http缓存-设置强缓存有效期" data-v-5ecb72e8>http缓存（设置强缓存有效期）</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#浏览器本地缓存机制" class="sidebar-link reco-side-浏览器本地缓存机制" data-v-5ecb72e8>浏览器本地缓存机制</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#强缓存和协商缓存什么区别-如何设置" class="sidebar-link reco-side-强缓存和协商缓存什么区别-如何设置" data-v-5ecb72e8>强缓存和协商缓存什么区别？如何设置？</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#协商缓存的过程" class="sidebar-link reco-side-协商缓存的过程" data-v-5ecb72e8>协商缓存的过程</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#协商缓存需要用到哪些状态码" class="sidebar-link reco-side-协商缓存需要用到哪些状态码" data-v-5ecb72e8>协商缓存需要用到哪些状态码</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#html文件js文件-哪些用强缓存-哪些用协商缓存-为什么。" class="sidebar-link reco-side-html文件js文件-哪些用强缓存-哪些用协商缓存-为什么。" data-v-5ecb72e8>html文件js文件，哪些用强缓存，哪些用协商缓存，为什么。</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#浏览器的事件" class="sidebar-link reco-side-浏览器的事件" data-v-5ecb72e8>浏览器的事件</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#浏览器多进程有哪些" class="sidebar-link reco-side-浏览器多进程有哪些" data-v-5ecb72e8>浏览器多进程有哪些</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#filereader、blob、arraybuffer、typedbuffer、怎么保证上传顺序和并发控制" class="sidebar-link reco-side-filereader、blob、arraybuffer、typedbuffer、怎么保证上传顺序和并发控制" data-v-5ecb72e8>FileReader、BLob、ArrayBuffer、Typedbuffer、怎么保证上传顺序和并发控制</a></li><li class="level-2" data-v-5ecb72e8><a href="/others/summary-answer.html#html" class="sidebar-link reco-side-html" data-v-5ecb72e8>html</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#html5新增特性" class="sidebar-link reco-side-html5新增特性" data-v-5ecb72e8>html5新增特性</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#convas和svg的区别" class="sidebar-link reco-side-convas和svg的区别" data-v-5ecb72e8>convas和svg的区别</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#dom常见的操作-怎么绑定事件" class="sidebar-link reco-side-dom常见的操作-怎么绑定事件" data-v-5ecb72e8>DOM常见的操作，怎么绑定事件</a></li><li class="level-2" data-v-5ecb72e8><a href="/others/summary-answer.html#vue" class="sidebar-link reco-side-vue" data-v-5ecb72e8>vue</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#vue中用到了什么模式-前端开发主要用到了哪些框架" class="sidebar-link reco-side-vue中用到了什么模式-前端开发主要用到了哪些框架" data-v-5ecb72e8>vue中用到了什么模式?前端开发主要用到了哪些框架？</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#vue生命周期-组件间生命周期的顺序" class="sidebar-link reco-side-vue生命周期-组件间生命周期的顺序" data-v-5ecb72e8>vue生命周期？组件间生命周期的顺序？</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#vue的history模式和hash模式有什么区别-为什么history会出现404" class="sidebar-link reco-side-vue的history模式和hash模式有什么区别-为什么history会出现404" data-v-5ecb72e8>vue的history模式和hash模式有什么区别，为什么history会出现404？</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#vue设计原理" class="sidebar-link reco-side-vue设计原理" data-v-5ecb72e8>Vue设计原理</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#vue脚手架" class="sidebar-link reco-side-vue脚手架" data-v-5ecb72e8>vue脚手架</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#vue和react的区别" class="sidebar-link reco-side-vue和react的区别" data-v-5ecb72e8>vue和react的区别</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#vue-3-有了解过吗" class="sidebar-link reco-side-vue-3-有了解过吗" data-v-5ecb72e8>Vue 3 有了解过吗？</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#vue2和vue3区别" class="sidebar-link reco-side-vue2和vue3区别" data-v-5ecb72e8>vue2和vue3区别</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#vue双向绑定原理-深挖-哪个属性-什么模式-vue2和3有什么不同" class="sidebar-link reco-side-vue双向绑定原理-深挖-哪个属性-什么模式-vue2和3有什么不同" data-v-5ecb72e8>vue双向绑定原理（深挖 哪个属性？什么模式？vue2和3有什么不同）</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#vue-双向绑定的底层原理" class="sidebar-link reco-side-vue-双向绑定的底层原理" data-v-5ecb72e8>Vue 双向绑定的底层原理</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#v-if和v-show区别" class="sidebar-link reco-side-v-if和v-show区别" data-v-5ecb72e8>v-if和v-show区别</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#compute和watch区别" class="sidebar-link reco-side-compute和watch区别" data-v-5ecb72e8>compute和watch区别</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#vue里面的常用api" class="sidebar-link reco-side-vue里面的常用api" data-v-5ecb72e8>vue里面的常用api</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#nexttick" class="sidebar-link reco-side-nexttick" data-v-5ecb72e8>$nextTick</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#set" class="sidebar-link reco-side-set" data-v-5ecb72e8>$set</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#为什么vue3比vue2提升性能-表现在什么地方" class="sidebar-link reco-side-为什么vue3比vue2提升性能-表现在什么地方" data-v-5ecb72e8>为什么vue3比vue2提升性能，表现在什么地方</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#父子组件生命周期" class="sidebar-link reco-side-父子组件生命周期" data-v-5ecb72e8>父子组件生命周期</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#vue的props相关" class="sidebar-link reco-side-vue的props相关" data-v-5ecb72e8>vue的props相关</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#vue中子组件可以修改父组件的props吗" class="sidebar-link reco-side-vue中子组件可以修改父组件的props吗" data-v-5ecb72e8>vue中子组件可以修改父组件的props吗</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#vue组件间通信方式" class="sidebar-link reco-side-vue组件间通信方式" data-v-5ecb72e8>Vue组件间通信方式</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#如何自定义通用组件" class="sidebar-link reco-side-如何自定义通用组件" data-v-5ecb72e8>如何自定义通用组件</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#vue-的数据观测原理" class="sidebar-link reco-side-vue-的数据观测原理" data-v-5ecb72e8>vue 的数据观测原理</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#react-vue-为什么要使用虚拟dom-有哪些不使用虚拟dom的前端框架" class="sidebar-link reco-side-react-vue-为什么要使用虚拟dom-有哪些不使用虚拟dom的前端框架" data-v-5ecb72e8>react vue 为什么要使用虚拟dom，有哪些不使用虚拟dom的前端框架</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#vuex" class="sidebar-link reco-side-vuex" data-v-5ecb72e8>vuex</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#为什么用pinia而不是vuex做状态管理" class="sidebar-link reco-side-为什么用pinia而不是vuex做状态管理" data-v-5ecb72e8>为什么用Pinia而不是vuex做状态管理?</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#如果把所有状态都用全局状态管理会有什么问题" class="sidebar-link reco-side-如果把所有状态都用全局状态管理会有什么问题" data-v-5ecb72e8>如果把所有状态都用全局状态管理会有什么问题?</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#对于一个状态如何考虑是否应该提升到全局状态" class="sidebar-link reco-side-对于一个状态如何考虑是否应该提升到全局状态" data-v-5ecb72e8>对于一个状态如何考虑是否应该提升到全局状态?</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#哪些数据放在vuex中" class="sidebar-link reco-side-哪些数据放在vuex中" data-v-5ecb72e8>哪些数据放在Vuex中</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#vue路由的实现原理" class="sidebar-link reco-side-vue路由的实现原理" data-v-5ecb72e8>vue路由的实现原理</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#描述一下数据流向的过程" class="sidebar-link reco-side-描述一下数据流向的过程" data-v-5ecb72e8>描述一下数据流向的过程</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#vue为什么要用data包裹属性" class="sidebar-link reco-side-vue为什么要用data包裹属性" data-v-5ecb72e8>vue为什么要用data包裹属性</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#vue的diff算法-vue2和3之间做了什么优化" class="sidebar-link reco-side-vue的diff算法-vue2和3之间做了什么优化" data-v-5ecb72e8>vue的diff算法（vue2和3之间做了什么优化）</a></li><li class="level-2" data-v-5ecb72e8><a href="/others/summary-answer.html#vue的diff算法基本思路" class="sidebar-link reco-side-vue的diff算法基本思路" data-v-5ecb72e8>Vue的diff算法基本思路：</a></li><li class="level-2" data-v-5ecb72e8><a href="/others/summary-answer.html#vue2与vue3的diff算法优化" class="sidebar-link reco-side-vue2与vue3的diff算法优化" data-v-5ecb72e8>Vue2与Vue3的diff算法优化：</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#vue2的diff" class="sidebar-link reco-side-vue2的diff" data-v-5ecb72e8>Vue2的diff：</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#vue3的diff优化" class="sidebar-link reco-side-vue3的diff优化" data-v-5ecb72e8>Vue3的diff优化：</a></li><li class="level-2" data-v-5ecb72e8><a href="/others/summary-answer.html#js-node" class="sidebar-link reco-side-js-node" data-v-5ecb72e8>js&amp;node</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#js与ts区别" class="sidebar-link reco-side-js与ts区别" data-v-5ecb72e8>js与ts区别</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#js数据类型有哪些-基本数据类型和引用数据类型的区别" class="sidebar-link reco-side-js数据类型有哪些-基本数据类型和引用数据类型的区别" data-v-5ecb72e8>js数据类型有哪些？基本数据类型和引用数据类型的区别？</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#javascript-里的数据类型。判断数据类型有哪些方法" class="sidebar-link reco-side-javascript-里的数据类型。判断数据类型有哪些方法" data-v-5ecb72e8>JavaScript 里的数据类型。判断数据类型有哪些方法？</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#如何判断一个变量的类型是不是数组" class="sidebar-link reco-side-如何判断一个变量的类型是不是数组" data-v-5ecb72e8>如何判断一个变量的类型是不是数组</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#instanceof-和-typeof-的区别。" class="sidebar-link reco-side-instanceof-和-typeof-的区别。" data-v-5ecb72e8>instanceof 和 typeof 的区别。</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#instanceof可靠吗" class="sidebar-link reco-side-instanceof可靠吗" data-v-5ecb72e8>instanceof可靠吗</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#es6新增特性" class="sidebar-link reco-side-es6新增特性" data-v-5ecb72e8>ES6新增特性</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#数组常用方法" class="sidebar-link reco-side-数组常用方法" data-v-5ecb72e8>数组常用方法</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#改变this指向" class="sidebar-link reco-side-改变this指向" data-v-5ecb72e8>改变this指向</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#call-apply-blid区别" class="sidebar-link reco-side-call-apply-blid区别" data-v-5ecb72e8>call,apply,blid区别</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#防抖和节流的区别-什么情况用节流-什么情况用防抖" class="sidebar-link reco-side-防抖和节流的区别-什么情况用节流-什么情况用防抖" data-v-5ecb72e8>防抖和节流的区别？什么情况用节流？什么情况用防抖？</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#axios是做什么的-和ajax区别" class="sidebar-link reco-side-axios是做什么的-和ajax区别" data-v-5ecb72e8>Axios是做什么的，和ajax区别</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#ajax原理-实现-请求体写在哪" class="sidebar-link reco-side-ajax原理-实现-请求体写在哪" data-v-5ecb72e8>ajax原理，实现，请求体写在哪</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#箭头函数有了解过吗-跟普通的函数有什么区别" class="sidebar-link reco-side-箭头函数有了解过吗-跟普通的函数有什么区别" data-v-5ecb72e8>箭头函数有了解过吗？跟普通的函数有什么区别？</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#数组方法-map和foreach区别" class="sidebar-link reco-side-数组方法-map和foreach区别" data-v-5ecb72e8>数组方法，map和foreach区别</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#typescript泛型有哪些" class="sidebar-link reco-side-typescript泛型有哪些" data-v-5ecb72e8>typescript泛型有哪些</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#对js继承有了解吗" class="sidebar-link reco-side-对js继承有了解吗" data-v-5ecb72e8>对Js继承有了解吗？</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#对原型链有了解吗-什么是原型链-原型链的终点-function-prototype指向哪" class="sidebar-link reco-side-对原型链有了解吗-什么是原型链-原型链的终点-function-prototype指向哪" data-v-5ecb72e8>对原型链有了解吗？什么是原型链？原型链的终点？Function.prototype指向哪？</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#原型链的机制与使用场景" class="sidebar-link reco-side-原型链的机制与使用场景" data-v-5ecb72e8>原型链的机制与使用场景</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#什么数据存在对象中-什么数据存在prototype中" class="sidebar-link reco-side-什么数据存在对象中-什么数据存在prototype中" data-v-5ecb72e8>什么数据存在对象中，什么数据存在prototype中</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#package-json相关-name和module区别。dependencies" class="sidebar-link reco-side-package-json相关-name和module区别。dependencies" data-v-5ecb72e8>package.json相关：name和module区别。dependencies</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#js事件模型与事件循环机制" class="sidebar-link reco-side-js事件模型与事件循环机制" data-v-5ecb72e8>JS事件模型与事件循环机制</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#微任务和宏任务" class="sidebar-link reco-side-微任务和宏任务" data-v-5ecb72e8>微任务和宏任务</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#栅格瓦片数据的渲染优化方式-分级渲染-软加载" class="sidebar-link reco-side-栅格瓦片数据的渲染优化方式-分级渲染-软加载" data-v-5ecb72e8>栅格瓦片数据的渲染优化方式，分级渲染，软加载</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#for-in-for-of-的区别-遍历数组用什么" class="sidebar-link reco-side-for-in-for-of-的区别-遍历数组用什么" data-v-5ecb72e8>for…in… for…of…的区别， 遍历数组用什么</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#js中栈与堆" class="sidebar-link reco-side-js中栈与堆" data-v-5ecb72e8>js中栈与堆</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#介绍下闭包-什么样的函数是闭包函数" class="sidebar-link reco-side-介绍下闭包-什么样的函数是闭包函数" data-v-5ecb72e8>介绍下闭包，什么样的函数是闭包函数？</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#闭包的原理" class="sidebar-link reco-side-闭包的原理" data-v-5ecb72e8>闭包的原理</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#闭包-内存泄漏怎么解决" class="sidebar-link reco-side-闭包-内存泄漏怎么解决" data-v-5ecb72e8>闭包，内存泄漏怎么解决</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#script标签中async和defer的区别" class="sidebar-link reco-side-script标签中async和defer的区别" data-v-5ecb72e8>script标签中async和defer的区别</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#var-和-let-有什么区别" class="sidebar-link reco-side-var-和-let-有什么区别" data-v-5ecb72e8>var 和 let 有什么区别？</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#const-和-let-有什么区别" class="sidebar-link reco-side-const-和-let-有什么区别" data-v-5ecb72e8>const 和 let 有什么区别？</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#异步编程的方法" class="sidebar-link reco-side-异步编程的方法" data-v-5ecb72e8>异步编程的方法</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#promise-了解吗" class="sidebar-link reco-side-promise-了解吗" data-v-5ecb72e8>promise 了解吗？</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#promise如果后面有多个-then怎么传值" class="sidebar-link reco-side-promise如果后面有多个-then怎么传值" data-v-5ecb72e8>promise如果后面有多个.then怎么传值</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#settimeout-和-promise-的执行顺序" class="sidebar-link reco-side-settimeout-和-promise-的执行顺序" data-v-5ecb72e8>setTimeout 和 Promise 的执行顺序</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#promise的三种状态" class="sidebar-link reco-side-promise的三种状态" data-v-5ecb72e8>promise的三种状态</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#promise和async-await区别" class="sidebar-link reco-side-promise和async-await区别" data-v-5ecb72e8>promise和async/await区别</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#async-await怎么捕获异常" class="sidebar-link reco-side-async-await怎么捕获异常" data-v-5ecb72e8>async await怎么捕获异常？</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#async-await的底层原理-generator的原理" class="sidebar-link reco-side-async-await的底层原理-generator的原理" data-v-5ecb72e8>async await的底层原理？generator的原理？</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#js中-与-有什么区别" class="sidebar-link reco-side-js中-与-有什么区别" data-v-5ecb72e8>js中 == 与 === 有什么区别</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#setinterval的任务堆积问题-为什么settimeout能解决" class="sidebar-link reco-side-setinterval的任务堆积问题-为什么settimeout能解决" data-v-5ecb72e8>setInterval的任务堆积问题，为什么settimeout能解决</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#深拷贝和浅拷贝的区别" class="sidebar-link reco-side-深拷贝和浅拷贝的区别" data-v-5ecb72e8>深拷贝和浅拷贝的区别？</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#如何实现深拷贝" class="sidebar-link reco-side-如何实现深拷贝" data-v-5ecb72e8>如何实现深拷贝</a></li><li class="level-2" data-v-5ecb72e8><a href="/others/summary-answer.html#运算符是深拷贝还是浅拷贝" class="sidebar-link reco-side-运算符是深拷贝还是浅拷贝" data-v-5ecb72e8>... 运算符是深拷贝还是浅拷贝</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#js的严格模式" class="sidebar-link reco-side-js的严格模式" data-v-5ecb72e8>js的严格模式</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#new-一个对象发生了什么-执行过程" class="sidebar-link reco-side-new-一个对象发生了什么-执行过程" data-v-5ecb72e8>new 一个对象发生了什么，执行过程</a></li><li class="level-2" data-v-5ecb72e8><a href="/others/summary-answer.html#css" class="sidebar-link reco-side-css" data-v-5ecb72e8>css</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#css5新增特性" class="sidebar-link reco-side-css5新增特性" data-v-5ecb72e8>css5新增特性</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#块级元素居中的几种方式" class="sidebar-link reco-side-块级元素居中的几种方式" data-v-5ecb72e8>块级元素居中的几种方式</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#css垂直居中" class="sidebar-link reco-side-css垂直居中" data-v-5ecb72e8>css垂直居中</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#em-rem-vm-vh的区别" class="sidebar-link reco-side-em-rem-vm-vh的区别" data-v-5ecb72e8>em，rem，vm,vh的区别</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#为什么要用scss-和其他预渲染库的对比。" class="sidebar-link reco-side-为什么要用scss-和其他预渲染库的对比。" data-v-5ecb72e8>为什么要用scss，和其他预渲染库的对比。</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#css权重" class="sidebar-link reco-side-css权重" data-v-5ecb72e8>css权重</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#css优先级" class="sidebar-link reco-side-css优先级" data-v-5ecb72e8>css优先级</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#bfc" class="sidebar-link reco-side-bfc" data-v-5ecb72e8>bfc</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#如何创建bfc" class="sidebar-link reco-side-如何创建bfc" data-v-5ecb72e8>如何创建bfc</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#css盒子模型" class="sidebar-link reco-side-css盒子模型" data-v-5ecb72e8>css盒子模型</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#css常用布局" class="sidebar-link reco-side-css常用布局" data-v-5ecb72e8>css常用布局</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#rem原理-有没有考虑过浏览器兼容性" class="sidebar-link reco-side-rem原理-有没有考虑过浏览器兼容性" data-v-5ecb72e8>rem原理，有没有考虑过浏览器兼容性</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#css哪些属性可以实现布局" class="sidebar-link reco-side-css哪些属性可以实现布局" data-v-5ecb72e8>CSS哪些属性可以实现布局</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#flex-布局-常用的属性有哪些" class="sidebar-link reco-side-flex-布局-常用的属性有哪些" data-v-5ecb72e8>flex 布局，常用的属性有哪些？</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#flex-1-是什么意思" class="sidebar-link reco-side-flex-1-是什么意思" data-v-5ecb72e8>flex : 1 是什么意思？</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#css的定位详解-position-static-relative-stiky-absolute" class="sidebar-link reco-side-css的定位详解-position-static-relative-stiky-absolute" data-v-5ecb72e8>css的定位详解？position static relative stiky absolute</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#box-sizing-属性" class="sidebar-link reco-side-box-sizing-属性" data-v-5ecb72e8>box-sizing 属性？</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#css-中的伪类和伪元素" class="sidebar-link reco-side-css-中的伪类和伪元素" data-v-5ecb72e8>CSS 中的伪类和伪元素</a></li><li class="level-2" data-v-5ecb72e8><a href="/others/summary-answer.html#react" class="sidebar-link reco-side-react" data-v-5ecb72e8>react</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#react与vue有什么不同" class="sidebar-link reco-side-react与vue有什么不同" data-v-5ecb72e8>react与vue有什么不同</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#state和props" class="sidebar-link reco-side-state和props" data-v-5ecb72e8>state和props</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#怎么创建一个组件" class="sidebar-link reco-side-怎么创建一个组件" data-v-5ecb72e8>怎么创建一个组件</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#react之间怎么通信的" class="sidebar-link reco-side-react之间怎么通信的" data-v-5ecb72e8>react之间怎么通信的</a></li><li class="level-2" data-v-5ecb72e8><a href="/others/summary-answer.html#计算机基础八股文" class="sidebar-link reco-side-计算机基础八股文" data-v-5ecb72e8>计算机基础八股文</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#进程和线程的区别与联系" class="sidebar-link reco-side-进程和线程的区别与联系" data-v-5ecb72e8>进程和线程的区别与联系</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#进程间通信方式-进程间如何进行通信-说一下应用场景" class="sidebar-link reco-side-进程间通信方式-进程间如何进行通信-说一下应用场景" data-v-5ecb72e8>进程间通信方式，进程间如何进行通信？说一下应用场景？</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#管道是如何通信的-全双工、半双工、单工-三者之间的区别" class="sidebar-link reco-side-管道是如何通信的-全双工、半双工、单工-三者之间的区别" data-v-5ecb72e8>管道是如何通信的？全双工、半双工、单工？？三者之间的区别</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#计算机进程的调度方式" class="sidebar-link reco-side-计算机进程的调度方式" data-v-5ecb72e8>计算机进程的调度方式</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#linux查看进程和端口" class="sidebar-link reco-side-linux查看进程和端口" data-v-5ecb72e8>linux查看进程和端口</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#计算机是如何管理内存的-提示-虚拟内存-段、页、段页-以及物理内存-为什么要有虚拟内存" class="sidebar-link reco-side-计算机是如何管理内存的-提示-虚拟内存-段、页、段页-以及物理内存-为什么要有虚拟内存" data-v-5ecb72e8>计算机是如何管理内存的？（提示：虚拟内存:段、页、段页；以及物理内存）？为什么要有虚拟内存？</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#软件设计原则" class="sidebar-link reco-side-软件设计原则" data-v-5ecb72e8>软件设计原则</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#了解的设计模式" class="sidebar-link reco-side-了解的设计模式" data-v-5ecb72e8>了解的设计模式</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#tcp三次握手-为什么要三次握手" class="sidebar-link reco-side-tcp三次握手-为什么要三次握手" data-v-5ecb72e8>tcp三次握手，为什么要三次握手</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#tcp和udp的区别以及各自的应用场景" class="sidebar-link reco-side-tcp和udp的区别以及各自的应用场景" data-v-5ecb72e8>tcp和udp的区别以及各自的应用场景</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#哪些协议基于tcp或udp" class="sidebar-link reco-side-哪些协议基于tcp或udp" data-v-5ecb72e8>哪些协议基于TCP或UDP</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#tcp如何保证传输的可靠性-滑动窗口具体是什么样的-tcp-通过确认和重传、序号和确认号、滑动窗口等机制来保证传输的可靠性。" class="sidebar-link reco-side-tcp如何保证传输的可靠性-滑动窗口具体是什么样的-tcp-通过确认和重传、序号和确认号、滑动窗口等机制来保证传输的可靠性。" data-v-5ecb72e8>tcp如何保证传输的可靠性？滑动窗口具体是什么样的？（TCP 通过确认和重传、序号和确认号、滑动窗口等机制来保证传输的可靠性。）</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#面向对象三个特征介绍一下-封装继承多态" class="sidebar-link reco-side-面向对象三个特征介绍一下-封装继承多态" data-v-5ecb72e8>面向对象三个特征介绍一下，封装继承多态</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#链表有什么特点-应用场景" class="sidebar-link reco-side-链表有什么特点-应用场景" data-v-5ecb72e8>链表有什么特点，应用场景</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#死锁、悲观锁、乐观锁" class="sidebar-link reco-side-死锁、悲观锁、乐观锁" data-v-5ecb72e8>死锁、悲观锁、乐观锁</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#临界资源是什么" class="sidebar-link reco-side-临界资源是什么" data-v-5ecb72e8>临界资源是什么</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#讲一下锁、信号量、互斥量等同步机制" class="sidebar-link reco-side-讲一下锁、信号量、互斥量等同步机制" data-v-5ecb72e8>讲一下锁、信号量、互斥量等同步机制</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#常见调度算法说一下" class="sidebar-link reco-side-常见调度算法说一下" data-v-5ecb72e8>常见调度算法说一下</a></li><li class="level-2" data-v-5ecb72e8><a href="/others/summary-answer.html#模块化、组件化、优化、安全性" class="sidebar-link reco-side-模块化、组件化、优化、安全性" data-v-5ecb72e8>模块化、组件化、优化、安全性</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#对hooks的理解" class="sidebar-link reco-side-对hooks的理解" data-v-5ecb72e8>对hooks的理解</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#react的hooks-原理的东西有看过吗" class="sidebar-link reco-side-react的hooks-原理的东西有看过吗" data-v-5ecb72e8>react的hooks，原理的东西有看过吗</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#webpack是干什么的-webpack是怎么创建项目的" class="sidebar-link reco-side-webpack是干什么的-webpack是怎么创建项目的" data-v-5ecb72e8>webpack是干什么的？webpack是怎么创建项目的？</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#webpack能处理什么类型的文件-不能处理什么类型的文件" class="sidebar-link reco-side-webpack能处理什么类型的文件-不能处理什么类型的文件" data-v-5ecb72e8>webpack能处理什么类型的文件？不能处理什么类型的文件？</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#了解-webpack-的-loader-和-plugin-吗-它们是怎么实现的" class="sidebar-link reco-side-了解-webpack-的-loader-和-plugin-吗-它们是怎么实现的" data-v-5ecb72e8>了解 Webpack 的 loader 和 plugin 吗？它们是怎么实现的？</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#说说你的理解-ui-组件和业务组件有什么区别" class="sidebar-link reco-side-说说你的理解-ui-组件和业务组件有什么区别" data-v-5ecb72e8>说说你的理解 UI 组件和业务组件有什么区别？</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#如何设计复用的逻辑" class="sidebar-link reco-side-如何设计复用的逻辑" data-v-5ecb72e8>如何设计复用的逻辑?</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#为什么选择服务端进行渲染" class="sidebar-link reco-side-为什么选择服务端进行渲染" data-v-5ecb72e8>为什么选择服务端进行渲染?</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#为什么服务端渲染有利于seo" class="sidebar-link reco-side-为什么服务端渲染有利于seo" data-v-5ecb72e8>为什么服务端渲染有利于seo</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#非服务端渲染能做seo吗-浏览器爬虫原理是什么。" class="sidebar-link reco-side-非服务端渲染能做seo吗-浏览器爬虫原理是什么。" data-v-5ecb72e8>非服务端渲染能做seo吗，浏览器爬虫原理是什么。</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#如果有大规模访问你的接口-或是有爬虫如何进行处理和优化" class="sidebar-link reco-side-如果有大规模访问你的接口-或是有爬虫如何进行处理和优化" data-v-5ecb72e8>如果有大规模访问你的接口，或是有爬虫如何进行处理和优化?</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#如何做首屏优化" class="sidebar-link reco-side-如何做首屏优化" data-v-5ecb72e8>如何做首屏优化?</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#如何保证token的安全" class="sidebar-link reco-side-如何保证token的安全" data-v-5ecb72e8>如何保证token的安全?</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#babel-有了解过吗" class="sidebar-link reco-side-babel-有了解过吗" data-v-5ecb72e8>babel 有了解过吗？</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#前端哪些地方需要做性能优化-前端如何做性能优化" class="sidebar-link reco-side-前端哪些地方需要做性能优化-前端如何做性能优化" data-v-5ecb72e8>前端哪些地方需要做性能优化,前端如何做性能优化</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#如何分析一个页面的性能" class="sidebar-link reco-side-如何分析一个页面的性能" data-v-5ecb72e8>如何分析一个页面的性能</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#从开发者视角看-有哪些性能指标、性能指标如何测出来的" class="sidebar-link reco-side-从开发者视角看-有哪些性能指标、性能指标如何测出来的" data-v-5ecb72e8>从开发者视角看，有哪些性能指标、性能指标如何测出来的</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#从用户角度看-还有哪些指标-web有哪些性能指标" class="sidebar-link reco-side-从用户角度看-还有哪些指标-web有哪些性能指标" data-v-5ecb72e8>从用户角度看，还有哪些指标,web有哪些性能指标</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#移动端应用有哪些性能指标" class="sidebar-link reco-side-移动端应用有哪些性能指标" data-v-5ecb72e8>移动端应用有哪些性能指标</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#http请求过多就说明性能差吗" class="sidebar-link reco-side-http请求过多就说明性能差吗" data-v-5ecb72e8>http请求过多就说明性能差吗</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#cdn缓存查询步骤" class="sidebar-link reco-side-cdn缓存查询步骤" data-v-5ecb72e8>CDN缓存查询步骤</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#大图片怎么优化-比如一个超大的地图-怎么检测一个大图片" class="sidebar-link reco-side-大图片怎么优化-比如一个超大的地图-怎么检测一个大图片" data-v-5ecb72e8>大图片怎么优化（比如一个超大的地图）：怎么检测一个大图片</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#假如你知道是一个大图片怎么优化-懒加载-预加载-分片" class="sidebar-link reco-side-假如你知道是一个大图片怎么优化-懒加载-预加载-分片" data-v-5ecb72e8>假如你知道是一个大图片怎么优化，懒加载，预加载，分片</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#分片怎么保证顺序和不丢失-网络原因导致丢失了怎么办" class="sidebar-link reco-side-分片怎么保证顺序和不丢失-网络原因导致丢失了怎么办" data-v-5ecb72e8>分片怎么保证顺序和不丢失，网络原因导致丢失了怎么办</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#图片懒加载怎么做得-有哪些常见方案" class="sidebar-link reco-side-图片懒加载怎么做得-有哪些常见方案" data-v-5ecb72e8>图片懒加载怎么做得？有哪些常见方案？</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#说一下数据检测的几种方式。你知道原理吗" class="sidebar-link reco-side-说一下数据检测的几种方式。你知道原理吗" data-v-5ecb72e8>说一下数据检测的几种方式。你知道原理吗？</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#跨端如何开发" class="sidebar-link reco-side-跨端如何开发" data-v-5ecb72e8>跨端如何开发</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#xss攻击和csrf攻击" class="sidebar-link reco-side-xss攻击和csrf攻击" data-v-5ecb72e8>xss攻击和csrf攻击</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#csrf攻击怎么实施和防范" class="sidebar-link reco-side-csrf攻击怎么实施和防范" data-v-5ecb72e8>csrf攻击怎么实施和防范</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#注入攻击" class="sidebar-link reco-side-注入攻击" data-v-5ecb72e8>注入攻击？</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#如果路径中有类似-a-b-tostring-这种情况-你怎么考虑。-答-这是一种注入攻击的方式-然后说说自己对注入攻击的一些看法和防止手段" class="sidebar-link reco-side-如果路径中有类似-a-b-tostring-这种情况-你怎么考虑。-答-这是一种注入攻击的方式-然后说说自己对注入攻击的一些看法和防止手段" data-v-5ecb72e8>如果路径中有类似 a.b.toString 这种情况，你怎么考虑。（答：这是一种注入攻击的方式，然后说说自己对注入攻击的一些看法和防止手段）</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#移动端适配" class="sidebar-link reco-side-移动端适配" data-v-5ecb72e8>移动端适配</a></li><li class="level-2" data-v-5ecb72e8><a href="/others/summary-answer.html#手撕算法题" class="sidebar-link reco-side-手撕算法题" data-v-5ecb72e8>手撕算法题</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#斐波那契数列用两种以上方式实现" class="sidebar-link reco-side-斐波那契数列用两种以上方式实现" data-v-5ecb72e8>斐波那契数列用两种以上方式实现</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#判断链表是否相交" class="sidebar-link reco-side-判断链表是否相交" data-v-5ecb72e8>判断链表是否相交</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#如果输入有环呢" class="sidebar-link reco-side-如果输入有环呢" data-v-5ecb72e8>如果输入有环呢</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#两个栈实现队列" class="sidebar-link reco-side-两个栈实现队列" data-v-5ecb72e8>两个栈实现队列</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#两个队列模拟栈" class="sidebar-link reco-side-两个队列模拟栈" data-v-5ecb72e8>两个队列模拟栈</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#实现一个数组的排序-用三种方法" class="sidebar-link reco-side-实现一个数组的排序-用三种方法" data-v-5ecb72e8>实现一个数组的排序，用三种方法</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#快速排序" class="sidebar-link reco-side-快速排序" data-v-5ecb72e8>快速排序</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#归并排序" class="sidebar-link reco-side-归并排序" data-v-5ecb72e8>归并排序</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#逆序数查找" class="sidebar-link reco-side-逆序数查找" data-v-5ecb72e8>逆序数查找</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#将对象数组转换为树形结构。" class="sidebar-link reco-side-将对象数组转换为树形结构。" data-v-5ecb72e8>将对象数组转换为树形结构。</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#手撕函数柯里化" class="sidebar-link reco-side-手撕函数柯里化" data-v-5ecb72e8>手撕函数柯里化</a></li><li class="level-2" data-v-5ecb72e8><a href="/others/summary-answer.html#实操题" class="sidebar-link reco-side-实操题" data-v-5ecb72e8>实操题</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#js闭包-写一个计数器函数-每次调用打印" class="sidebar-link reco-side-js闭包-写一个计数器函数-每次调用打印" data-v-5ecb72e8>js闭包？写一个计数器函数，每次调用打印++</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#写一下防抖节流" class="sidebar-link reco-side-写一下防抖节流" data-v-5ecb72e8>写一下防抖节流？</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#设计一个函数getnewurl-参数是一个url和query-返回一个url和参数拼接之后的新url-类似于http请求中get请求的参数放在url后面-在做之前面试官说这并不是考算法-而是考察函数设计的鲁棒性-需要多考虑边界情况。" class="sidebar-link reco-side-设计一个函数getnewurl-参数是一个url和query-返回一个url和参数拼接之后的新url-类似于http请求中get请求的参数放在url后面-在做之前面试官说这并不是考算法-而是考察函数设计的鲁棒性-需要多考虑边界情况。" data-v-5ecb72e8>设计一个函数getNewUrl，参数是一个url和query，返回一个url和参数拼接之后的新url（类似于http请求中get请求的参数放在url后面），在做之前面试官说这并不是考算法，而是考察函数设计的鲁棒性，需要多考虑边界情况。</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#手写-实现图片加载失败后-显示另一个地址内容" class="sidebar-link reco-side-手写-实现图片加载失败后-显示另一个地址内容" data-v-5ecb72e8>手写，实现图片加载失败后，显示另一个地址内容</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#手写instancof方法" class="sidebar-link reco-side-手写instancof方法" data-v-5ecb72e8>手写instancof方法</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#手写promise-all" class="sidebar-link reco-side-手写promise-all" data-v-5ecb72e8>手写promise.all</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#手写一个-promise-的并发控制" class="sidebar-link reco-side-手写一个-promise-的并发控制" data-v-5ecb72e8>手写一个 Promise 的并发控制</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#promise版本的settimeout" class="sidebar-link reco-side-promise版本的settimeout" data-v-5ecb72e8>promise版本的settimeout</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#实现一个函数fn-start-success-fail-可以进行catch-then的链式调用" class="sidebar-link reco-side-实现一个函数fn-start-success-fail-可以进行catch-then的链式调用" data-v-5ecb72e8>实现一个函数fn({start,success,fail})可以进行catch/then的链式调用</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#手写-双向数据绑定" class="sidebar-link reco-side-手写-双向数据绑定" data-v-5ecb72e8>手写：双向数据绑定</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#手写一个vue3的倒计时组件" class="sidebar-link reco-side-手写一个vue3的倒计时组件" data-v-5ecb72e8>手写一个vue3的倒计时组件</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#css编程题-一行文字展示超出部分用省略号替代-三行文字展示超出部分用省略号替代" class="sidebar-link reco-side-css编程题-一行文字展示超出部分用省略号替代-三行文字展示超出部分用省略号替代" data-v-5ecb72e8>css编程题:一行文字展示超出部分用省略号替代；三行文字展示超出部分用省略号替代</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#js编程题-手写apply函数" class="sidebar-link reco-side-js编程题-手写apply函数" data-v-5ecb72e8>js编程题:手写apply函数</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#用reduce实现map" class="sidebar-link reco-side-用reduce实现map" data-v-5ecb72e8>用reduce实现map</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#css实现三角形" class="sidebar-link reco-side-css实现三角形" data-v-5ecb72e8>css实现三角形</a></li><li class="level-2" data-v-5ecb72e8><a href="/others/summary-answer.html#反问" class="sidebar-link reco-side-反问" data-v-5ecb72e8>反问</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#什么部门" class="sidebar-link reco-side-什么部门" data-v-5ecb72e8>什么部门</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#主要技术栈" class="sidebar-link reco-side-主要技术栈" data-v-5ecb72e8>主要技术栈</a></li><li class="level-3" data-v-5ecb72e8><a href="/others/summary-answer.html#web端和小程序端的占比" class="sidebar-link reco-side-web端和小程序端的占比" data-v-5ecb72e8>web端和小程序端的占比</a></li></ul></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div><div data-v-3338c3f8><div class="DetailsOpenFlag" style="right:1rem;bottom:9rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;font-size:14px;font-weight:500;display:none;" data-v-3338c3f8>
 展开

</div></div><!----><div class="Sakura" data-v-248d85d6><canvas id="canvas_sakura" style="z-index:-1;" data-v-248d85d6></canvas></div><!----><!----></div></div>
    <script src="/assets/js/app.1d990b48.js" defer></script><script src="/assets/js/4.f0018437.js" defer></script><script src="/assets/js/1.f3d9f98c.js" defer></script><script src="/assets/js/124.58bcc7ee.js" defer></script><script src="/assets/js/22.15f81ae7.js" defer></script>
    <div id="maps" style="pointer-events:auto;display: none;">
      <div
        style="position: fixed; width: 300px; height: 300px; right: 200px; bottom: 0px;"
      >
      <script type="text/javascript" src="//rf.revolvermaps.com/0/0/6.js?i=5kd8hpv87ho&amp;m=7&amp;c=e63100&amp;cr1=ffffff&amp;f=arial&amp;l=0&amp;bv=90&amp;lx=-420&amp;ly=420&amp;hi=20&amp;he=7&amp;hc=a8ddff&amp;rs=80" async="async"></script>
      </div>
    </div>
  </body>
</html>
