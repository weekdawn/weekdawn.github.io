<!-- ssr.html -->
<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Scala学习笔记 | Week.D.Awn</title>
    <meta name="generator" content="VuePress 1.8.2" />
    <link rel="icon" href="/vuepress/logo.png">
    <link rel="apple-touch-icon" href="/vuepress/logo.png">
    <script language="javascript" type="text/javascript" src="https://cdn.staticfile.org/jquery/1.7.2/jquery.min.js"></script>
    <script language="javascript" type="text/javascript" src="/js/MouseClickEffect.js"></script> <meta name="description" content="Things Aren't Always What You Seem">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    <meta name="renderer" content="webkit">
    <meta name="referrer" content="never">
    <meta data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">  <link rel="preload" href="/assets/css/0.styles.bf298c27.css" as="style"><link rel="preload" href="/assets/js/app.b52a54d3.js" as="script"><link rel="preload" href="/assets/js/4.2ab4d284.js" as="script"><link rel="preload" href="/assets/js/1.d5207ac6.js" as="script"><link rel="preload" href="/assets/js/83.402b2fce.js" as="script"><link rel="preload" href="/assets/js/20.23ca62f8.js" as="script"><link rel="prefetch" href="/assets/js/10.09793738.js"><link rel="prefetch" href="/assets/js/100.2742c59c.js"><link rel="prefetch" href="/assets/js/101.0fc59b8b.js"><link rel="prefetch" href="/assets/js/102.354fd238.js"><link rel="prefetch" href="/assets/js/103.ac3c62fc.js"><link rel="prefetch" href="/assets/js/104.8e8b73e1.js"><link rel="prefetch" href="/assets/js/105.254ffd7f.js"><link rel="prefetch" href="/assets/js/106.0b9c1db1.js"><link rel="prefetch" href="/assets/js/107.8bdd41f1.js"><link rel="prefetch" href="/assets/js/108.d55a157e.js"><link rel="prefetch" href="/assets/js/109.445ebe8e.js"><link rel="prefetch" href="/assets/js/11.05d9eec5.js"><link rel="prefetch" href="/assets/js/110.aa8a8ce1.js"><link rel="prefetch" href="/assets/js/111.5d10e4ba.js"><link rel="prefetch" href="/assets/js/112.7c3f8e28.js"><link rel="prefetch" href="/assets/js/113.b4fadaf9.js"><link rel="prefetch" href="/assets/js/12.d1afcb74.js"><link rel="prefetch" href="/assets/js/13.175a7120.js"><link rel="prefetch" href="/assets/js/14.a8c7df9c.js"><link rel="prefetch" href="/assets/js/15.f5cfd398.js"><link rel="prefetch" href="/assets/js/16.a1b9e428.js"><link rel="prefetch" href="/assets/js/17.80aab54e.js"><link rel="prefetch" href="/assets/js/18.b87e8de1.js"><link rel="prefetch" href="/assets/js/19.3db6526c.js"><link rel="prefetch" href="/assets/js/2.9bf63212.js"><link rel="prefetch" href="/assets/js/21.ad20e9ca.js"><link rel="prefetch" href="/assets/js/22.de79e9b4.js"><link rel="prefetch" href="/assets/js/23.487a23f7.js"><link rel="prefetch" href="/assets/js/24.a935d5eb.js"><link rel="prefetch" href="/assets/js/25.1b636312.js"><link rel="prefetch" href="/assets/js/26.8f288d28.js"><link rel="prefetch" href="/assets/js/27.e6523325.js"><link rel="prefetch" href="/assets/js/28.ac7db5fc.js"><link rel="prefetch" href="/assets/js/29.b74bd1a4.js"><link rel="prefetch" href="/assets/js/30.057669f4.js"><link rel="prefetch" href="/assets/js/31.143b7885.js"><link rel="prefetch" href="/assets/js/32.8bac0e33.js"><link rel="prefetch" href="/assets/js/33.ba46c264.js"><link rel="prefetch" href="/assets/js/34.d21edf67.js"><link rel="prefetch" href="/assets/js/35.041c61d8.js"><link rel="prefetch" href="/assets/js/36.761ff651.js"><link rel="prefetch" href="/assets/js/37.322a55df.js"><link rel="prefetch" href="/assets/js/38.347b733e.js"><link rel="prefetch" href="/assets/js/39.cbb34fcb.js"><link rel="prefetch" href="/assets/js/40.1f327de9.js"><link rel="prefetch" href="/assets/js/41.15e7582c.js"><link rel="prefetch" href="/assets/js/42.cdf9ef0b.js"><link rel="prefetch" href="/assets/js/43.014cbac2.js"><link rel="prefetch" href="/assets/js/44.3ac06348.js"><link rel="prefetch" href="/assets/js/45.f4c9766c.js"><link rel="prefetch" href="/assets/js/46.d4369dfa.js"><link rel="prefetch" href="/assets/js/47.4f42113b.js"><link rel="prefetch" href="/assets/js/48.8ca8511a.js"><link rel="prefetch" href="/assets/js/49.dc63e70c.js"><link rel="prefetch" href="/assets/js/5.b4259a13.js"><link rel="prefetch" href="/assets/js/50.05b4b9d8.js"><link rel="prefetch" href="/assets/js/51.a6467e5a.js"><link rel="prefetch" href="/assets/js/52.bca0677a.js"><link rel="prefetch" href="/assets/js/53.efb607ef.js"><link rel="prefetch" href="/assets/js/54.f97fdca9.js"><link rel="prefetch" href="/assets/js/55.776dd013.js"><link rel="prefetch" href="/assets/js/56.14b8106f.js"><link rel="prefetch" href="/assets/js/57.e6f38049.js"><link rel="prefetch" href="/assets/js/58.8dfbde6f.js"><link rel="prefetch" href="/assets/js/59.fb18a870.js"><link rel="prefetch" href="/assets/js/6.3e294312.js"><link rel="prefetch" href="/assets/js/60.576a580b.js"><link rel="prefetch" href="/assets/js/61.675d5879.js"><link rel="prefetch" href="/assets/js/62.e163c19b.js"><link rel="prefetch" href="/assets/js/63.8a001f9f.js"><link rel="prefetch" href="/assets/js/64.d1279444.js"><link rel="prefetch" href="/assets/js/65.c8b98d33.js"><link rel="prefetch" href="/assets/js/66.a0a23461.js"><link rel="prefetch" href="/assets/js/67.7796453d.js"><link rel="prefetch" href="/assets/js/68.ca84c529.js"><link rel="prefetch" href="/assets/js/69.796e84dd.js"><link rel="prefetch" href="/assets/js/7.c14eb7da.js"><link rel="prefetch" href="/assets/js/70.e98aced0.js"><link rel="prefetch" href="/assets/js/71.2c59709f.js"><link rel="prefetch" href="/assets/js/72.56c74789.js"><link rel="prefetch" href="/assets/js/73.ed9f4e6c.js"><link rel="prefetch" href="/assets/js/74.233089e2.js"><link rel="prefetch" href="/assets/js/75.10f38919.js"><link rel="prefetch" href="/assets/js/76.60753e78.js"><link rel="prefetch" href="/assets/js/77.f2c3ef83.js"><link rel="prefetch" href="/assets/js/78.d2688ba7.js"><link rel="prefetch" href="/assets/js/79.b2798fbe.js"><link rel="prefetch" href="/assets/js/8.c6c39088.js"><link rel="prefetch" href="/assets/js/80.3fa483ae.js"><link rel="prefetch" href="/assets/js/81.61685b7e.js"><link rel="prefetch" href="/assets/js/82.69d15ff4.js"><link rel="prefetch" href="/assets/js/84.02b4580f.js"><link rel="prefetch" href="/assets/js/85.b7c693a3.js"><link rel="prefetch" href="/assets/js/86.052d99af.js"><link rel="prefetch" href="/assets/js/87.5189e06b.js"><link rel="prefetch" href="/assets/js/88.08198244.js"><link rel="prefetch" href="/assets/js/89.38ab98a9.js"><link rel="prefetch" href="/assets/js/9.ac040250.js"><link rel="prefetch" href="/assets/js/90.a2d1dbf8.js"><link rel="prefetch" href="/assets/js/91.c817d61c.js"><link rel="prefetch" href="/assets/js/92.7dcadda2.js"><link rel="prefetch" href="/assets/js/93.34fbf9a9.js"><link rel="prefetch" href="/assets/js/94.ca7bf5ef.js"><link rel="prefetch" href="/assets/js/95.2df48583.js"><link rel="prefetch" href="/assets/js/96.522ee696.js"><link rel="prefetch" href="/assets/js/97.69c57513.js"><link rel="prefetch" href="/assets/js/98.80f0eb66.js"><link rel="prefetch" href="/assets/js/99.68b6a492.js"> <link rel="stylesheet" href="/assets/css/0.styles.bf298c27.css">
    <script type="text/javascript">
      window.addEventListener("load", function () {
        var isMobile =
          !!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
            navigator.userAgent
          );
        // PC端显示 3D 地球
        if (!isMobile) document.getElementById("maps").style.display = "inline";
      });
    </script>
  </head>

  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-4f9c9c87><div data-v-4f9c9c87><div class="password-shadow password-wrapper-out" style="display:none;" data-v-06dbc5d6 data-v-4f9c9c87 data-v-4f9c9c87><h3 class="title" data-v-06dbc5d6 data-v-06dbc5d6>Week.D.Awn</h3> <p class="description" data-v-06dbc5d6 data-v-06dbc5d6>Things Aren't Always What You Seem</p> <label id="box" class="inputBox" data-v-06dbc5d6 data-v-06dbc5d6><input type="password" value="" data-v-06dbc5d6> <span data-v-06dbc5d6>Konck! Knock!</span> <button data-v-06dbc5d6>OK</button></label> <div class="footer" data-v-06dbc5d6 data-v-06dbc5d6><span data-v-06dbc5d6><i class="iconfont reco-theme" data-v-06dbc5d6></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-06dbc5d6>vuePress-theme-reco</a></span> <span data-v-06dbc5d6><i class="iconfont reco-copyright" data-v-06dbc5d6></i> <a data-v-06dbc5d6><span data-v-06dbc5d6>Week.D.Awn</span>
            
          <!---->
          2022
        </a></span></div></div> <div class="hide" data-v-4f9c9c87><header class="navbar" data-v-4f9c9c87><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/vuepress/head.jpg" alt="Week.D.Awn" class="logo"> <span class="site-name">Week.D.Awn</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-blog"></i>
      领域
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>专业</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blogs/前端/" class="nav-link"><i class="iconfont reco-api"></i>
  前端
</a></li><li class="dropdown-subitem"><a href="/blogs/后端/" class="nav-link"><i class="iconfont reco-api"></i>
  后端
</a></li><li class="dropdown-subitem"><a href="/blogs/AI/" class="nav-link"><i class="iconfont reco-coding"></i>
  AI
</a></li><li class="dropdown-subitem"><a href="/others/projects.html" class="nav-link"><i class="iconfont reco-other"></i>
  收藏
</a></li><li class="dropdown-subitem"><a href="/blogs/其他/" class="nav-link router-link-active"><i class="iconfont reco-other"></i>
  其他
</a></li></ul></li></ul></div></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间线
</a></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="https://travellings.link" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-account"></i>
  开往
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="/bookmarks/常用/常用网址.html" class="nav-link"><i class="iconfont reco-tag"></i>
  收藏
</a></div><div class="nav-item"><a href="/about/" class="nav-link"><i class="iconfont reco-account"></i>
  关于我
</a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-4f9c9c87></div> <aside class="sidebar" data-v-4f9c9c87><div class="personal-info-wrapper" data-v-ad235a34 data-v-4f9c9c87><img src="/vuepress/head.jpg" alt="author-avatar" class="personal-img" data-v-ad235a34> <h3 class="name" data-v-ad235a34>
    Week.D.Awn
  </h3> <div class="num" data-v-ad235a34><div data-v-ad235a34><h3 data-v-ad235a34>78</h3> <h6 data-v-ad235a34>Articles</h6></div> <div data-v-ad235a34><h3 data-v-ad235a34>82</h3> <h6 data-v-ad235a34>Tags</h6></div></div> <ul class="social-links" data-v-ad235a34></ul> <hr data-v-ad235a34></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-blog"></i>
      领域
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>专业</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blogs/前端/" class="nav-link"><i class="iconfont reco-api"></i>
  前端
</a></li><li class="dropdown-subitem"><a href="/blogs/后端/" class="nav-link"><i class="iconfont reco-api"></i>
  后端
</a></li><li class="dropdown-subitem"><a href="/blogs/AI/" class="nav-link"><i class="iconfont reco-coding"></i>
  AI
</a></li><li class="dropdown-subitem"><a href="/others/projects.html" class="nav-link"><i class="iconfont reco-other"></i>
  收藏
</a></li><li class="dropdown-subitem"><a href="/blogs/其他/" class="nav-link router-link-active"><i class="iconfont reco-other"></i>
  其他
</a></li></ul></li></ul></div></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间线
</a></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="https://travellings.link" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-account"></i>
  开往
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="/bookmarks/常用/常用网址.html" class="nav-link"><i class="iconfont reco-tag"></i>
  收藏
</a></div><div class="nav-item"><a href="/about/" class="nav-link"><i class="iconfont reco-account"></i>
  关于我
</a></div> <!----></nav> <ul class="sidebar-links"><li><a href="/blogs/其他/" aria-current="page" class="sidebar-link">其他</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>笔记</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blogs/其他/笔记/markdown语法.html" class="sidebar-link">markdown语法</a></li><li><a href="/blogs/其他/笔记/正则表达式语法.html" class="sidebar-link">正则表达式语法</a></li><li><a href="/blogs/其他/笔记/常用正则表达式.html" class="sidebar-link">常用正则表达式</a></li><li><a href="/blogs/其他/笔记/常用bat命令.html" class="sidebar-link">常用bat命令</a></li><li><a href="/blogs/其他/笔记/linux常用命令.html" class="sidebar-link">linux常用命令</a></li><li><a href="/blogs/其他/笔记/npm和yarn常用命令.html" class="sidebar-link">npm和yarn常用命令</a></li><li><a href="/blogs/其他/笔记/npm常用命令.html" class="sidebar-link">npm常用命令</a></li><li><a href="/blogs/其他/笔记/conda命令.html" class="sidebar-link">conda命令</a></li><li><a href="/blogs/其他/笔记/Scala学习笔记.html" aria-current="page" class="active sidebar-link">Scala学习笔记</a></li><li><a href="/blogs/其他/笔记/bat批处理语法.html" class="sidebar-link">bat批处理语法</a></li><li><a href="/blogs/其他/笔记/git常用命令速查.html" class="sidebar-link">git常用命令速查</a></li><li><a href="/blogs/其他/笔记/git手册.html" class="sidebar-link">git手册</a></li><li><a href="/blogs/其他/笔记/git提交规范.html" class="sidebar-link">git提交规范</a></li><li><a href="/blogs/其他/笔记/k8s基本命令与pod管理.html" class="sidebar-link">k8s基本命令与pod管理</a></li><li><a href="/blogs/其他/笔记/py3和py2的区别总结.html" class="sidebar-link">python3和python2的区别总结</a></li><li><a href="/blogs/其他/笔记/ss.html" class="sidebar-link">ss服务端配置</a></li><li><a href="/blogs/其他/笔记/yaml学习笔记.html" class="sidebar-link">yaml学习笔记</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>教程</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>解决方案</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>复习</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>其他</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-06dbc5d6 data-v-4f9c9c87><h3 class="title" data-v-06dbc5d6 data-v-06dbc5d6>Scala学习笔记</h3> <!----> <label id="box" class="inputBox" data-v-06dbc5d6 data-v-06dbc5d6><input type="password" value="" data-v-06dbc5d6> <span data-v-06dbc5d6>Konck! Knock!</span> <button data-v-06dbc5d6>OK</button></label> <div class="footer" data-v-06dbc5d6 data-v-06dbc5d6><span data-v-06dbc5d6><i class="iconfont reco-theme" data-v-06dbc5d6></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-06dbc5d6>vuePress-theme-reco</a></span> <span data-v-06dbc5d6><i class="iconfont reco-copyright" data-v-06dbc5d6></i> <a data-v-06dbc5d6><span data-v-06dbc5d6>Week.D.Awn</span>
            
          <!---->
          2022
        </a></span></div></div> <div data-v-4f9c9c87><main class="page"><section><div class="page-title"><h1 class="title">Scala学习笔记</h1> <div data-v-da1c0c82><i class="iconfont reco-account" data-v-da1c0c82><span data-v-da1c0c82>Week.D.Awn</span></i> <i class="iconfont reco-date" data-v-da1c0c82><span data-v-da1c0c82>7/18/2020</span></i> <i class="iconfont reco-eye" data-v-da1c0c82><span id="/blogs/其他/笔记/Scala学习笔记.html" data-flag-title="Your Article Title" class="leancloud-visitors" data-v-da1c0c82><a class="leancloud-visitors-count" style="font-size:.9rem;font-weight:normal;color:#999;"></a></span></i> <i class="tags iconfont reco-tag" data-v-da1c0c82><span class="tag-item" data-v-da1c0c82>scala</span></i></div></div> <div class="theme-reco-content content__default"><h3 id="简介"><a href="#简介" class="header-anchor">#</a> 简介</h3> <blockquote><p>Scala 是 Scalable Language 的简写，是一门多范式的编程语言</p> <p>联邦理工学院洛桑（EPFL）的Martin Odersky于2001年基于Funnel的工作开始设计Scala。</p> <p>Funnel是把函数式编程思想和Petri网相结合的一种编程语言。</p></blockquote> <h3 id="scala特性"><a href="#scala特性" class="header-anchor">#</a> Scala特性</h3> <blockquote><h4 id="面向对象特性"><a href="#面向对象特性" class="header-anchor">#</a> 面向对象特性</h4> <p>Scala是一种纯面向对象的语言，每个值都是对象。对象的数据类型以及行为由类和特质描述。</p> <p>类抽象机制的扩展有两种途径：一种途径是子类继承，另一种途径是灵活的混入机制。这两种途径能避免多重继承的种种问题。</p> <h4 id="函数式编程"><a href="#函数式编程" class="header-anchor">#</a> 函数式编程</h4> <p>Scala也是一种函数式语言，其函数也能当成值来使用。Scala提供了轻量级的语法用以定义匿名函数，支持高阶函数，允许嵌套多层函数，并支持柯里化。Scala的case class及其内置的模式匹配相当于函数式编程语言中常用的代数类型。</p> <p>更进一步，程序员可以利用Scala的模式匹配，编写类似正则表达式的代码处理XML数据。</p> <h4 id="静态类型"><a href="#静态类型" class="header-anchor">#</a> 静态类型</h4> <p>Scala具备类型系统，通过编译时检查，保证代码的安全性和一致性。</p> <h3 id="扩展性"><a href="#扩展性" class="header-anchor">#</a> 扩展性</h3> <p>Scala的设计秉承一项事实，即在实践中，某个领域特定的应用程序开发往往需要特定于该领域的语言扩展。Scala提供了许多独特的语言机制，可以以库的形式轻易无缝添加新的语言结构：</p> <ul><li>任何方法可用作前缀或后缀操作符</li> <li>可以根据预期类型自动构造闭包。</li></ul> <h3 id="并发性"><a href="#并发性" class="header-anchor">#</a> 并发性</h3> <p>Scala使用Actor作为其并发模型，Actor是类似线程的实体，通过邮箱发收消息。Actor可以复用线程，因此可以在程序中可以使用数百万个Actor,而线程只能创建数千个。在2.10之后的版本中，使用Akka作为其默认Actor实现。</p> <h3 id="谁使用了-scala"><a href="#谁使用了-scala" class="header-anchor">#</a> 谁使用了 Scala</h3> <ul><li>2009年4月，Twitter宣布他们已经把大部分后端程序从Ruby迁移到Scala，其余部分也打算要迁移。</li> <li>此外，Wattzon已经公开宣称，其整个平台都已经是基于Scala基础设施编写的。</li> <li>瑞银集团把Scala用于一般产品中。</li> <li>Coursera把Scala作为服务器语言使用。</li></ul></blockquote> <h3 id="基础语法"><a href="#基础语法" class="header-anchor">#</a> 基础语法</h3> <blockquote><p>Scala 与 Java 的最大区别是：Scala 语句末尾的分号 ; 是可选的。</p> <p>scala的helloworld.scala</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>object HelloWorld {
   /* 这是我的第一个 Scala 程序
    * 以下程序将输出'Hello World!' 
    */
   def main(args: Array[String]) {
      println(&quot;Hello, world!&quot;) // 输出 Hello World
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div></blockquote> <h4 id="基本语法需要注意以下几点"><a href="#基本语法需要注意以下几点" class="header-anchor">#</a> 基本语法需要注意以下几点：</h4> <blockquote><ul><li><p><strong>区分大小写</strong> -  Scala是大小写敏感的，这意味着标识Hello 和 hello在Scala中会有不同的含义。</p></li> <li><p><strong>类名</strong> - 对于所有的类名的第一个字母要大写。
如果需要使用几个单词来构成一个类的名称，每个单词的第一个字母要大写。</p> <p>示例：<em>class MyFirstScalaClass</em></p></li> <li><p><strong>方法名称</strong> - 所有的方法名称的第一个字母用小写。
如果若干单词被用于构成方法的名称，则每个单词的第一个字母应大写。</p> <p>示例：<em>def myMethodName()</em></p></li> <li><p><strong>程序文件名</strong> - 程序文件的名称应该与对象名称完全匹配(新版本不需要了，但建议保留这种习惯)。
保存文件时，应该保存它使用的对象名称（记住Scala是区分大小写），并追加&quot;.scala&quot;为文件扩展名。 （如果文件名和对象名称不匹配，程序将无法编译）。</p> <p>示例: 假设&quot;HelloWorld&quot;是对象的名称。那么该文件应保存为'HelloWorld.scala&quot;</p></li> <li><p><strong>def main(args: Array[String])</strong> - Scala程序从main()方法开始处理，这是每一个Scala程序的强制程序入口部分。</p></li></ul></blockquote> <h4 id="标识符"><a href="#标识符" class="header-anchor">#</a> 标识符</h4> <blockquote><p>Scala 可以使用两种形式的标志符，字符数字和符号。</p> <p>字符数字使用字母或是下划线开头，后面可以接字母或是数字，符号&quot;$&quot;在 Scala 中也看作为字母。然而以&quot;$&quot;开头的标识符为保留的 Scala 编译器产生的标志符使用，应用程序应该避免使用&quot;$&quot;开始的标识符，以免造成冲突。</p> <p>Scala 的命名规则采用和 Java 类似的 camel 命名规则，首字符小写，比如 toString。类名的首字符还是使用大写。此外也应该避免使用以下划线结尾的标志符以避免冲突。符号标志符包含一个或多个符号，如+，:，? 等</p></blockquote> <h4 id="关键字"><a href="#关键字" class="header-anchor">#</a> 关键字</h4> <blockquote><table><thead><tr><th></th> <th></th> <th></th> <th></th></tr></thead> <tbody><tr><td>abstract</td> <td>case</td> <td>catch</td> <td>class</td></tr> <tr><td>def</td> <td>do</td> <td>else</td> <td>extends</td></tr> <tr><td>false</td> <td>final</td> <td>finally</td> <td>for</td></tr> <tr><td>forSome</td> <td>if</td> <td>implicit</td> <td>import</td></tr> <tr><td>lazy</td> <td>match</td> <td>new</td> <td>null</td></tr> <tr><td>object</td> <td>override</td> <td>package</td> <td>private</td></tr> <tr><td>protected</td> <td>return</td> <td>sealed</td> <td>super</td></tr> <tr><td>this</td> <td>throw</td> <td>trait</td> <td>try</td></tr> <tr><td>true</td> <td>type</td> <td>val</td> <td>var</td></tr> <tr><td>while</td> <td>with</td> <td>yield</td> <td></td></tr> <tr><td>-</td> <td>:</td> <td>=</td> <td>=&gt;</td></tr> <tr><td>&lt;-</td> <td>&lt;:</td> <td>&lt;%</td> <td>&gt;:</td></tr> <tr><td>#</td> <td>@</td> <td></td> <td></td></tr></tbody></table></blockquote> <h4 id="注释"><a href="#注释" class="header-anchor">#</a> 注释</h4> <blockquote><p>// 或者/*  */</p></blockquote> <h4 id="空行和空格"><a href="#空行和空格" class="header-anchor">#</a> 空行和空格</h4> <blockquote><p>一行中只有空格或者带有注释，Scala 会认为其是空行，会忽略它。标记可以被空格或者注释来分割。</p></blockquote> <h4 id="换行符"><a href="#换行符" class="header-anchor">#</a> 换行符</h4> <blockquote><p>Scala是面向行的语言，语句可以用分号（;）结束或换行符。Scala 程序里,语句末尾的分号通常是可选的。如果你愿意可以输入一个,但若一行里仅 有一个语句也可不写。另一方面,如果一行里写多个语句那么分号是需要的。例如</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>val s = &quot;weekdawn&quot;; println(s)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></blockquote> <h4 id="scala包"><a href="#scala包" class="header-anchor">#</a> Scala包</h4> <blockquote><p>Scala 使用 package 关键字定义包，在Scala将代码定义到某个包中有两种方式：</p> <p>第一种方法和 Java 一样，在文件的头定义包名，这种方法就后续所有代码都放在该包中。 比如：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>package com.runoob
class HelloWorld
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>第二种方法有些类似 C#，如：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>package com.runoob {
  class HelloWorld 
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>第二种方法，可以在一个文件中定义多个包。</p></blockquote> <h4 id="引用"><a href="#引用" class="header-anchor">#</a> 引用</h4> <blockquote><p>Scala 使用 import 关键字引用包。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>import java.awt.Color  // 引入Color
 
import java.awt._  // 引入包内所有成员
 
def handler(evt: event.ActionEvent) { // java.awt.event.ActionEvent
  ...  // 因为引入了java.awt，所以可以省去前面的部分
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>import语句可以出现在任何地方，而不是只能在文件顶部。import的效果从开始延伸到语句块的结束。这可以大幅减少名称冲突的可能性。</p> <p>如果想要引入包中的几个成员，可以使用selector（选取器）：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>import java.awt.{Color, Font}
 
// 重命名成员
import java.util.{HashMap =&gt; JavaHashMap}
 
// 隐藏成员
import java.util.{HashMap =&gt; _, _} // 引入了util包的所有成员，但是HashMap被隐藏了
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><blockquote><p>**注意：**默认情况下，Scala 总会引入 java.lang._ 、 scala._ 和 Predef._，这里也能解释，为什么以scala开头的包，在使用时都是省去scala.的。</p></blockquote></blockquote> <h3 id="scala数据类型"><a href="#scala数据类型" class="header-anchor">#</a> Scala数据类型</h3> <blockquote><table><thead><tr><th style="text-align:left;">数据类型</th> <th style="text-align:left;">描述</th></tr></thead> <tbody><tr><td style="text-align:left;">Byte</td> <td style="text-align:left;">8位有符号补码整数。数值区间为 -128 到 127</td></tr> <tr><td style="text-align:left;">Short</td> <td style="text-align:left;">16位有符号补码整数。数值区间为 -32768 到 32767</td></tr> <tr><td style="text-align:left;">Int</td> <td style="text-align:left;">32位有符号补码整数。数值区间为 -2147483648 到 2147483647</td></tr> <tr><td style="text-align:left;">Long</td> <td style="text-align:left;">64位有符号补码整数。数值区间为 -9223372036854775808 到 9223372036854775807</td></tr> <tr><td style="text-align:left;">Float</td> <td style="text-align:left;">32 位, IEEE 754 标准的单精度浮点数</td></tr> <tr><td style="text-align:left;">Double</td> <td style="text-align:left;">64 位 IEEE 754 标准的双精度浮点数</td></tr> <tr><td style="text-align:left;">Char</td> <td style="text-align:left;">16位无符号Unicode字符, 区间值为 U+0000 到 U+FFFF</td></tr> <tr><td style="text-align:left;">String</td> <td style="text-align:left;">字符序列</td></tr> <tr><td style="text-align:left;">Boolean</td> <td style="text-align:left;">true或false</td></tr> <tr><td style="text-align:left;">Unit</td> <td style="text-align:left;">表示无值，和其他语言中void等同。用作不返回任何结果的方法的结果类型。Unit只有一个实例值，写成()。</td></tr> <tr><td style="text-align:left;">Null</td> <td style="text-align:left;">null 或空引用</td></tr> <tr><td style="text-align:left;">Nothing</td> <td style="text-align:left;">Nothing类型在Scala的类层级的最低端；它是任何其他类型的子类型。</td></tr> <tr><td style="text-align:left;">Any</td> <td style="text-align:left;">Any是所有其他类的超类</td></tr> <tr><td style="text-align:left;">AnyRef</td> <td style="text-align:left;">AnyRef类是Scala里所有引用类(reference class)的基类</td></tr></tbody></table></blockquote> <h4 id="scala基础字面量"><a href="#scala基础字面量" class="header-anchor">#</a> Scala基础字面量</h4> <blockquote><h3 id="整型字面量"><a href="#整型字面量" class="header-anchor">#</a> 整型字面量</h3> <p>整型字面量用于 Int 类型，如果表示 Long，可以在数字后面添加 L 或者小写 l 作为后缀。：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>0
035
21 
0xFFFFFFFF 
0777L
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="浮点型字面量"><a href="#浮点型字面量" class="header-anchor">#</a> 浮点型字面量</h3> <p>如果浮点数后面有f或者F后缀时，表示这是一个Float类型，否则就是一个Double类型的。实例如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>0.0 
1e30f 
3.14159f 
1.0e100
.1
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="布尔型字面量"><a href="#布尔型字面量" class="header-anchor">#</a> 布尔型字面量</h3> <p>布尔型字面量有 true 和 false。</p> <h3 id="符号字面量"><a href="#符号字面量" class="header-anchor">#</a> 符号字面量</h3> <p>符号字面量被写成： <strong>'&lt;标识符&gt;</strong> ，这里 <strong>&lt;标识符&gt;</strong> 可以是任何字母或数字的标识（注意：不能以数字开头）。这种字面量被映射成预定义类scala.Symbol的实例。</p> <p>如： 符号字面量 <strong>'x****scala.Symbol(&quot;x&quot;)</strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>package scala
final case class Symbol private (name: String) {
   override def toString: String = &quot;'&quot; + name
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="字符字面量"><a href="#字符字面量" class="header-anchor">#</a> 字符字面量</h3> <p>在 Scala 字符变量使用单引号 <strong>'</strong> 来定义，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>'a' 
'\u0041'
'\n'
'\t'
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>其中 *<em>*</em> 表示转义字符，其后可以跟 <strong>u0041</strong> 数字或者 <strong>\r\n</strong> 等固定的转义字符。</p> <h3 id="字符串字面量"><a href="#字符串字面量" class="header-anchor">#</a> 字符串字面量</h3> <p>在 Scala 字符串变量使用双引号 <strong>&quot;</strong> 来定义，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&quot;Hello,\nWorld!&quot;
&quot;菜鸟教程官网：www.runoob.com&quot;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="多行字符串的表示方法"><a href="#多行字符串的表示方法" class="header-anchor">#</a> 多行字符串的表示方法</h3> <p>多行字符串用三个双引号来表示分隔符，格式为：<strong>&quot;&quot;&quot; ... &quot;&quot;&quot;</strong>。</p> <p>实例如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>val foo = &quot;&quot;&quot;菜鸟教程
www.runoob.com
www.w3cschool.cc
www.runnoob.com
以上三个地址都能访问&quot;&quot;&quot;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="null-值"><a href="#null-值" class="header-anchor">#</a> Null 值</h3> <p>空值是 scala.Null 类型。</p> <p>Scala.Null和scala.Nothing是用统一的方式处理Scala面向对象类型系统的某些&quot;边界情况&quot;的特殊类型。</p> <p>Null类是null引用对象的类型，它是每个引用类（继承自AnyRef的类）的子类。Null不兼容值类型。</p></blockquote> <h4 id="转义字符"><a href="#转义字符" class="header-anchor">#</a> 转义字符</h4> <blockquote><table><thead><tr><th style="text-align:left;">转义字符</th> <th style="text-align:left;">Unicode</th> <th style="text-align:left;">描述</th></tr></thead> <tbody><tr><td style="text-align:left;">\b</td> <td style="text-align:left;">\u0008</td> <td style="text-align:left;">退格(BS) ，将当前位置移到前一列</td></tr> <tr><td style="text-align:left;">\t</td> <td style="text-align:left;">\u0009</td> <td style="text-align:left;">水平制表(HT) （跳到下一个TAB位置）</td></tr> <tr><td style="text-align:left;">\n</td> <td style="text-align:left;">\u000a</td> <td style="text-align:left;">换行(LF) ，将当前位置移到下一行开头</td></tr> <tr><td style="text-align:left;">\f</td> <td style="text-align:left;">\u000c</td> <td style="text-align:left;">换页(FF)，将当前位置移到下页开头</td></tr> <tr><td style="text-align:left;">\r</td> <td style="text-align:left;">\u000d</td> <td style="text-align:left;">回车(CR) ，将当前位置移到本行开头</td></tr> <tr><td style="text-align:left;">&quot;</td> <td style="text-align:left;">\u0022</td> <td style="text-align:left;">代表一个双引号(&quot;)字符</td></tr> <tr><td style="text-align:left;">'</td> <td style="text-align:left;">\u0027</td> <td style="text-align:left;">代表一个单引号（'）字符</td></tr> <tr><td style="text-align:left;">\</td> <td style="text-align:left;">\u005c</td> <td style="text-align:left;">代表一个反斜线字符 ''</td></tr></tbody></table></blockquote> <h3 id="scala变量"><a href="#scala变量" class="header-anchor">#</a> Scala变量</h3> <blockquote><p>在 Scala 中，使用关键词 <strong>&quot;var&quot;</strong> 声明变量，使用关键词 <strong>&quot;val&quot;</strong> 声明常量。</p> <p>声明变量实例如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var myVar : String = &quot;Foo&quot;
var myVar : String = &quot;Too&quot;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>以上定义了变量 myVar，我们可以修改它。</p> <p>声明常量实例如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>val myVal : String = &quot;Foo&quot;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>以上定义了常量 myVal，它是不能修改的。如果程序尝试修改常量 myVal 的值，程序将会在编译时报错。</p></blockquote> <h4 id="变量类型声明"><a href="#变量类型声明" class="header-anchor">#</a> 变量类型声明</h4> <blockquote><p>变量的类型在变量名之后等号之前声明。定义变量的类型的语法格式如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var VariableName : DataType [=  Initial Value]

或

val VariableName : DataType [=  Initial Value]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></blockquote> <h4 id="变量类型引用"><a href="#变量类型引用" class="header-anchor">#</a> 变量类型引用</h4> <blockquote><p>在 Scala 中声明变量和常量不一定要指明数据类型，在没有指明数据类型的情况下，其数据类型是通过变量或常量的初始值推断出来的。</p> <p>所以，如果在没有指明数据类型的情况下声明变量或常量必须要给出其初始值，否则将会报错。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var myVar = 10;
val myVal = &quot;Hello, Scala!&quot;;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>以上实例中，myVar 会被推断为 Int 类型，myVal 会被推断为 String 类型。</p></blockquote> <h4 id="scala多个变量声明"><a href="#scala多个变量声明" class="header-anchor">#</a> Scala多个变量声明</h4> <blockquote><p>Scala 支持多个变量的声明：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>val xmax, ymax = 100  // xmax, ymax都声明为100
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>如果方法返回值是元组，我们可以使用 val 来声明一个元组：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>scala&gt; val pa = (40,&quot;Foo&quot;)
pa: (Int, String) = (40,Foo)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></blockquote> <h3 id="scala访问修饰符"><a href="#scala访问修饰符" class="header-anchor">#</a> Scala访问修饰符</h3> <blockquote><p>Scala 访问修饰符基本和Java的一样，分别有：private，protected，public。</p> <p>如果没有指定访问修饰符，默认情况下，Scala 对象的访问级别都是 public。</p> <p>Scala 中的 private 限定符，比 Java 更严格，在嵌套类情况下，外层类甚至不能访问被嵌套类的私有成员。</p></blockquote> <h4 id="private成员"><a href="#private成员" class="header-anchor">#</a> Private成员</h4> <blockquote><p>用 private 关键字修饰，带有此标记的成员<strong>仅在包含了成员定义的类或对象内部</strong>可见，同样的规则还适用内部类。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>class Outer{
    class Inner{
    private def f(){println(&quot;f&quot;)}
    class InnerMost{
        f() // 正确
        }
    }
    (new Inner).f() //错误
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></blockquote> <h4 id="protected成员"><a href="#protected成员" class="header-anchor">#</a> Protected成员</h4> <blockquote><p>在 scala 中，对保护（Protected）成员的访问比 java 更严格一些。因为它只允许保护成员在定义了该成员的的<strong>类的子类中被访问</strong>。而在java中，用protected关键字修饰的成员，除了定义了该成员的类的子类可以访问，同一个包里的其他类也可以进行访问。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>package p{
class Super{
    protected def f() {println(&quot;f&quot;)}
    }
    class Sub extends Super{
        f()
    }
    class Other{
        (new Super).f() //错误
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div></blockquote> <h4 id="public成员"><a href="#public成员" class="header-anchor">#</a> Public成员</h4> <blockquote><p>Scala中，如果没有指定任何的修饰符，则默认为 public。这样的成员在任何地方都可以被访问。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>class Outer {
   class Inner {
      def f() { println(&quot;f&quot;) }
      class InnerMost {
         f() // 正确
      }
   }
   (new Inner).f() // 正确因为 f() 是 public
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></blockquote> <h3 id="scala运算符"><a href="#scala运算符" class="header-anchor">#</a> Scala运算符</h3> <blockquote><p>略</p></blockquote> <h3 id="scala-if-else"><a href="#scala-if-else" class="header-anchor">#</a> Scala IF...ELSE</h3> <blockquote><p>略</p></blockquote> <h3 id="scala循环"><a href="#scala循环" class="header-anchor">#</a> Scala循环</h3> <blockquote><h4 id="for循环"><a href="#for循环" class="header-anchor">#</a> For循环</h4> <p>Scala 语言中 <strong>for</strong> 循环的语法：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>for( var x &lt;- Range ){
   statement(s);
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>以上语法中，<strong>Range</strong> 可以是一个数字区间表示 <strong>i to j</strong> ，或者 <strong>i until j</strong>。左箭头 &lt;- 用于为变量 x 赋值。</p> <h3 id="实例"><a href="#实例" class="header-anchor">#</a> 实例</h3> <p>以下是一个使用了 <strong>i to j</strong> 语法(包含 j)的实例:</p> <div class="language-scala line-numbers-mode"><pre class="language-scala"><code><span class="token keyword">object</span> Test <span class="token punctuation">{</span>
   <span class="token keyword">def</span> main<span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      <span class="token comment">// for 循环</span>
      <span class="token keyword">for</span><span class="token punctuation">(</span> a <span class="token keyword">&lt;-</span> <span class="token number">1</span> to <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
         println<span class="token punctuation">(</span> <span class="token string">&quot;Value of a: &quot;</span> <span class="token operator">+</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></blockquote> <blockquote><p>以下是一个使用了 <strong>i until j</strong> 语法(不包含 j)的实例:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>object Test {
   def main(args: Array[String]) {
      var a = 0;
      // for 循环
      for( a &lt;- 1 until 10){
         println( &quot;Value of a: &quot; + a );
      }
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></blockquote> <blockquote><p>在 <strong>for 循环</strong> 中你可以使用分号 (😉 来设置多个区间，它将迭代给定区间所有的可能值。以下实例演示了两个区间的循环实例：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>object Test {
   def main(args: Array[String]) {
      var a = 0;
      var b = 0;
      // for 循环
      for( a &lt;- 1 to 3; b &lt;- 1 to 3){
         println( &quot;Value of a: &quot; + a );
         println( &quot;Value of b: &quot; + b );
      }
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div></blockquote> <blockquote><h2 id="for-循环集合"><a href="#for-循环集合" class="header-anchor">#</a> for 循环集合</h2> <p>for 循环集合的语法如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>for( var x &lt;- List ){
   statement(s);
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>以上语法中， <strong>List</strong> 变量是一个集合，for 循环会迭代所有集合的元素。</p> <h3 id="实例-2"><a href="#实例-2" class="header-anchor">#</a> 实例</h3> <p>以下实例将循环数字集合。我们使用 <em>List()</em> 来创建集合。再以后章节我们会详细介绍集合。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>object Test {
   def main(args: Array[String]) {
      var a = 0;
      val numList = List(1,2,3,4,5,6);

      // for 循环
      for( a &lt;- numList ){
         println( &quot;Value of a: &quot; + a );
      }
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div></blockquote> <blockquote><h2 id="for-循环过滤"><a href="#for-循环过滤" class="header-anchor">#</a> for 循环过滤</h2> <p>Scala 可以使用一个或多个 <strong>if</strong> 语句来过滤一些元素。</p> <p>以下是在 for 循环中使用过滤器的语法。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>for( var x &lt;- List
      if condition1; if condition2...
   ){
   statement(s);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>你可以使用分号(;)来为表达式添加一个或多个的过滤条件。</p> <h3 id="实例-3"><a href="#实例-3" class="header-anchor">#</a> 实例</h3> <p>以下是 for 循环中过滤的实例：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>object Test {
   def main(args: Array[String]) {
      var a = 0;
      val numList = List(1,2,3,4,5,6,7,8,9,10);

      // for 循环
      for( a &lt;- numList
           if a != 3; if a &lt; 8 ){
         println( &quot;Value of a: &quot; + a );
      }
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div></blockquote> <blockquote><h2 id="for-使用-yield"><a href="#for-使用-yield" class="header-anchor">#</a> for 使用 yield</h2> <p>你可以将 for 循环的返回值作为一个变量存储。语法格式如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var retVal = for{ var x &lt;- List
     if condition1; if condition2...
}yield x
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>注意大括号中用于保存变量和条件，<em>retVal</em> 是变量， 循环中的 yield 会把当前的元素记下来，保存在集合中，循环结束后将返回该集合。</p> <h3 id="实例-4"><a href="#实例-4" class="header-anchor">#</a> 实例</h3> <p>以下实例演示了 for 循环中使用 yield：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>object Test {
   def main(args: Array[String]) {
      var a = 0;
      val numList = List(1,2,3,4,5,6,7,8,9,10);

      // for 循环
      var retVal = for{ a &lt;- numList 
                        if a != 3; if a &lt; 8
                      }yield a

      // 输出返回值
      for( a &lt;- retVal){
         println( &quot;Value of a: &quot; + a );
      }
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div></blockquote> <h3 id="scala方法与函数"><a href="#scala方法与函数" class="header-anchor">#</a> Scala方法与函数</h3> <blockquote><p>Scala 有方法与函数，二者在语义上的区别很小。Scala 方法是类的一部分，而函数是一个对象可以赋值给一个变量。换句话来说在类中定义的函数即是方法。</p> <p>Scala 中的方法跟 Java 的类似，方法是组成类的一部分。</p> <p>Scala 中的函数则是一个完整的对象，Scala 中的函数其实就是继承了 Trait 的类的对象。</p> <p>Scala 中使用 <strong>val</strong> 语句可以定义函数，<strong>def</strong> 语句定义方法。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>class Test{
  def m(x: Int) = x + 3
  val f = (x: Int) =&gt; x + 3
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></blockquote> <h4 id="方法声明"><a href="#方法声明" class="header-anchor">#</a> 方法声明</h4> <blockquote><p>Scala 方法声明格式如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>def functionName ([参数列表]) : [return type]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>如果你不写等于号和方法主体，那么方法会被隐式声明为<strong>抽象(abstract)</strong>，包含它的类型于是也是一个抽象类型。</p></blockquote> <h4 id="方法定义"><a href="#方法定义" class="header-anchor">#</a> 方法定义</h4> <blockquote><p>方法定义由一个 <strong>def</strong> 关键字开始，紧接着是可选的参数列表，一个冒号 <strong>:</strong> 和方法的返回类型，一个等于号 <strong>=</strong> ，最后是方法的主体。</p> <p>Scala 方法定义格式如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>def functionName ([参数列表]) : [return type] = {
   function body
   return [expr]
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>以上代码中 <strong>return type</strong> 可以是任意合法的 Scala 数据类型。参数列表中的参数可以使用逗号分隔。</p> <p>以下方法的功能是将两个传入的参数相加并求和：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>object add{
   def addInt( a:Int, b:Int ) : Int = {
      var sum:Int = 0
      sum = a + b

      return sum
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>如果方法没有返回值，可以返回为 <strong>Unit</strong>，这个类似于 Java 的 <strong>void</strong>, 实例如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>object Hello{
   def printMe( ) : Unit = {
      println(&quot;Hello, Scala!&quot;)
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></blockquote> <h4 id="方法调用"><a href="#方法调用" class="header-anchor">#</a> 方法调用</h4> <blockquote><p>Scala 提供了多种不同的方法调用方式：</p> <p>以下是调用方法的标准格式：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>functionName( 参数列表 )
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>如果方法使用了实例的对象来调用，我们可以使用类似java的格式 (使用 <strong>.</strong> 号)：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>[instance.]functionName( 参数列表 )
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>以上实例演示了定义与调用方法的实例:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>object Test {
   def main(args: Array[String]) {
        println( &quot;Returned Value : &quot; + addInt(5,7) );
   }
   def addInt( a:Int, b:Int ) : Int = {
      var sum:Int = 0
      sum = a + b

      return sum
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div></blockquote> <h4 id="scala闭包"><a href="#scala闭包" class="header-anchor">#</a> Scala闭包</h4> <blockquote><p>闭包是一个函数，返回值依赖于声明在函数外部的一个或多个变量。</p> <p>闭包通常来讲可以简单的认为是可以访问一个函数里面局部变量的另外一个函数。</p> <p>如下面这段匿名的函数：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>val multiplier = (i:Int) =&gt; i * 10  
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>函数体内有一个变量 i，它作为函数的一个参数。如下面的另一段代码：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>val multiplier = (i:Int) =&gt; i * factor
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>在 multiplier 中有两个变量：i 和 factor。其中的一个 i 是函数的形式参数，在 multiplier 函数被调用时，i 被赋予一个新的值。然而，factor不是形式参数，而是自由变量，考虑下面代码：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var factor = 3  
val multiplier = (i:Int) =&gt; i * factor  
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这里我们引入一个自由变量 factor，这个变量定义在函数外面。</p> <p>这样定义的函数变量 multiplier 成为一个&quot;闭包&quot;，因为它引用到函数外面定义的变量，定义这个函数的过程是将这个自由变量捕获而构成一个封闭的函数。</p> <p>完整实例</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>object Test {  
   def main(args: Array[String]) {  
      println( &quot;muliplier(1) value = &quot; +  multiplier(1) )  
      println( &quot;muliplier(2) value = &quot; +  multiplier(2) )  
   }  
   var factor = 3  
   val multiplier = (i:Int) =&gt; i * factor  
}  
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div></blockquote> <h4 id="scala字符串"><a href="#scala字符串" class="header-anchor">#</a> Scala字符串</h4> <blockquote><p>以下实例将字符串赋值给一个常量：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>object Test {
   val greeting: String = &quot;Hello,World!&quot;

   def main(args: Array[String]) {
      println( greeting )
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>以上实例定义了变量 greeting，为字符串常量，它的类型为 String (java.lang.String)。</p> <p>在 Scala 中，字符串的类型实际上是 Java String，它本身没有 String 类。</p> <p>在 Scala 中，String 是一个不可变的对象，所以该对象不可被修改。这就意味着你如果修改字符串就会产生一个新的字符串对象。</p> <p>但其他对象，如数组就是可变的对象。接下来我们会为大家介绍常用的 java.lang.String 方法。</p></blockquote> <h4 id="创建字符串"><a href="#创建字符串" class="header-anchor">#</a> 创建字符串</h4> <blockquote><p>创建字符串实例如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var greeting = &quot;Hello World!&quot;;

或

var greeting:String = &quot;Hello World!&quot;;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>你不一定为字符串指定 String 类型，因为 Scala 编译器会自动推断出字符串的类型为 String。</p> <p>当然我们也可以直接显示的声明字符串为 String 类型，如下实例：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>object Test {
   val greeting: String = &quot;Hello, World!&quot;

   def main(args: Array[String]) {
      println( greeting )
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></blockquote> <blockquote><p>我们前面提到过 String 对象是不可变的，如果你需要创建一个可以修改的字符串，可以使用 String Builder 类，如下实例:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>object Test {
   def main(args: Array[String]) {
      val buf = new StringBuilder;
      buf += 'a'
      buf ++= &quot;bcdef&quot;
      println( &quot;buf is : &quot; + buf.toString );
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div></blockquote> <h4 id="字符串长度"><a href="#字符串长度" class="header-anchor">#</a> 字符串长度</h4> <blockquote><p>我们可以使用 length() 方法来获取字符串长度：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>object Test {
   def main(args: Array[String]) {
      var palindrome = &quot;www.runoob.com&quot;;
      var len = palindrome.length();
      println( &quot;String Length is : &quot; + len );
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></blockquote> <h4 id="字符串连接"><a href="#字符串连接" class="header-anchor">#</a> 字符串连接</h4> <blockquote><p>String 类中使用 concat() 方法来连接两个字符串：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>string1.concat(string2);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></blockquote> <blockquote><p>同样你也可以使用加号(+)来连接：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>scala&gt; &quot;weekdawn &quot; + &quot; yoyo&quot;
res1: String = weekdawn yoyo
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></blockquote> <h4 id="创建格式化字符串"><a href="#创建格式化字符串" class="header-anchor">#</a> 创建格式化字符串</h4> <blockquote><p>String 类中你可以使用 printf() 方法来格式化字符串并输出，String format() 方法可以返回 String 对象而不是 PrintStream 对象。以下实例演示了 printf() 方法的使用：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>object Test {
   def main(args: Array[String]) {
      var floatVar = 12.456
      var intVar = 2000
      var stringVar = &quot;菜鸟教程!&quot;
      var fs = printf(&quot;浮点型变量为 &quot; +
                   &quot;%f, 整型变量为 %d, 字符串为 &quot; +
                   &quot; %s&quot;, floatVar, intVar, stringVar)
      println(fs)
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div></blockquote> <h4 id="string方法"><a href="#string方法" class="header-anchor">#</a> String方法</h4> <blockquote><p>下表列出了 java.lang.String 中常用的方法，可以在 Scala 中使用：</p> <table><thead><tr><th style="text-align:left;">序号</th> <th style="text-align:left;">方法及描述</th></tr></thead> <tbody><tr><td style="text-align:left;">1</td> <td style="text-align:left;">**char charAt(int index)**返回指定位置的字符</td></tr> <tr><td style="text-align:left;">2</td> <td style="text-align:left;">**int compareTo(Object o)**比较字符串与对象</td></tr> <tr><td style="text-align:left;">3</td> <td style="text-align:left;">**int compareTo(String anotherString)**按字典顺序比较两个字符串</td></tr> <tr><td style="text-align:left;">4</td> <td style="text-align:left;">**int compareToIgnoreCase(String str)**按字典顺序比较两个字符串，不考虑大小写</td></tr> <tr><td style="text-align:left;">5</td> <td style="text-align:left;">**String concat(String str)**将指定字符串连接到此字符串的结尾</td></tr> <tr><td style="text-align:left;">6</td> <td style="text-align:left;">**boolean contentEquals(StringBuffer sb)**将此字符串与指定的 StringBuffer 比较。</td></tr> <tr><td style="text-align:left;">7</td> <td style="text-align:left;">**static String copyValueOf(char[] data)**返回指定数组中表示该字符序列的 String</td></tr> <tr><td style="text-align:left;">8</td> <td style="text-align:left;">**static String copyValueOf(char[] data, int offset, int count)**返回指定数组中表示该字符序列的 String</td></tr> <tr><td style="text-align:left;">9</td> <td style="text-align:left;">**boolean endsWith(String suffix)**测试此字符串是否以指定的后缀结束</td></tr> <tr><td style="text-align:left;">10</td> <td style="text-align:left;">**boolean equals(Object anObject)**将此字符串与指定的对象比较</td></tr> <tr><td style="text-align:left;">11</td> <td style="text-align:left;">**boolean equalsIgnoreCase(String anotherString)**将此 String 与另一个 String 比较，不考虑大小写</td></tr> <tr><td style="text-align:left;">12</td> <td style="text-align:left;">**byte getBytes()**使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中</td></tr> <tr><td style="text-align:left;">13</td> <td style="text-align:left;"><strong>byte[] getBytes(String charsetName</strong>使用指定的字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中</td></tr> <tr><td style="text-align:left;">14</td> <td style="text-align:left;">**void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)**将字符从此字符串复制到目标字符数组</td></tr> <tr><td style="text-align:left;">15</td> <td style="text-align:left;">**int hashCode()**返回此字符串的哈希码</td></tr> <tr><td style="text-align:left;">16</td> <td style="text-align:left;">**int indexOf(int ch)**返回指定字符在此字符串中第一次出现处的索引</td></tr> <tr><td style="text-align:left;">17</td> <td style="text-align:left;">**int indexOf(int ch, int fromIndex)**返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索</td></tr> <tr><td style="text-align:left;">18</td> <td style="text-align:left;">**int indexOf(String str)**返回指定子字符串在此字符串中第一次出现处的索引</td></tr> <tr><td style="text-align:left;">19</td> <td style="text-align:left;">**int indexOf(String str, int fromIndex)**返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始</td></tr> <tr><td style="text-align:left;">20</td> <td style="text-align:left;">**String intern()**返回字符串对象的规范化表示形式</td></tr> <tr><td style="text-align:left;">21</td> <td style="text-align:left;">**int lastIndexOf(int ch)**返回指定字符在此字符串中最后一次出现处的索引</td></tr> <tr><td style="text-align:left;">22</td> <td style="text-align:left;">**int lastIndexOf(int ch, int fromIndex)**返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索</td></tr> <tr><td style="text-align:left;">23</td> <td style="text-align:left;">**int lastIndexOf(String str)**返回指定子字符串在此字符串中最右边出现处的索引</td></tr> <tr><td style="text-align:left;">24</td> <td style="text-align:left;">**int lastIndexOf(String str, int fromIndex)**返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索</td></tr> <tr><td style="text-align:left;">25</td> <td style="text-align:left;">**int length()**返回此字符串的长度</td></tr> <tr><td style="text-align:left;">26</td> <td style="text-align:left;">**boolean matches(String regex)**告知此字符串是否匹配给定的正则表达式</td></tr> <tr><td style="text-align:left;">27</td> <td style="text-align:left;">**boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)**测试两个字符串区域是否相等</td></tr> <tr><td style="text-align:left;">28</td> <td style="text-align:left;">**boolean regionMatches(int toffset, String other, int ooffset, int len)**测试两个字符串区域是否相等</td></tr> <tr><td style="text-align:left;">29</td> <td style="text-align:left;">**String replace(char oldChar, char newChar)**返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的</td></tr> <tr><td style="text-align:left;">30</td> <td style="text-align:left;"><strong>String replaceAll(String regex, String replacement</strong>使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串</td></tr> <tr><td style="text-align:left;">31</td> <td style="text-align:left;">**String replaceFirst(String regex, String replacement)**使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串</td></tr> <tr><td style="text-align:left;">32</td> <td style="text-align:left;">**String[] split(String regex)**根据给定正则表达式的匹配拆分此字符串</td></tr> <tr><td style="text-align:left;">33</td> <td style="text-align:left;">**String[] split(String regex, int limit)**根据匹配给定的正则表达式来拆分此字符串</td></tr> <tr><td style="text-align:left;">34</td> <td style="text-align:left;">**boolean startsWith(String prefix)**测试此字符串是否以指定的前缀开始</td></tr> <tr><td style="text-align:left;">35</td> <td style="text-align:left;">**boolean startsWith(String prefix, int toffset)**测试此字符串从指定索引开始的子字符串是否以指定前缀开始。</td></tr> <tr><td style="text-align:left;">36</td> <td style="text-align:left;">**CharSequence subSequence(int beginIndex, int endIndex)**返回一个新的字符序列，它是此序列的一个子序列</td></tr> <tr><td style="text-align:left;">37</td> <td style="text-align:left;">**String substring(int beginIndex)**返回一个新的字符串，它是此字符串的一个子字符串</td></tr> <tr><td style="text-align:left;">38</td> <td style="text-align:left;">**String substring(int beginIndex, int endIndex)**返回一个新字符串，它是此字符串的一个子字符串</td></tr> <tr><td style="text-align:left;">39</td> <td style="text-align:left;">**char[] toCharArray()**将此字符串转换为一个新的字符数组</td></tr> <tr><td style="text-align:left;">40</td> <td style="text-align:left;">**String toLowerCase()**使用默认语言环境的规则将此 String 中的所有字符都转换为小写</td></tr> <tr><td style="text-align:left;">41</td> <td style="text-align:left;">**String toLowerCase(Locale locale)**使用给定 Locale 的规则将此 String 中的所有字符都转换为小写</td></tr> <tr><td style="text-align:left;">42</td> <td style="text-align:left;">**String toString()**返回此对象本身（它已经是一个字符串！）</td></tr> <tr><td style="text-align:left;">43</td> <td style="text-align:left;">**String toUpperCase()**使用默认语言环境的规则将此 String 中的所有字符都转换为大写</td></tr> <tr><td style="text-align:left;">44</td> <td style="text-align:left;">**String toUpperCase(Locale locale)**使用给定 Locale 的规则将此 String 中的所有字符都转换为大写</td></tr> <tr><td style="text-align:left;">45</td> <td style="text-align:left;">**String trim()**删除指定字符串的首尾空白符</td></tr> <tr><td style="text-align:left;">46</td> <td style="text-align:left;">**static String valueOf(primitive data type x)**返回指定类型参数的字符串表示形式</td></tr></tbody></table></blockquote> <h3 id="scala数组"><a href="#scala数组" class="header-anchor">#</a> Scala数组</h3> <h4 id="声明数组"><a href="#声明数组" class="header-anchor">#</a> 声明数组</h4> <blockquote><p>以下是 Scala 数组声明的语法格式：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var z:Array[String] = new Array[String](3)

或

var z = new Array[String](3)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></blockquote> <h4 id="处理数组"><a href="#处理数组" class="header-anchor">#</a> 处理数组</h4> <blockquote><p>数组的元素类型和数组的大小都是确定的，所以当处理数组元素时候，我们通常使用基本的 for 循环。</p> <p>以下实例演示了数组的创建，初始化等处理过程：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>object Test {
   def main(args: Array[String]) {
      var myList = Array(1.9, 2.9, 3.4, 3.5)
      
      // 输出所有数组元素
      for ( x &lt;- myList ) {
         println( x )
      }

      // 计算数组所有元素的总和
      var total = 0.0;
      for ( i &lt;- 0 to (myList.length - 1)) {
         total += myList(i);
      }
      println(&quot;总和为 &quot; + total);

      // 查找数组中的最大元素
      var max = myList(0);
      for ( i &lt;- 1 to (myList.length - 1) ) {
         if (myList(i) &gt; max) max = myList(i);
      }
      println(&quot;最大值为 &quot; + max);
    
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div></blockquote> <h4 id="多维数组"><a href="#多维数组" class="header-anchor">#</a> 多维数组</h4> <blockquote><p>多维数组一个数组中的值可以是另一个数组，另一个数组的值也可以是一个数组。矩阵与表格是我们常见的二维数组。</p> <p>以上是一个定义了二维数组的实例：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var myMatrix = ofDim[Int](3,3)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>实例中数组中包含三个数组元素，每个数组元素又含有三个值。</p> <p>接下来我们来看一个二维数组处理的完整实例：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>import Array._

object Test {
   def main(args: Array[String]) {
      var myMatrix = ofDim[Int](3,3)
      
      // 创建矩阵
      for (i &lt;- 0 to 2) {
         for ( j &lt;- 0 to 2) {
            myMatrix(i)(j) = j;
         }
      }
      
      // 打印二维阵列
      for (i &lt;- 0 to 2) {
         for ( j &lt;- 0 to 2) {
            print(&quot; &quot; + myMatrix(i)(j));
         }
         println();
      }
    
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div></blockquote> <h4 id="合并数组"><a href="#合并数组" class="header-anchor">#</a> 合并数组</h4> <blockquote><p>以下实例中，我们使用 concat() 方法来合并两个数组，concat() 方法中接受多个数组参数：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>import Array._

object Test {
   def main(args: Array[String]) {
      var myList1 = Array(1.9, 2.9, 3.4, 3.5)
      var myList2 = Array(8.9, 7.9, 0.4, 1.5)

      var myList3 =  concat( myList1, myList2)
      
      // 输出所有数组元素
      for ( x &lt;- myList3 ) {
         println( x )
      }
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div></blockquote> <h4 id="创建区间数组"><a href="#创建区间数组" class="header-anchor">#</a> 创建区间数组</h4> <blockquote><p>以下实例中，我们使用了 range() 方法来生成一个区间范围内的数组。<strong>range</strong>() 方法最后一个参数为步长，默认为 1：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>import Array._

object Test {
   def main(args: Array[String]) {
      var myList1 = range(10, 20, 2)
      var myList2 = range(10,20)

      // 输出所有数组元素
      for ( x &lt;- myList1 ) {
         print( &quot; &quot; + x )
      }
      println()
      for ( x &lt;- myList2 ) {
         print( &quot; &quot; + x )
      }
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div></blockquote> <h4 id="scala数组方法"><a href="#scala数组方法" class="header-anchor">#</a> Scala数组方法</h4> <blockquote><p>下表中为 Scala 语言中处理数组的重要方法，使用它前我们需要使用 <strong>import Array._</strong> 引入包。</p> <table><thead><tr><th style="text-align:left;">序号</th> <th style="text-align:left;">方法和描述</th></tr></thead> <tbody><tr><td style="text-align:left;">1</td> <td style="text-align:left;">**def apply( x: T, xs: T* ): Array[T]**创建指定对象 T 的数组, T 的值可以是 Unit, Double, Float, Long, Int, Char, Short, Byte, Boolean。</td></tr> <tr><td style="text-align:left;">2</td> <td style="text-align:left;">**def concat[T]( xss: Array[T]* ): Array[T]**合并数组</td></tr> <tr><td style="text-align:left;">3</td> <td style="text-align:left;"><strong>def copy( src: AnyRef, srcPos: Int, dest: AnyRef, destPos: Int, length: Int ): Unit</strong>复制一个数组到另一个数组上。相等于 Java's System.arraycopy(src, srcPos, dest, destPos, length)。</td></tr> <tr><td style="text-align:left;">4</td> <td style="text-align:left;">**def empty[T]: Array[T]**返回长度为 0 的数组</td></tr> <tr><td style="text-align:left;">5</td> <td style="text-align:left;"><strong>def iterate[T]( start: T, len: Int )( f: (T) =&gt; T ): Array[T]<strong>返回指定长度数组，每个数组元素为指定函数的返回值。以上实例数组初始值为 0，长度为 3，计算函数为</strong>a=&gt;a+1</strong>：<code>scala&gt; Array.iterate(0,3)(a=&gt;a+1) res1: Array[Int] = Array(0, 1, 2)</code></td></tr> <tr><td style="text-align:left;">6</td> <td style="text-align:left;">**def fill[T]( n: Int )(elem: =&gt; T): Array[T]**返回数组，长度为第一个参数指定，同时每个元素使用第二个参数进行填充。</td></tr> <tr><td style="text-align:left;">7</td> <td style="text-align:left;">**def fill[T]( n1: Int, n2: Int )( elem: =&gt; T ): Array[Array[T]]**返回二数组，长度为第一个参数指定，同时每个元素使用第二个参数进行填充。</td></tr> <tr><td style="text-align:left;">8</td> <td style="text-align:left;">**def ofDim[T]( n1: Int ): Array[T]**创建指定长度的数组</td></tr> <tr><td style="text-align:left;">9</td> <td style="text-align:left;">**def ofDim[T]( n1: Int, n2: Int ): Array[Array[T]]**创建二维数组</td></tr> <tr><td style="text-align:left;">10</td> <td style="text-align:left;">**def ofDim[T]( n1: Int, n2: Int, n3: Int ): Array[Array[Array[T]]]**创建三维数组</td></tr> <tr><td style="text-align:left;">11</td> <td style="text-align:left;">**def range( start: Int, end: Int, step: Int ): Array[Int]**创建指定区间内的数组，step 为每个元素间的步长</td></tr> <tr><td style="text-align:left;">12</td> <td style="text-align:left;">**def range( start: Int, end: Int ): Array[Int]**创建指定区间内的数组</td></tr> <tr><td style="text-align:left;">13</td> <td style="text-align:left;">**def tabulate[T]( n: Int )(f: (Int)=&gt; T): Array[T]**返回指定长度数组，每个数组元素为指定函数的返回值，默认从 0 开始。以上实例返回 3 个元素：<code>scala&gt; Array.tabulate(3)(a =&gt; a + 5) res0: Array[Int] = Array(5, 6, 7)</code></td></tr> <tr><td style="text-align:left;">14</td> <td style="text-align:left;">**def tabulate[T]( n1: Int, n2: Int )( f: (Int, Int ) =&gt; T): Array[Array[T]]**返回指定长度的二维数组，每个数组元素为指定函数的返回值，默认从 0 开始。</td></tr></tbody></table></blockquote> <h3 id="scala集合"><a href="#scala集合" class="header-anchor">#</a> Scala集合</h3> <h4 id="scala-list"><a href="#scala-list" class="header-anchor">#</a> Scala List</h4> <blockquote><p>Scala 列表类似于数组，它们所有元素的类型都相同，但是它们也有所不同：列表是不可变的，值一旦被定义了就不能改变，其次列表 具有递归的结构（也就是链接表结构）而数组不是。。</p> <p>列表的元素类型 T 可以写成 List[T]。例如，以下列出了多种类型的列表：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 字符串列表
val site: List[String] = List(&quot;Runoob&quot;, &quot;Google&quot;, &quot;Baidu&quot;)

// 整型列表
val nums: List[Int] = List(1, 2, 3, 4)

// 空列表
val empty: List[Nothing] = List()

// 二维列表
val dim: List[List[Int]] =
   List(
      List(1, 0, 0),
      List(0, 1, 0),
      List(0, 0, 1)
   )
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>构造列表的两个基本单位是 <strong>Nil</strong> 和 <strong>::</strong></p> <p><strong>Nil</strong> 也可以表示为一个空列表。</p> <p>以上实例我们可以写成如下所示：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 字符串列表
val site = &quot;Runoob&quot; :: (&quot;Google&quot; :: (&quot;Baidu&quot; :: Nil))

// 整型列表
val nums = 1 :: (2 :: (3 :: (4 :: Nil)))

// 空列表
val empty = Nil

// 二维列表
val dim = (1 :: (0 :: (0 :: Nil))) ::
          (0 :: (1 :: (0 :: Nil))) ::
          (0 :: (0 :: (1 :: Nil))) :: Nil
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><hr> <h4 id="列表基本操作"><a href="#列表基本操作" class="header-anchor">#</a> 列表基本操作</h4> <p>Scala列表有三个基本操作：</p> <ul><li><code>head</code> 返回列表第一个元素</li> <li><code>tail</code> 返回一个列表，包含除了第一元素之外的其他元素</li> <li><code>isEmpty</code> 在列表为空时返回true</li></ul> <p>对于Scala列表的任何操作都可以使用这三个基本操作来表达。实例如下:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>object Test {
   def main(args: Array[String]) {
      val site = &quot;Runoob&quot; :: (&quot;Google&quot; :: (&quot;Baidu&quot; :: Nil))
      val nums = Nil

      println( &quot;第一网站是 : &quot; + site.head )
      println( &quot;最后一个网站是 : &quot; + site.tail )
      println( &quot;查看列表 site 是否为空 : &quot; + site.isEmpty )
      println( &quot;查看 nums 是否为空 : &quot; + nums.isEmpty )
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>执行以上代码，输出结果为：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ vim Test.scala 
$ scala Test.scala 
第一网站是 : Runoob
最后一个网站是 : List(Google, Baidu)
查看列表 site 是否为空 : false
查看 nums 是否为空 : true
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><hr> <h4 id="连接列表"><a href="#连接列表" class="header-anchor">#</a> 连接列表</h4> <p>你可以使用 <strong>:::</strong> 运算符或 <strong>List.::😦)</strong> 方法或 <strong>List.concat()</strong> 方法来连接两个或多个列表。实例如下:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>object Test {
   def main(args: Array[String]) {
      val site1 = &quot;Runoob&quot; :: (&quot;Google&quot; :: (&quot;Baidu&quot; :: Nil))
      val site2 = &quot;Facebook&quot; :: (&quot;Taobao&quot; :: Nil)

      // 使用 ::: 运算符
      var fruit = site1 ::: site2
      println( &quot;site1 ::: site2 : &quot; + fruit )
      
      // 使用 List.:::() 方法
      fruit = site1.:::(site2)
      println( &quot;site1.:::(site2) : &quot; + fruit )

      // 使用 concat 方法
      fruit = List.concat(site1, site2)
      println( &quot;List.concat(site1, site2) : &quot; + fruit  )
      

   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>执行以上代码，输出结果为：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ vim Test.scala 
$ scala Test.scala 
site1 ::: site2 : List(Runoob, Google, Baidu, Facebook, Taobao)
site1.:::(site2) : List(Facebook, Taobao, Runoob, Google, Baidu)
List.concat(site1, site2) : List(Runoob, Google, Baidu, Facebook, Taobao)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><hr> <h4 id="list-fill"><a href="#list-fill" class="header-anchor">#</a> List.fill()</h4> <p>我们可以使用 List.fill() 方法来创建一个指定重复数量的元素列表：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>object Test {
   def main(args: Array[String]) {
      val site = List.fill(3)(&quot;Runoob&quot;) // 重复 Runoob 3次
      println( &quot;site : &quot; + site  )

      val num = List.fill(10)(2)         // 重复元素 2, 10 次
      println( &quot;num : &quot; + num  )
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>执行以上代码，输出结果为：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ vim Test.scala 
$ scala Test.scala 
site : List(Runoob, Runoob, Runoob)
num : List(2, 2, 2, 2, 2, 2, 2, 2, 2, 2)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><hr> <h4 id="list-tabulate"><a href="#list-tabulate" class="header-anchor">#</a> List.tabulate()</h4> <p>List.tabulate() 方法是通过给定的函数来创建列表。</p> <p>方法的第一个参数为元素的数量，可以是二维的，第二个参数为指定的函数，我们通过指定的函数计算结果并返回值插入到列表中，起始值为 0，实例如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>object Test {
   def main(args: Array[String]) {
      // 通过给定的函数创建 5 个元素
      val squares = List.tabulate(6)(n =&gt; n * n)
      println( &quot;一维 : &quot; + squares  )

      // 创建二维列表
      val mul = List.tabulate( 4,5 )( _ * _ )      
      println( &quot;多维 : &quot; + mul  )
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>执行以上代码，输出结果为：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ vim Test.scala 
$ scala Test.scala 
一维 : List(0, 1, 4, 9, 16, 25)
多维 : List(List(0, 0, 0, 0, 0), List(0, 1, 2, 3, 4), List(0, 2, 4, 6, 8), List(0, 3, 6, 9, 12))
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><hr> <h4 id="list-reverse"><a href="#list-reverse" class="header-anchor">#</a> List.reverse</h4> <p>List.reverse 用于将列表的顺序反转，实例如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>object Test {
   def main(args: Array[String]) {
      val site = &quot;Runoob&quot; :: (&quot;Google&quot; :: (&quot;Baidu&quot; :: Nil))
      println( &quot;site 反转前 : &quot; + site )

      println( &quot;site 反转后 : &quot; + site.reverse )
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>执行以上代码，输出结果为：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ vim Test.scala 
$ scala Test.scala 
site 反转前 : List(Runoob, Google, Baidu)
site 反转后 : List(Baidu, Google, Runoob)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></blockquote> <h3 id="scala-set"><a href="#scala-set" class="header-anchor">#</a> Scala Set</h3> <blockquote><p>Scala Set(集合)是没有重复的对象集合，所有的元素都是唯一的。</p> <p>Scala 集合分为可变的和不可变的集合。</p> <p>默认情况下，Scala 使用的是不可变集合，如果你想使用可变集合，需要引用 <strong>scala.collection.mutable.Set</strong> 包。</p> <p>默认引用 scala.collection.immutable.Set，不可变集合实例如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>val set = Set(1,2,3)
println(set.getClass.getName) // 

println(set.exists(_ % 2 == 0)) //true
println(set.drop(1)) //Set(2,3)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>如果需要使用可变集合需要引入 scala.collection.mutable.Set：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>import scala.collection.mutable.Set // 可以在任何地方引入 可变集合

val mutableSet = Set(1,2,3)
println(mutableSet.getClass.getName) // scala.collection.mutable.HashSet

mutableSet.add(4)
mutableSet.remove(1)
mutableSet += 5
mutableSet -= 2

println(mutableSet) // Set(5, 3, 4)

val another = mutableSet.toSet
println(another.getClass.getName) // scala.collection.immutable.Set
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><blockquote><p><strong>注意：</strong> 虽然可变Set和不可变Set都有添加或删除元素的操作，但是有一个非常大的差别。对不可变Set进行操作，会产生一个新的set，原来的set并没有改变，这与List一样。 而对可变Set进行操作，改变的是该Set本身，与ListBuffer类似。</p></blockquote> <hr> <h4 id="集合基本操作"><a href="#集合基本操作" class="header-anchor">#</a> 集合基本操作</h4> <p>Scala集合有三个基本操作：</p> <ul><li><code>head</code> 返回集合第一个元素</li> <li><code>tail</code> 返回一个集合，包含除了第一元素之外的其他元素</li> <li><code>isEmpty</code> 在集合为空时返回true</li></ul> <p>对于Scala集合的任何操作都可以使用这三个基本操作来表达。实例如下:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>object Test {
   def main(args: Array[String]) {
      val site = Set(&quot;Runoob&quot;, &quot;Google&quot;, &quot;Baidu&quot;)
      val nums: Set[Int] = Set()

      println( &quot;第一网站是 : &quot; + site.head )
      println( &quot;最后一个网站是 : &quot; + site.tail )
      println( &quot;查看列表 site 是否为空 : &quot; + site.isEmpty )
      println( &quot;查看 nums 是否为空 : &quot; + nums.isEmpty )
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>执行以上代码，输出结果为：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ vim Test.scala 
$ scala Test.scala 
第一网站是 : Runoob
最后一个网站是 : Set(Google, Baidu)
查看列表 site 是否为空 : false
查看 nums 是否为空 : true
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><hr> <h4 id="连接集合"><a href="#连接集合" class="header-anchor">#</a> 连接集合</h4> <p>你可以使用 <strong>++</strong> 运算符或 <strong>Set.++()</strong> 方法来连接两个集合。如果元素有重复的就会移除重复的元素。实例如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>object Test {
   def main(args: Array[String]) {
      val site1 = Set(&quot;Runoob&quot;, &quot;Google&quot;, &quot;Baidu&quot;)
      val site2 = Set(&quot;Faceboook&quot;, &quot;Taobao&quot;)

      // ++ 作为运算符使用
      var site = site1 ++ site2
      println( &quot;site1 ++ site2 : &quot; + site )

      //  ++ 作为方法使用
      site = site1.++(site2)
      println( &quot;site1.++(site2) : &quot; + site )
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>执行以上代码，输出结果为：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ vim Test.scala 
$ scala Test.scala 
site1 ++ site2 : Set(Faceboook, Taobao, Google, Baidu, Runoob)
site1.++(site2) : Set(Faceboook, Taobao, Google, Baidu, Runoob)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><hr> <h4 id="查找集合中最大与最小元素"><a href="#查找集合中最大与最小元素" class="header-anchor">#</a> 查找集合中最大与最小元素</h4> <p>你可以使用 Set.min 方法来查找集合中的最小元素，使用 Set.max 方法查找集合中的最大元素。实例如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>object Test {
   def main(args: Array[String]) {
      val num = Set(5,6,9,20,30,45)

      // 查找集合中最大与最小元素
      println( &quot;Set(5,6,9,20,30,45) 集合中的最小元素是 : &quot; + num.min )
      println( &quot;Set(5,6,9,20,30,45) 集合中的最大元素是 : &quot; + num.max )
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h4 id="交集"><a href="#交集" class="header-anchor">#</a> 交集</h4> <p>你可以使用 <strong>Set.&amp;</strong> 方法或 <strong>Set.intersect</strong> 方法来查看两个集合的交集元素。实例如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>object Test {
   def main(args: Array[String]) {
      val num1 = Set(5,6,9,20,30,45)
      val num2 = Set(50,60,9,20,35,55)

      // 交集
      println( &quot;num1.&amp;(num2) : &quot; + num1.&amp;(num2) )
      println( &quot;num1.intersect(num2) : &quot; + num1.intersect(num2) )
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>执行以上代码，输出结果为：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ vim Test.scala 
$ scala Test.scala 
num1.&amp;(num2) : Set(20, 9)
num1.intersect(num2) : Set(20, 9)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></blockquote> <h3 id="scala-map"><a href="#scala-map" class="header-anchor">#</a> Scala Map</h3> <blockquote><p>Map(映射)是一种可迭代的键值对（key/value）结构。</p> <p>所有的值都可以通过键来获取。</p> <p>Map 中的键都是唯一的。</p> <p>Map 也叫哈希表（Hash tables）。</p> <p>Map 有两种类型，可变与不可变，区别在于可变对象可以修改它，而不可变对象不可以。</p> <p>默认情况下 Scala 使用不可变 Map。如果你需要使用可变集合，你需要显式的引入 <strong>import scala.collection.mutable.Map</strong> 类</p> <p>在 Scala 中 你可以同时使用可变与不可变 Map，不可变的直接使用 Map，可变的使用 mutable.Map。以下实例演示了不可变 Map 的应用：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 空哈希表，键为字符串，值为整型
var A:Map[Char,Int] = Map()

// Map 键值对演示
val colors = Map(&quot;red&quot; -&gt; &quot;#FF0000&quot;, &quot;azure&quot; -&gt; &quot;#F0FFFF&quot;)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>定义 Map 时，需要为键值对定义类型。如果需要添加 key-value 对，可以使用 + 号，如下所示：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>A += ('I' -&gt; 1)
A += ('J' -&gt; 5)
A += ('K' -&gt; 10)
A += ('L' -&gt; 100)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><hr> <h4 id="map-基本操作"><a href="#map-基本操作" class="header-anchor">#</a> Map 基本操作</h4> <p>Scala Map 有三个基本操作：</p> <table><thead><tr><th style="text-align:left;">方法</th> <th style="text-align:left;">描述</th></tr></thead> <tbody><tr><td style="text-align:left;">keys</td> <td style="text-align:left;">返回 Map 所有的键(key)</td></tr> <tr><td style="text-align:left;">values</td> <td style="text-align:left;">返回 Map 所有的值(value)</td></tr> <tr><td style="text-align:left;">isEmpty</td> <td style="text-align:left;">在 Map 为空时返回true</td></tr></tbody></table> <h4 id="实例-5"><a href="#实例-5" class="header-anchor">#</a> 实例</h4> <p>以下实例演示了以上三个方法的基本应用：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>object Test {
   def main(args: Array[String]) {
      val colors = Map(&quot;red&quot; -&gt; &quot;#FF0000&quot;,
                       &quot;azure&quot; -&gt; &quot;#F0FFFF&quot;,
                       &quot;peru&quot; -&gt; &quot;#CD853F&quot;)

      val nums: Map[Int, Int] = Map()

      println( &quot;colors 中的键为 : &quot; + colors.keys )
      println( &quot;colors 中的值为 : &quot; + colors.values )
      println( &quot;检测 colors 是否为空 : &quot; + colors.isEmpty )
      println( &quot;检测 nums 是否为空 : &quot; + nums.isEmpty )
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>执行以上代码，输出结果为：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ scalac Test.scala 
$ scala Test
colors 中的键为 : Set(red, azure, peru)
colors 中的值为 : MapLike(#FF0000, #F0FFFF, #CD853F)
检测 colors 是否为空 : false
检测 nums 是否为空 : true
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><hr> <h4 id="map-合并"><a href="#map-合并" class="header-anchor">#</a> Map 合并</h4> <p>你可以使用 <strong>++</strong> 运算符或 <strong>Map.++()</strong> 方法来连接两个 Map，Map 合并时会移除重复的 key。以下演示了两个 Map 合并的实例:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>object Test {
   def main(args: Array[String]) {
      val colors1 = Map(&quot;red&quot; -&gt; &quot;#FF0000&quot;,
                        &quot;azure&quot; -&gt; &quot;#F0FFFF&quot;,
                        &quot;peru&quot; -&gt; &quot;#CD853F&quot;)
      val colors2 = Map(&quot;blue&quot; -&gt; &quot;#0033FF&quot;,
                        &quot;yellow&quot; -&gt; &quot;#FFFF00&quot;,
                        &quot;red&quot; -&gt; &quot;#FF0000&quot;)

      //  ++ 作为运算符
      var colors = colors1 ++ colors2
      println( &quot;colors1 ++ colors2 : &quot; + colors )

      //  ++ 作为方法
      colors = colors1.++(colors2)
      println( &quot;colors1.++(colors2) : &quot; + colors )

   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>执行以上代码，输出结果为：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ scalac Test.scala 
$ scala Test
colors1 ++ colors2 : Map(blue -&gt; #0033FF, azure -&gt; #F0FFFF, peru -&gt; #CD853F, yellow -&gt; #FFFF00, red -&gt; #FF0000)
colors1.++(colors2) : Map(blue -&gt; #0033FF, azure -&gt; #F0FFFF, peru -&gt; #CD853F, yellow -&gt; #FFFF00, red -&gt; #FF0000)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><hr> <h4 id="输出-map-的-keys-和-values"><a href="#输出-map-的-keys-和-values" class="header-anchor">#</a> 输出 Map 的 keys 和 values</h4> <p>以下通过 foreach 循环输出 Map 中的 keys 和 values：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>object Test {
   def main(args: Array[String]) {
      val sites = Map(&quot;runoob&quot; -&gt; &quot;http://www.runoob.com&quot;,
                       &quot;baidu&quot; -&gt; &quot;http://www.baidu.com&quot;,
                       &quot;taobao&quot; -&gt; &quot;http://www.taobao.com&quot;)

      sites.keys.foreach{ i =&gt;  
                           print( &quot;Key = &quot; + i )
                           println(&quot; Value = &quot; + sites(i) )}
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>执行以上代码，输出结果为：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ scalac Test.scala 
$ scala Test
Key = runoob Value = http://www.runoob.com
Key = baidu Value = http://www.baidu.com
Key = taobao Value = http://www.taobao.com
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><hr> <h4 id="查看-map-中是否存在指定的-key"><a href="#查看-map-中是否存在指定的-key" class="header-anchor">#</a> 查看 Map 中是否存在指定的 Key</h4> <p>你可以使用 <strong>Map.contains</strong> 方法来查看 Map 中是否存在指定的 Key。实例如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>object Test {
   def main(args: Array[String]) {
      val sites = Map(&quot;runoob&quot; -&gt; &quot;http://www.runoob.com&quot;,
                       &quot;baidu&quot; -&gt; &quot;http://www.baidu.com&quot;,
                       &quot;taobao&quot; -&gt; &quot;http://www.taobao.com&quot;)

      if( sites.contains( &quot;runoob&quot; )){
           println(&quot;runoob 键存在，对应的值为 :&quot;  + sites(&quot;runoob&quot;))
      }else{
           println(&quot;runoob 键不存在&quot;)
      }
      if( sites.contains( &quot;baidu&quot; )){
           println(&quot;baidu 键存在，对应的值为 :&quot;  + sites(&quot;baidu&quot;))
      }else{
           println(&quot;baidu 键不存在&quot;)
      }
      if( sites.contains( &quot;google&quot; )){
           println(&quot;google 键存在，对应的值为 :&quot;  + sites(&quot;google&quot;))
      }else{
           println(&quot;google 键不存在&quot;)
      }
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p>执行以上代码，输出结果为：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ scalac Test.scala 
$ scala Test
runoob 键存在，对应的值为 :http://www.runoob.com
baidu 键存在，对应的值为 :http://www.baidu.com
google 键不存在
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></blockquote> <h4 id="scala-元组"><a href="#scala-元组" class="header-anchor">#</a> Scala 元组</h4> <blockquote><p>与列表一样，元组也是不可变的，但与列表不同的是元组可以包含不同类型的元素。</p> <p>元组的值是通过将单个的值包含在圆括号中构成的。例如：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>val t = (1, 3.14, &quot;Fred&quot;)  
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>以上实例在元组中定义了三个元素，对应的类型分别为[Int, Double, java.lang.String]。</p> <p>此外我们也可以使用以下方式来定义：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>val t = new Tuple3(1, 3.14, &quot;Fred&quot;)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>元组的实际类型取决于它的元素的类型，比如 (99, &quot;runoob&quot;) 是 Tuple2[Int, String]。 ('u', 'r', &quot;the&quot;, 1, 4, &quot;me&quot;) 为 Tuple6[Char, Char, String, Int, Int, String]。</p> <p>目前 Scala 支持的元组最大长度为 22。对于更大长度你可以使用集合，或者扩展元组。</p> <p>访问元组的元素可以通过数字索引，如下一个元组：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>val t = (4,3,2,1)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>我们可以使用 t._1 访问第一个元素， t._2 访问第二个元素，如下所示：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>object Test {
   def main(args: Array[String]) {
      val t = (4,3,2,1)

      val sum = t._1 + t._2 + t._3 + t._4

      println( &quot;元素之和为: &quot;  + sum )
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>执行以上代码，输出结果为：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ scalac Test.scala 
$ scala Test
元素之和为: 10
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><hr> <h4 id="迭代元组"><a href="#迭代元组" class="header-anchor">#</a> 迭代元组</h4> <p>你可以使用 <strong>Tuple.productIterator()</strong> 方法来迭代输出元组的所有元素：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>object Test {
   def main(args: Array[String]) {
      val t = (4,3,2,1)
      
      t.productIterator.foreach{ i =&gt;println(&quot;Value = &quot; + i )}
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>执行以上代码，输出结果为：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ scalac Test.scala 
$ scala Test
Value = 4
Value = 3
Value = 2
Value = 1
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><hr> <h4 id="元组转为字符串"><a href="#元组转为字符串" class="header-anchor">#</a> 元组转为字符串</h4> <p>你可以使用 <strong>Tuple.toString()</strong> 方法将元组的所有元素组合成一个字符串，实例如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>object Test {
   def main(args: Array[String]) {
      val t = new Tuple3(1, &quot;hello&quot;, Console)
      
      println(&quot;连接后的字符串为: &quot; + t.toString() )
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>执行以上代码，输出结果为：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ scalac Test.scala 
$ scala Test
连接后的字符串为: (1,hello,scala.Console$@4dd8dc3)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><hr> <h4 id="元素交换"><a href="#元素交换" class="header-anchor">#</a> 元素交换</h4> <p>你可以使用 <strong>Tuple.swap</strong> 方法来交换元组的元素。如下实例：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>object Test {
   def main(args: Array[String]) {
      val t = new Tuple2(&quot;www.google.com&quot;, &quot;www.runoob.com&quot;)
      
      println(&quot;交换后的元组: &quot; + t.swap )
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>执行以上代码，输出结果为：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ scalac Test.scala 
$ scala Test
交换后的元组: (www.runoob.com,www.google.com)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></blockquote> <h3 id="scala-option"><a href="#scala-option" class="header-anchor">#</a> Scala Option</h3> <blockquote><p>Scala Option(选项)类型用来表示一个值是可选的（有值或无值)。</p> <p>Option[T] 是一个类型为 T 的可选值的容器： 如果值存在， Option[T] 就是一个 Some[T] ，如果不存在， Option[T] 就是对象 None 。</p> <p>接下来我们来看一段代码：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 虽然 Scala 可以不定义变量的类型，不过为了清楚些，我还是
// 把他显示的定义上了
 
val myMap: Map[String, String] = Map(&quot;key1&quot; -&gt; &quot;value&quot;)
val value1: Option[String] = myMap.get(&quot;key1&quot;)
val value2: Option[String] = myMap.get(&quot;key2&quot;)
 
println(value1) // Some(&quot;value1&quot;)
println(value2) // None
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>在上面的代码中，myMap 一个是一个 Key 的类型是 String，Value 的类型是 String 的 hash map，但不一样的是他的 get() 返回的是一个叫 Option[String] 的类别。</p> <p>Scala 使用 Option[String] 来告诉你：「我会想办法回传一个 String，但也可能没有 String 给你」。</p> <p>myMap 里并没有 key2 这笔数据，get() 方法返回 None。</p> <p>Option 有两个子类别，一个是 Some，一个是 None，当他回传 Some 的时候，代表这个函式成功地给了你一个 String，而你可以透过 get() 这个函式拿到那个 String，如果他返回的是 None，则代表没有字符串可以给你。</p> <p>另一个实例：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>object Test {
   def main(args: Array[String]) {
      val sites = Map(&quot;runoob&quot; -&gt; &quot;www.runoob.com&quot;, &quot;google&quot; -&gt; &quot;www.google.com&quot;)
      
      println(&quot;sites.get( \&quot;runoob\&quot; ) : &quot; +  sites.get( &quot;runoob&quot; )) // Some(www.runoob.com)
      println(&quot;sites.get( \&quot;baidu\&quot; ) : &quot; +  sites.get( &quot;baidu&quot; ))  //  None
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>执行以上代码，输出结果为：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ scalac Test.scala 
$ scala Test
sites.get( &quot;runoob&quot; ) : Some(www.runoob.com)
sites.get( &quot;baidu&quot; ) : None
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>你也可以通过模式匹配来输出匹配值。实例如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>object Test {
   def main(args: Array[String]) {
      val sites = Map(&quot;runoob&quot; -&gt; &quot;www.runoob.com&quot;, &quot;google&quot; -&gt; &quot;www.google.com&quot;)
      
      println(&quot;show(sites.get( \&quot;runoob\&quot;)) : &quot; +  
                                          show(sites.get( &quot;runoob&quot;)) )
      println(&quot;show(sites.get( \&quot;baidu\&quot;)) : &quot; +  
                                          show(sites.get( &quot;baidu&quot;)) )
   }
   
   def show(x: Option[String]) = x match {
      case Some(s) =&gt; s
      case None =&gt; &quot;?&quot;
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>执行以上代码，输出结果为：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ scalac Test.scala 
$ scala Test
show(sites.get( &quot;runoob&quot;)) : www.runoob.com
show(sites.get( &quot;baidu&quot;)) : ?
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><hr> <h4 id="getorelse-方法"><a href="#getorelse-方法" class="header-anchor">#</a> getOrElse() 方法</h4> <p>你可以使用 getOrElse() 方法来获取元组中存在的元素或者使用其默认的值，实例如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>object Test {
   def main(args: Array[String]) {
      val a:Option[Int] = Some(5)
      val b:Option[Int] = None 
      
      println(&quot;a.getOrElse(0): &quot; + a.getOrElse(0) )
      println(&quot;b.getOrElse(10): &quot; + b.getOrElse(10) )
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>执行以上代码，输出结果为：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ scalac Test.scala 
$ scala Test
a.getOrElse(0): 5
b.getOrElse(10): 10
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><hr> <h4 id="isempty-方法"><a href="#isempty-方法" class="header-anchor">#</a> isEmpty() 方法</h4> <p>你可以使用 isEmpty() 方法来检测元组中的元素是否为 None，实例如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>object Test {
   def main(args: Array[String]) {
      val a:Option[Int] = Some(5)
      val b:Option[Int] = None 
      
      println(&quot;a.isEmpty: &quot; + a.isEmpty )
      println(&quot;b.isEmpty: &quot; + b.isEmpty )
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>执行以上代码，输出结果为：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ scalac Test.scala 
$ scala Test
a.isEmpty: false
b.isEmpty: true
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></blockquote> <h3 id="scala-iterator"><a href="#scala-iterator" class="header-anchor">#</a> Scala Iterator</h3> <blockquote><p>Scala Iterator（迭代器）不是一个集合，它是一种用于访问集合的方法。</p> <p>迭代器 it 的两个基本操作是 <strong>next</strong> 和 <strong>hasNext</strong>。</p> <p>调用 <strong>it.next()</strong> 会返回迭代器的下一个元素，并且更新迭代器的状态。</p> <p>调用 <strong>it.hasNext()</strong> 用于检测集合中是否还有元素。</p> <p>让迭代器 it 逐个返回所有元素最简单的方法是使用 while 循环：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>object Test {
   def main(args: Array[String]) {
      val it = Iterator(&quot;Baidu&quot;, &quot;Google&quot;, &quot;Runoob&quot;, &quot;Taobao&quot;)
      
      while (it.hasNext){
         println(it.next())
      }
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>执行以上代码，输出结果为：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ scalac Test.scala 
$ scala Test
Baidu
Google
Runoob
Taobao
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><hr> <h4 id="查找最大与最小元素"><a href="#查找最大与最小元素" class="header-anchor">#</a> 查找最大与最小元素</h4> <p>你可以使用 <strong>it.min</strong> 和 <strong>it.max</strong> 方法从迭代器中查找最大与最小元素，实例如下:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>object Test {
   def main(args: Array[String]) {
      val ita = Iterator(20,40,2,50,69, 90)
      val itb = Iterator(20,40,2,50,69, 90)
      
      println(&quot;最大元素是：&quot; + ita.max )
      println(&quot;最小元素是：&quot; + itb.min )

   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>执行以上代码，输出结果为：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ scalac Test.scala 
$ scala Test
最大元素是：90
最小元素是：2
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><hr> <h4 id="获取迭代器的长度"><a href="#获取迭代器的长度" class="header-anchor">#</a> 获取迭代器的长度</h4> <p>你可以使用 <strong>it.size</strong> 或 <strong>it.length</strong> 方法来查看迭代器中的元素个数。实例如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>object Test {
   def main(args: Array[String]) {
      val ita = Iterator(20,40,2,50,69, 90)
      val itb = Iterator(20,40,2,50,69, 90)
      
      println(&quot;ita.size 的值: &quot; + ita.size )
      println(&quot;itb.length 的值: &quot; + itb.length )

   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>执行以上代码，输出结果为：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ scalac Test.scala 
$ scala Test
ita.size 的值: 6
itb.length 的值: 6
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></blockquote> <h4 id="集合实例"><a href="#集合实例" class="header-anchor">#</a> 集合实例</h4> <p>以下代码判断，演示了所有以上集合类型的定义实例：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 定义整型 List
val x = List(1,2,3,4)

// 定义 Set
val x = Set(1,3,5,7)

// 定义 Map
val x = Map(&quot;one&quot; -&gt; 1, &quot;two&quot; -&gt; 2, &quot;three&quot; -&gt; 3)

// 创建两个不同类型元素的元组
val x = (10, &quot;Runoob&quot;)

// 定义 Option
val x:Option[Int] = Some(5)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h3 id="scala类和对象"><a href="#scala类和对象" class="header-anchor">#</a> Scala类和对象</h3> <blockquote><p>类是对象的抽象，而对象是类的具体实例。类是抽象的，不占用内存，而对象是具体的，占用存储空间。类是用于创建对象的蓝图，它是一个定义包括在特定类型的对象中的方法和变量的软件模板。</p> <p>我们可以使用 new 关键字来创建类的对象，实例如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>class Point(xc: Int, yc: Int) {
   var x: Int = xc
   var y: Int = yc

   def move(dx: Int, dy: Int) {
      x = x + dx
      y = y + dy
      println (&quot;x 的坐标点: &quot; + x);
      println (&quot;y 的坐标点: &quot; + y);
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>Scala中的类不声明为public，一个Scala源文件中可以有多个类。</p> <p>以上实例的类定义了两个变量 <strong>x</strong> 和 <strong>y</strong> ，一个方法：<strong>move</strong>，方法没有返回值。</p> <p>Scala 的类定义可以有参数，称为类参数，如上面的 xc, yc，类参数在整个类中都可以访问。</p> <p>接着我们可以使用 new 来实例化类，并访问类中的方法和变量：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>import java.io._

class Point(xc: Int, yc: Int) {
   var x: Int = xc
   var y: Int = yc

   def move(dx: Int, dy: Int) {
      x = x + dx
      y = y + dy
      println (&quot;x 的坐标点: &quot; + x);
      println (&quot;y 的坐标点: &quot; + y);
   }
}

object Test {
   def main(args: Array[String]) {
      val pt = new Point(10, 20);

      // 移到一个新的位置
      pt.move(10, 10);
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>执行以上代码，输出结果为：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ scalac Test.scala 
$ scala Test
x 的坐标点: 20
y 的坐标点: 30
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><hr> <h4 id="scala-继承"><a href="#scala-继承" class="header-anchor">#</a> Scala 继承</h4> <p>Scala继承一个基类跟Java很相似, 但我们需要注意以下几点：</p> <ul><li>1、重写一个非抽象方法必须使用override修饰符。</li> <li>2、只有主构造函数才可以往基类的构造函数里写参数。</li> <li>3、在子类中重写超类的抽象方法时，你不需要使用override关键字。</li></ul> <p>接下来让我们来看个实例：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>class Point(xc: Int, yc: Int) {
   var x: Int = xc
   var y: Int = yc

   def move(dx: Int, dy: Int) {
      x = x + dx
      y = y + dy
      println (&quot;x 的坐标点: &quot; + x);
      println (&quot;y 的坐标点: &quot; + y);
   }
}

class Location(override val xc: Int, override val yc: Int,
   val zc :Int) extends Point(xc, yc){
   var z: Int = zc

   def move(dx: Int, dy: Int, dz: Int) {
      x = x + dx
      y = y + dy
      z = z + dz
      println (&quot;x 的坐标点 : &quot; + x);
      println (&quot;y 的坐标点 : &quot; + y);
      println (&quot;z 的坐标点 : &quot; + z);
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>Scala 使用 extends 关键字来继承一个类。实例中 Location 类继承了 Point 类。Point 称为父类(基类)，Location 称为子类。</p> <p><strong>override val xc</strong> 为重写了父类的字段。</p> <p>继承会继承父类的所有属性和方法，Scala 只允许继承一个父类。</p> <p>实例如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>import java.io._

class Point(val xc: Int, val yc: Int) {
   var x: Int = xc
   var y: Int = yc
   def move(dx: Int, dy: Int) {
      x = x + dx
      y = y + dy
      println (&quot;x 的坐标点 : &quot; + x);
      println (&quot;y 的坐标点 : &quot; + y);
   }
}

class Location(override val xc: Int, override val yc: Int,
   val zc :Int) extends Point(xc, yc){
   var z: Int = zc

   def move(dx: Int, dy: Int, dz: Int) {
      x = x + dx
      y = y + dy
      z = z + dz
      println (&quot;x 的坐标点 : &quot; + x);
      println (&quot;y 的坐标点 : &quot; + y);
      println (&quot;z 的坐标点 : &quot; + z);
   }
}

object Test {
   def main(args: Array[String]) {
      val loc = new Location(10, 20, 15);

      // 移到一个新的位置
      loc.move(10, 10, 5);
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><p>执行以上代码，输出结果为：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ scalac Test.scala 
$ scala Test
x 的坐标点 : 20
y 的坐标点 : 30
z 的坐标点 : 20
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>Scala重写一个非抽象方法，必须用override修饰符。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>class Person {
  var name = &quot;&quot;
  override def toString = getClass.getName + &quot;[name=&quot; + name + &quot;]&quot;
}

class Employee extends Person {
  var salary = 0.0
  override def toString = super.toString + &quot;[salary=&quot; + salary + &quot;]&quot;
}

object Test extends App {
  val fred = new Employee
  fred.name = &quot;Fred&quot;
  fred.salary = 50000
  println(fred)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>执行以上代码，输出结果为：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ scalac Test.scala 
$ scala Test
Employee[name=Fred][salary=50000.0]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><hr> <h4 id="scala-单例对象"><a href="#scala-单例对象" class="header-anchor">#</a> Scala 单例对象</h4> <p>在 Scala 中，是没有 static 这个东西的，但是它也为我们提供了单例模式的实现方法，那就是使用关键字 object。</p> <p>Scala 中使用单例模式时，除了定义的类之外，还要定义一个同名的 object 对象，它和类的区别是，object对象不能带参数。</p> <p>当单例对象与某个类共享同一个名称时，他被称作是这个类的伴生对象：companion object。你必须在同一个源文件里定义类和它的伴生对象。类被称为是这个单例对象的伴生类：companion class。类和它的伴生对象可以互相访问其私有成员。</p> <h4 id="单例对象实例"><a href="#单例对象实例" class="header-anchor">#</a> 单例对象实例</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>import java.io._

class Point(val xc: Int, val yc: Int) {
   var x: Int = xc
   var y: Int = yc
   def move(dx: Int, dy: Int) {
      x = x + dx
      y = y + dy
   }
}

object Test {
   def main(args: Array[String]) {
      val point = new Point(10, 20)
      printPoint

      def printPoint{
         println (&quot;x 的坐标点 : &quot; + point.x);
         println (&quot;y 的坐标点 : &quot; + point.y);
      }
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>执行以上代码，输出结果为：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ scalac Test.scala 
$ scala Test
x 的坐标点 : 10
y 的坐标点 : 20
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h4 id="伴生对象实例"><a href="#伴生对象实例" class="header-anchor">#</a> 伴生对象实例</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>/* 文件名：Marker.scala
 */

// 私有构造方法
class Marker private(val color:String) {

  println(&quot;创建&quot; + this)
  
  override def toString(): String = &quot;颜色标记：&quot;+ color
  
}

// 伴生对象，与类名字相同，可以访问类的私有属性和方法
object Marker{
  
    private val markers: Map[String, Marker] = Map(
      &quot;red&quot; -&gt; new Marker(&quot;red&quot;),
      &quot;blue&quot; -&gt; new Marker(&quot;blue&quot;),
      &quot;green&quot; -&gt; new Marker(&quot;green&quot;)
    )
    
    def apply(color:String) = {
      if(markers.contains(color)) markers(color) else null
    }
  
    
    def getMarker(color:String) = { 
      if(markers.contains(color)) markers(color) else null
    }
    def main(args: Array[String]) { 
        println(Marker(&quot;red&quot;))  
        // 单例函数调用，省略了.(点)符号  
        println(Marker getMarker &quot;blue&quot;)  
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><p>执行以上代码，输出结果为：</p> <div class="language-scala line-numbers-mode"><pre class="language-scala"><code>$ scalac Marker<span class="token punctuation">.</span>scala 
$ scala Marker
创建颜色标记：red
创建颜色标记：blue
创建颜色标记：green
颜色标记：red
颜色标记：blue
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></blockquote> <h3 id="scala-trait-特征"><a href="#scala-trait-特征" class="header-anchor">#</a> Scala Trait(特征)</h3> <blockquote><p>Scala Trait(特征) 相当于 Java 的接口，实际上它比接口还功能强大。</p> <p>与接口不同的是，它还可以定义属性和方法的实现。</p> <p>一般情况下Scala的类只能够继承单一父类，但是如果是 Trait(特征) 的话就可以继承多个，从结果来看就是实现了多重继承。</p> <p>Trait(特征) 定义的方式与类类似，但它使用的关键字是 <strong>trait</strong>，如下所示：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>trait Equal {
  def isEqual(x: Any): Boolean
  def isNotEqual(x: Any): Boolean = !isEqual(x)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>以上Trait(特征)由两个方法组成：<strong>isEqual</strong> 和 <strong>isNotEqual</strong>。isEqual 方法没有定义方法的实现，isNotEqual定义了方法的实现。子类继承特征可以实现未被实现的方法。所以其实 Scala Trait(特征)更像 Java 的抽象类。</p> <p>以下演示了特征的完整实例：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>/* 文件名：Test.scala
 */
trait Equal {
  def isEqual(x: Any): Boolean
  def isNotEqual(x: Any): Boolean = !isEqual(x)
}

class Point(xc: Int, yc: Int) extends Equal {
  var x: Int = xc
  var y: Int = yc
  def isEqual(obj: Any) =
    obj.isInstanceOf[Point] &amp;&amp;
    obj.asInstanceOf[Point].x == x
}

object Test {
   def main(args: Array[String]) {
      val p1 = new Point(2, 3)
      val p2 = new Point(2, 4)
      val p3 = new Point(3, 3)

      println(p1.isNotEqual(p2))
      println(p1.isNotEqual(p3))
      println(p1.isNotEqual(2))
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>执行以上代码，输出结果为：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ scalac Test.scala 
$ scala Test
false
true
true
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><hr> <h4 id="特征构造顺序"><a href="#特征构造顺序" class="header-anchor">#</a> 特征构造顺序</h4> <p>特征也可以有构造器，由字段的初始化和其他特征体中的语句构成。这些语句在任何混入该特征的对象在构造时都会被执行。</p> <p>构造器的执行顺序：</p> <ul><li>调用超类的构造器；</li> <li>特征构造器在超类构造器之后、类构造器之前执行；</li> <li>特征由左到右被构造；</li> <li>每个特征当中，父特征先被构造；</li> <li>如果多个特征共有一个父特征，父特征不会被重复构造</li> <li>所有特征被构造完毕，子类被构造。</li></ul> <p>构造器的顺序是类的线性化的反向。线性化是描述某个类型的所有超类型的一种技术规格。</p></blockquote> <h3 id="scala模式匹配"><a href="#scala模式匹配" class="header-anchor">#</a> Scala模式匹配</h3> <blockquote><p>Scala 提供了强大的模式匹配机制，应用也非常广泛。</p> <p>一个模式匹配包含了一系列备选项，每个都开始于关键字 <strong>case</strong>。每个备选项都包含了一个模式及一到多个表达式。箭头符号 <strong>=&gt;</strong> 隔开了模式和表达式。</p> <p>以下是一个简单的整型值模式匹配实例：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>object Test {
   def main(args: Array[String]) {
      println(matchTest(3))

   }
   def matchTest(x: Int): String = x match {
      case 1 =&gt; &quot;one&quot;
      case 2 =&gt; &quot;two&quot;
      case _ =&gt; &quot;many&quot;
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>执行以上代码，输出结果为：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ scalac Test.scala 
$ scala Test
many
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>match 对应 Java 里的 switch，但是写在选择器表达式之后。即： <strong>选择器 match {备选项}。</strong></p> <p>match 表达式通过以代码编写的先后次序尝试每个模式来完成计算，只要发现有一个匹配的case，剩下的case不会继续匹配。</p> <p>接下来我们来看一个不同数据类型的模式匹配：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>object Test {
   def main(args: Array[String]) {
      println(matchTest(&quot;two&quot;))
      println(matchTest(&quot;test&quot;))
      println(matchTest(1))
      println(matchTest(6))

   }
   def matchTest(x: Any): Any = x match {
      case 1 =&gt; &quot;one&quot;
      case &quot;two&quot; =&gt; 2
      case y: Int =&gt; &quot;scala.Int&quot;
      case _ =&gt; &quot;many&quot;
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>执行以上代码，输出结果为：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ scalac Test.scala 
$ scala Test
2
many
one
scala.Int
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>实例中第一个 case 对应整型数值 1，第二个 case 对应字符串值 two，第三个 case 对应类型模式，用于判断传入的值是否为整型，相比使用isInstanceOf来判断类型，使用模式匹配更好。第四个 case 表示默认的全匹配备选项，即没有找到其他匹配时的匹配项，类似 switch 中的 default。</p> <hr> <h4 id="使用样例类"><a href="#使用样例类" class="header-anchor">#</a> 使用样例类</h4> <p>使用了case关键字的类定义就是就是样例类(case classes)，样例类是种特殊的类，经过优化以用于模式匹配。</p> <p>以下是样例类的简单实例:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>object Test {
   def main(args: Array[String]) {
       val alice = new Person(&quot;Alice&quot;, 25)
    val bob = new Person(&quot;Bob&quot;, 32)
       val charlie = new Person(&quot;Charlie&quot;, 32)
   
    for (person &lt;- List(alice, bob, charlie)) {
        person match {
            case Person(&quot;Alice&quot;, 25) =&gt; println(&quot;Hi Alice!&quot;)
            case Person(&quot;Bob&quot;, 32) =&gt; println(&quot;Hi Bob!&quot;)
            case Person(name, age) =&gt;
               println(&quot;Age: &quot; + age + &quot; year, name: &quot; + name + &quot;?&quot;)
         }
      }
   }
   // 样例类
   case class Person(name: String, age: Int)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>执行以上代码，输出结果为：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ scalac Test.scala 
$ scala Test
Hi Alice!
Hi Bob!
Age: 32 year, name: Charlie?
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>在声明样例类时，下面的过程自动发生了：</p> <ul><li>构造器的每个参数都成为val，除非显式被声明为var，但是并不推荐这么做；</li> <li>在伴生对象中提供了apply方法，所以可以不使用new关键字就可构建对象；</li> <li>提供unapply方法使模式匹配可以工作；</li> <li>生成toString、equals、hashCode和copy方法，除非显示给出这些方法的定义。</li></ul></blockquote> <h3 id="scala正则表达式"><a href="#scala正则表达式" class="header-anchor">#</a> Scala正则表达式</h3> <blockquote><p>Scala 通过 scala.util.matching 包中的 <strong>Regex</strong> 类来支持正则表达式。以下实例演示了使用正则表达式查找单词 <strong>Scala</strong> :</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>import scala.util.matching.Regex

object Test {
   def main(args: Array[String]) {
      val pattern = &quot;Scala&quot;.r
      val str = &quot;Scala is Scalable and cool&quot;
      
      println(pattern findFirstIn str)
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>执行以上代码，输出结果为：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ scalac Test.scala 
$ scala Test
Some(Scala)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>实例中使用 String 类的 r() 方法构造了一个Regex对象。</p> <p>然后使用 findFirstIn 方法找到首个匹配项。</p> <p>如果需要查看所有的匹配项可以使用 findAllIn 方法。</p> <p>你可以使用 mkString( ) 方法来连接正则表达式匹配结果的字符串，并可以使用管道(|)来设置不同的模式：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>import scala.util.matching.Regex

object Test {
   def main(args: Array[String]) {
      val pattern = new Regex(&quot;(S|s)cala&quot;)  // 首字母可以是大写 S 或小写 s
      val str = &quot;Scala is scalable and cool&quot;
      
      println((pattern findAllIn str).mkString(&quot;,&quot;))   // 使用逗号 , 连接返回结果
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>执行以上代码，输出结果为：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ scalac Test.scala 
$ scala Test
Scala,scala
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>如果你需要将匹配的文本替换为指定的关键词，可以使用 <strong>replaceFirstIn( )</strong> 方法来替换第一个匹配项，使用 <strong>replaceAllIn( )</strong> 方法替换所有匹配项，实例如下:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>object Test {
   def main(args: Array[String]) {
      val pattern = &quot;(S|s)cala&quot;.r
      val str = &quot;Scala is scalable and cool&quot;
      
      println(pattern replaceFirstIn(str, &quot;Java&quot;))
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>执行以上代码，输出结果为：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ scalac Test.scala 
$ scala Test
Java is scalable and cool
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><hr> <h4 id="正则表达式"><a href="#正则表达式" class="header-anchor">#</a> 正则表达式</h4> <p>Scala 的正则表达式继承了 Java 的语法规则，Java 则大部分使用了 Perl 语言的规则。</p> <p>下表我们给出了常用的一些正则表达式规则：</p> <table><thead><tr><th style="text-align:left;">表达式</th> <th style="text-align:left;">匹配规则</th></tr></thead> <tbody><tr><td style="text-align:left;">^</td> <td style="text-align:left;">匹配输入字符串开始的位置。</td></tr> <tr><td style="text-align:left;">$</td> <td style="text-align:left;">匹配输入字符串结尾的位置。</td></tr> <tr><td style="text-align:left;">.</td> <td style="text-align:left;">匹配除&quot;\r\n&quot;之外的任何单个字符。</td></tr> <tr><td style="text-align:left;">[...]</td> <td style="text-align:left;">字符集。匹配包含的任一字符。例如，&quot;[abc]&quot;匹配&quot;plain&quot;中的&quot;a&quot;。</td></tr> <tr><td style="text-align:left;">[^...]</td> <td style="text-align:left;">反向字符集。匹配未包含的任何字符。例如，&quot;[^abc]&quot;匹配&quot;plain&quot;中&quot;p&quot;，&quot;l&quot;，&quot;i&quot;，&quot;n&quot;。</td></tr> <tr><td style="text-align:left;">\A</td> <td style="text-align:left;">匹配输入字符串开始的位置（无多行支持）</td></tr> <tr><td style="text-align:left;">\z</td> <td style="text-align:left;">字符串结尾(类似$，但不受处理多行选项的影响)</td></tr> <tr><td style="text-align:left;">\Z</td> <td style="text-align:left;">字符串结尾或行尾(不受处理多行选项的影响)</td></tr> <tr><td style="text-align:left;">re*</td> <td style="text-align:left;">重复零次或更多次</td></tr> <tr><td style="text-align:left;">re+</td> <td style="text-align:left;">重复一次或更多次</td></tr> <tr><td style="text-align:left;">re?</td> <td style="text-align:left;">重复零次或一次</td></tr> <tr><td style="text-align:left;">re{ n}</td> <td style="text-align:left;">重复n次</td></tr> <tr><td style="text-align:left;">re{ n,}</td> <td style="text-align:left;"></td></tr> <tr><td style="text-align:left;">re{ n, m}</td> <td style="text-align:left;">重复n到m次</td></tr> <tr><td style="text-align:left;">a|b</td> <td style="text-align:left;">匹配 a 或者 b</td></tr> <tr><td style="text-align:left;">(re)</td> <td style="text-align:left;">匹配 re,并捕获文本到自动命名的组里</td></tr> <tr><td style="text-align:left;">(?: re)</td> <td style="text-align:left;">匹配 re,不捕获匹配的文本，也不给此分组分配组号</td></tr> <tr><td style="text-align:left;">(?&gt; re)</td> <td style="text-align:left;">贪婪子表达式</td></tr> <tr><td style="text-align:left;">\w</td> <td style="text-align:left;">匹配字母或数字或下划线或汉字</td></tr> <tr><td style="text-align:left;">\W</td> <td style="text-align:left;">匹配任意不是字母，数字，下划线，汉字的字符</td></tr> <tr><td style="text-align:left;">\s</td> <td style="text-align:left;">匹配任意的空白符,相等于 [\t\n\r\f]</td></tr> <tr><td style="text-align:left;">\S</td> <td style="text-align:left;">匹配任意不是空白符的字符</td></tr> <tr><td style="text-align:left;">\d</td> <td style="text-align:left;">匹配数字，类似 [0-9]</td></tr> <tr><td style="text-align:left;">\D</td> <td style="text-align:left;">匹配任意非数字的字符</td></tr> <tr><td style="text-align:left;">\G</td> <td style="text-align:left;">当前搜索的开头</td></tr> <tr><td style="text-align:left;">\n</td> <td style="text-align:left;">换行符</td></tr> <tr><td style="text-align:left;">\b</td> <td style="text-align:left;">通常是单词分界位置，但如果在字符类里使用代表退格</td></tr> <tr><td style="text-align:left;">\B</td> <td style="text-align:left;">匹配不是单词开头或结束的位置</td></tr> <tr><td style="text-align:left;">\t</td> <td style="text-align:left;">制表符</td></tr> <tr><td style="text-align:left;">\Q</td> <td style="text-align:left;">开始引号：<strong>\Q(a+b)*3\E</strong> 可匹配文本 &quot;(a+b)*3&quot;。</td></tr> <tr><td style="text-align:left;">\E</td> <td style="text-align:left;">结束引号：<strong>\Q(a+b)*3\E</strong> 可匹配文本 &quot;(a+b)*3&quot;。</td></tr></tbody></table> <hr> <h4 id="正则表达式实例"><a href="#正则表达式实例" class="header-anchor">#</a> 正则表达式实例</h4> <table><thead><tr><th style="text-align:left;">实例</th> <th style="text-align:left;">描述</th></tr></thead> <tbody><tr><td style="text-align:left;">.</td> <td style="text-align:left;">匹配除&quot;\r\n&quot;之外的任何单个字符。</td></tr> <tr><td style="text-align:left;">[Rr]uby</td> <td style="text-align:left;">匹配 &quot;Ruby&quot; 或 &quot;ruby&quot;</td></tr> <tr><td style="text-align:left;">rub[ye]</td> <td style="text-align:left;">匹配 &quot;ruby&quot; 或 &quot;rube&quot;</td></tr> <tr><td style="text-align:left;">[aeiou]</td> <td style="text-align:left;">匹配小写字母 ：aeiou</td></tr> <tr><td style="text-align:left;">[0-9]</td> <td style="text-align:left;">匹配任何数字，类似 [0123456789]</td></tr> <tr><td style="text-align:left;">[a-z]</td> <td style="text-align:left;">匹配任何 ASCII 小写字母</td></tr> <tr><td style="text-align:left;">[A-Z]</td> <td style="text-align:left;">匹配任何 ASCII 大写字母</td></tr> <tr><td style="text-align:left;">[a-zA-Z0-9]</td> <td style="text-align:left;">匹配数字，大小写字母</td></tr> <tr><td style="text-align:left;">[^aeiou]</td> <td style="text-align:left;">匹配除了 aeiou 其他字符</td></tr> <tr><td style="text-align:left;">[^0-9]</td> <td style="text-align:left;">匹配除了数字的其他字符</td></tr> <tr><td style="text-align:left;">\d</td> <td style="text-align:left;">匹配数字，类似: [0-9]</td></tr> <tr><td style="text-align:left;">\D</td> <td style="text-align:left;">匹配非数字，类似: [^0-9]</td></tr> <tr><td style="text-align:left;">\s</td> <td style="text-align:left;">匹配空格，类似: [ \t\r\n\f]</td></tr> <tr><td style="text-align:left;">\S</td> <td style="text-align:left;">匹配非空格，类似: [^ \t\r\n\f]</td></tr> <tr><td style="text-align:left;">\w</td> <td style="text-align:left;">匹配字母，数字，下划线，类似: [A-Za-z0-9_]</td></tr> <tr><td style="text-align:left;">\W</td> <td style="text-align:left;">匹配非字母，数字，下划线，类似: [^A-Za-z0-9_]</td></tr> <tr><td style="text-align:left;">ruby?</td> <td style="text-align:left;">匹配 &quot;rub&quot; 或 &quot;ruby&quot;: y 是可选的</td></tr> <tr><td style="text-align:left;">ruby*</td> <td style="text-align:left;">匹配 &quot;rub&quot; 加上 0 个或多个的 y。</td></tr> <tr><td style="text-align:left;">ruby+</td> <td style="text-align:left;">匹配 &quot;rub&quot; 加上 1 个或多个的 y。</td></tr> <tr><td style="text-align:left;">\d{3}</td> <td style="text-align:left;">刚好匹配 3 个数字。</td></tr> <tr><td style="text-align:left;">\d{3,}</td> <td style="text-align:left;">匹配 3 个或多个数字。</td></tr> <tr><td style="text-align:left;">\d{3,5}</td> <td style="text-align:left;">匹配 3 个、4 个或 5 个数字。</td></tr> <tr><td style="text-align:left;">\D\d+</td> <td style="text-align:left;">无分组： + 重复 \d</td></tr> <tr><td style="text-align:left;">(\D\d)+/</td> <td style="text-align:left;">分组： + 重复 \D\d 对</td></tr> <tr><td style="text-align:left;">([Rr]uby(, )?)+</td> <td style="text-align:left;">匹配 &quot;Ruby&quot;、&quot;Ruby, ruby, ruby&quot;，等等</td></tr></tbody></table> <p>注意上表中的每个字符使用了两个反斜线。这是因为在 Java 和 Scala 中字符串中的反斜线是转义字符。所以如果你要输出 ..，你需要在字符串中写成 .\. 来获取一个反斜线。查看以下实例：</p> <div class="language-scala line-numbers-mode"><pre class="language-scala"><code><span class="token keyword">import</span> <span class="token namespace">scala<span class="token punctuation">.</span>util<span class="token punctuation">.</span>matching<span class="token punctuation">.</span></span>Regex

<span class="token keyword">object</span> Test <span class="token punctuation">{</span>
   <span class="token keyword">def</span> main<span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">val</span> pattern <span class="token operator">=</span> <span class="token keyword">new</span> Regex<span class="token punctuation">(</span><span class="token string">&quot;abl[ae]\\d+&quot;</span><span class="token punctuation">)</span>
      <span class="token keyword">val</span> str <span class="token operator">=</span> <span class="token string">&quot;ablaw is able1 and cool&quot;</span>
      
      println<span class="token punctuation">(</span><span class="token punctuation">(</span>pattern findAllIn str<span class="token punctuation">)</span><span class="token punctuation">.</span>mkString<span class="token punctuation">(</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>执行以上代码，输出结果为：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ scalac Test.scala 
$ scala Test
able1
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></blockquote> <h3 id="scala异常处理"><a href="#scala异常处理" class="header-anchor">#</a> Scala异常处理</h3> <blockquote><p>Scala 的异常处理和其它语言比如 Java 类似。</p> <p>Scala 的方法可以通过抛出异常的方法的方式来终止相关代码的运行，不必通过返回值。</p> <hr> <h4 id="抛出异常"><a href="#抛出异常" class="header-anchor">#</a> 抛出异常</h4> <p>Scala 抛出异常的方法和 Java一样，使用 throw 方法，例如，抛出一个新的参数异常：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>throw new IllegalArgumentException
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><hr> <h4 id="捕获异常"><a href="#捕获异常" class="header-anchor">#</a> 捕获异常</h4> <p>异常捕捉的机制与其他语言中一样，如果有异常发生，catch字句是按次序捕捉的。因此，在catch字句中，越具体的异常越要靠前，越普遍的异常越靠后。 如果抛出的异常不在catch字句中，该异常则无法处理，会被升级到调用者处。</p> <p>捕捉异常的catch子句，语法与其他语言中不太一样。在Scala里，借用了模式匹配的思想来做异常的匹配，因此，在catch的代码里，是一系列case字句，如下例所示：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>import java.io.FileReader
import java.io.FileNotFoundException
import java.io.IOException

object Test {
   def main(args: Array[String]) {
      try {
         val f = new FileReader(&quot;input.txt&quot;)
      } catch {
         case ex: FileNotFoundException =&gt;{
            println(&quot;Missing file exception&quot;)
         }
         case ex: IOException =&gt; {
            println(&quot;IO Exception&quot;)
         }
      }
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>执行以上代码，输出结果为：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ scalac Test.scala 
$ scala Test
Missing file exception
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>catch字句里的内容跟match里的case是完全一样的。由于异常捕捉是按次序，如果最普遍的异常，Throwable，写在最前面，则在它后面的case都捕捉不到，因此需要将它写在最后面。</p> <hr> <h4 id="finally-语句"><a href="#finally-语句" class="header-anchor">#</a> finally 语句</h4> <p>finally 语句用于执行不管是正常处理还是有异常发生时都需要执行的步骤，实例如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>import java.io.FileReader
import java.io.FileNotFoundException
import java.io.IOException

object Test {
   def main(args: Array[String]) {
      try {
         val f = new FileReader(&quot;input.txt&quot;)
      } catch {
         case ex: FileNotFoundException =&gt; {
            println(&quot;Missing file exception&quot;)
         }
         case ex: IOException =&gt; {
            println(&quot;IO Exception&quot;)
         }
      } finally {
         println(&quot;Exiting finally...&quot;)
      }
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>执行以上代码，输出结果为：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ scalac Test.scala 
$ scala Test
Missing file exception
Exiting finally...
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></blockquote> <h3 id="scala提取器-extractor"><a href="#scala提取器-extractor" class="header-anchor">#</a> Scala提取器（Extractor）</h3> <blockquote><p>提取器是从传递给它的对象中提取出构造该对象的参数。</p> <p>Scala 标准库包含了一些预定义的提取器，我们会大致的了解一下它们。</p> <p>Scala 提取器是一个带有unapply方法的对象。unapply方法算是apply方法的反向操作：unapply接受一个对象，然后从对象中提取值，提取的值通常是用来构造该对象的值。</p> <p>以下实例演示了邮件地址的提取器对象：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>object Test {
   def main(args: Array[String]) {
      
      println (&quot;Apply 方法 : &quot; + apply(&quot;Zara&quot;, &quot;gmail.com&quot;));
      println (&quot;Unapply 方法 : &quot; + unapply(&quot;Zara@gmail.com&quot;));
      println (&quot;Unapply 方法 : &quot; + unapply(&quot;Zara Ali&quot;));

   }
   // 注入方法 (可选)
   def apply(user: String, domain: String) = {
      user +&quot;@&quot;+ domain
   }

   // 提取方法（必选）
   def unapply(str: String): Option[(String, String)] = {
      val parts = str split &quot;@&quot;
      if (parts.length == 2){
         Some(parts(0), parts(1)) 
      }else{
         None
      }
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p>执行以上代码，输出结果为：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ scalac Test.scala 
$ scala Test
Apply 方法 : Zara@gmail.com
Unapply 方法 : Some((Zara,gmail.com))
Unapply 方法 : None
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>以上对象定义了两个方法： <strong>apply</strong> 和 <strong>unapply</strong> 方法。通过 apply 方法我们无需使用 new 操作就可以创建对象。所以你可以通过语句 Test(&quot;Zara&quot;, &quot;gmail.com&quot;) 来构造一个字符串 &quot;Zara@gmail.com&quot;。</p> <p>unapply方法算是apply方法的反向操作：unapply接受一个对象，然后从对象中提取值，提取的值通常是用来构造该对象的值。实例中我们使用 Unapply 方法从对象中提取用户名和邮件地址的后缀。</p> <p>实例中 unapply 方法在传入的字符串不是邮箱地址时返回 None。代码演示如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>unapply(&quot;Zara@gmail.com&quot;) 相等于 Some(&quot;Zara&quot;, &quot;gmail.com&quot;)
unapply(&quot;Zara Ali&quot;) 相等于 None
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><hr> <h4 id="提取器使用模式匹配"><a href="#提取器使用模式匹配" class="header-anchor">#</a> 提取器使用模式匹配</h4> <p>在我们实例化一个类的时，可以带上0个或者多个的参数，编译器在实例化的时会调用 apply 方法。我们可以在类和对象中都定义 apply 方法。</p> <p>就像我们之前提到过的，unapply 用于提取我们指定查找的值，它与 apply 的操作相反。 当我们在提取器对象中使用 match 语句是，unapply 将自动执行，如下所示：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>object Test {
   def main(args: Array[String]) {
      
      val x = Test(5)
      println(x)

      x match
      {
         case Test(num) =&gt; println(x + &quot; 是 &quot; + num + &quot; 的两倍！&quot;)
         //unapply 被调用
         case _ =&gt; println(&quot;无法计算&quot;)
      }

   }
   def apply(x: Int) = x*2
   def unapply(z: Int): Option[Int] = if (z%2==0) Some(z/2) else None
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>执行以上代码，输出结果为：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ scalac Test.scala 
$ scala Test
10
10 是 5 的两倍！
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></blockquote> <h3 id="scala-文件i-o"><a href="#scala-文件i-o" class="header-anchor">#</a> Scala 文件I/O</h3> <blockquote><h4 id="scala-进行文件写操作-直接用的都是-java中-的-i-o-类-java-io-file"><a href="#scala-进行文件写操作-直接用的都是-java中-的-i-o-类-java-io-file" class="header-anchor">#</a> Scala 进行文件写操作，直接用的都是 java中 的 I/O 类 （<strong>java.io.File</strong>)：</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>import java.io._

object Test {
   def main(args: Array[String]) {
      val writer = new PrintWriter(new File(&quot;test.txt&quot; ))

      writer.write(&quot;菜鸟教程&quot;)
      writer.close()
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>执行以上代码，会在你的当前目录下生产一个 test.txt 文件，文件内容为&quot;菜鸟教程&quot;:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ scalac Test.scala 
$ scala Test
$ cat test.txt 
菜鸟教程
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><hr> <h4 id="从屏幕上读取用户输入"><a href="#从屏幕上读取用户输入" class="header-anchor">#</a> 从屏幕上读取用户输入</h4> <p>有时候我们需要接收用户在屏幕输入的指令来处理程序。实例如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>import scala.io._
object Test {
   def main(args: Array[String]) {
      print(&quot;请输入weekdawn : &quot; )
      val line = StdIn.readLine()

      println(&quot;谢谢，你输入的是: &quot; + line)
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><blockquote><p>Scala2.11 后的版本 <strong>Console.readLine</strong> 已废弃，使用 <strong>scala.io.StdIn.readLine()</strong> 方法代替。</p></blockquote> <p>执行以上代码，屏幕上会显示如下信息:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ scalac Test.scala 
$ scala Test
请输入菜鸟教程官网 : www.runoob.com
谢谢，你输入的是: www.runoob.com
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><hr> <h4 id="从文件上读取内容"><a href="#从文件上读取内容" class="header-anchor">#</a> 从文件上读取内容</h4> <p>从文件读取内容非常简单。我们可以使用 Scala 的 <strong>Source</strong> 类及伴生对象来读取文件。以下实例演示了从 &quot;test.txt&quot;(之前已创建过) 文件中读取内容:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>import scala.io.Source

object Test {
   def main(args: Array[String]) {
      println(&quot;文件内容为:&quot; )

      Source.fromFile(&quot;test.txt&quot; ).foreach{ 
         print 
      }
   }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>执行以上代码，输出结果为:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ scalac Test.scala 
$ scala Test
文件内容为:
weekdawn
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></blockquote></div></section> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新: </span> <span class="time">2022/08/22 10:00:40</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
          ←
          <a href="/blogs/其他/笔记/conda命令.html" class="prev">
            conda命令
          </a></span> <span class="next"><a href="/blogs/其他/笔记/bat批处理语法.html">
            bat批处理语法
          </a>
          →
        </span></p></div> <div class="article-list" data-v-6845f1ce><div class="article-title" data-v-6845f1ce><a href="/timeline/" class="iconfont icon-shizhong" data-v-6845f1ce>最近更新</a></div> <div class="article-wrapper" data-v-6845f1ce><dl data-v-6845f1ce><dd data-v-6845f1ce>01</dd> <dt data-v-6845f1ce><a href="/blogs/后端/python/JsonItemExporter和JsonLinesItemExporter保存数据的异同.html" data-v-6845f1ce><div data-v-6845f1ce>JsonItemExporter 和 JsonLinesItemExporter 保存数据的异同</div></a> <span data-v-6845f1ce>08-18</span></dt></dl><dl data-v-6845f1ce><dd data-v-6845f1ce>02</dd> <dt data-v-6845f1ce><a href="/blogs/后端/数据库/mongodb教程.html" data-v-6845f1ce><div data-v-6845f1ce>mongodb教程</div></a> <span data-v-6845f1ce>08-18</span></dt></dl><dl data-v-6845f1ce><dd data-v-6845f1ce>03</dd> <dt data-v-6845f1ce><a href="/blogs/后端/数据库/mongodb配置和操作.html" data-v-6845f1ce><div data-v-6845f1ce>mongodb常用配置和操作</div></a> <span data-v-6845f1ce>08-18</span></dt></dl></div> <div data-v-6845f1ce><a href="/timeline/" class="article-more" data-v-6845f1ce>更多&gt;</a></div></div> <div class="comments-wrapper"><!----></div> <ul class="side-bar sub-sidebar-wrapper" style="width:12rem;" data-v-5ecb72e8><li class="level-3" data-v-5ecb72e8><a href="/blogs/其他/笔记/Scala学习笔记.html#简介" class="sidebar-link reco-side-简介" data-v-5ecb72e8>简介</a></li><li class="level-3" data-v-5ecb72e8><a href="/blogs/其他/笔记/Scala学习笔记.html#scala特性" class="sidebar-link reco-side-scala特性" data-v-5ecb72e8>Scala特性</a></li><li class="level-3" data-v-5ecb72e8><a href="/blogs/其他/笔记/Scala学习笔记.html#扩展性" class="sidebar-link reco-side-扩展性" data-v-5ecb72e8>扩展性</a></li><li class="level-3" data-v-5ecb72e8><a href="/blogs/其他/笔记/Scala学习笔记.html#并发性" class="sidebar-link reco-side-并发性" data-v-5ecb72e8>并发性</a></li><li class="level-3" data-v-5ecb72e8><a href="/blogs/其他/笔记/Scala学习笔记.html#谁使用了-scala" class="sidebar-link reco-side-谁使用了-scala" data-v-5ecb72e8>谁使用了 Scala</a></li><li class="level-3" data-v-5ecb72e8><a href="/blogs/其他/笔记/Scala学习笔记.html#基础语法" class="sidebar-link reco-side-基础语法" data-v-5ecb72e8>基础语法</a></li><li class="level-3" data-v-5ecb72e8><a href="/blogs/其他/笔记/Scala学习笔记.html#scala数据类型" class="sidebar-link reco-side-scala数据类型" data-v-5ecb72e8>Scala数据类型</a></li><li class="level-3" data-v-5ecb72e8><a href="/blogs/其他/笔记/Scala学习笔记.html#整型字面量" class="sidebar-link reco-side-整型字面量" data-v-5ecb72e8>整型字面量</a></li><li class="level-3" data-v-5ecb72e8><a href="/blogs/其他/笔记/Scala学习笔记.html#浮点型字面量" class="sidebar-link reco-side-浮点型字面量" data-v-5ecb72e8>浮点型字面量</a></li><li class="level-3" data-v-5ecb72e8><a href="/blogs/其他/笔记/Scala学习笔记.html#布尔型字面量" class="sidebar-link reco-side-布尔型字面量" data-v-5ecb72e8>布尔型字面量</a></li><li class="level-3" data-v-5ecb72e8><a href="/blogs/其他/笔记/Scala学习笔记.html#符号字面量" class="sidebar-link reco-side-符号字面量" data-v-5ecb72e8>符号字面量</a></li><li class="level-3" data-v-5ecb72e8><a href="/blogs/其他/笔记/Scala学习笔记.html#字符字面量" class="sidebar-link reco-side-字符字面量" data-v-5ecb72e8>字符字面量</a></li><li class="level-3" data-v-5ecb72e8><a href="/blogs/其他/笔记/Scala学习笔记.html#字符串字面量" class="sidebar-link reco-side-字符串字面量" data-v-5ecb72e8>字符串字面量</a></li><li class="level-3" data-v-5ecb72e8><a href="/blogs/其他/笔记/Scala学习笔记.html#多行字符串的表示方法" class="sidebar-link reco-side-多行字符串的表示方法" data-v-5ecb72e8>多行字符串的表示方法</a></li><li class="level-3" data-v-5ecb72e8><a href="/blogs/其他/笔记/Scala学习笔记.html#null-值" class="sidebar-link reco-side-null-值" data-v-5ecb72e8>Null 值</a></li><li class="level-3" data-v-5ecb72e8><a href="/blogs/其他/笔记/Scala学习笔记.html#scala变量" class="sidebar-link reco-side-scala变量" data-v-5ecb72e8>Scala变量</a></li><li class="level-3" data-v-5ecb72e8><a href="/blogs/其他/笔记/Scala学习笔记.html#scala访问修饰符" class="sidebar-link reco-side-scala访问修饰符" data-v-5ecb72e8>Scala访问修饰符</a></li><li class="level-3" data-v-5ecb72e8><a href="/blogs/其他/笔记/Scala学习笔记.html#scala运算符" class="sidebar-link reco-side-scala运算符" data-v-5ecb72e8>Scala运算符</a></li><li class="level-3" data-v-5ecb72e8><a href="/blogs/其他/笔记/Scala学习笔记.html#scala-if-else" class="sidebar-link reco-side-scala-if-else" data-v-5ecb72e8>Scala IF...ELSE</a></li><li class="level-3" data-v-5ecb72e8><a href="/blogs/其他/笔记/Scala学习笔记.html#scala循环" class="sidebar-link reco-side-scala循环" data-v-5ecb72e8>Scala循环</a></li><li class="level-3" data-v-5ecb72e8><a href="/blogs/其他/笔记/Scala学习笔记.html#实例" class="sidebar-link reco-side-实例" data-v-5ecb72e8>实例</a></li><li class="level-2" data-v-5ecb72e8><a href="/blogs/其他/笔记/Scala学习笔记.html#for-循环集合" class="sidebar-link reco-side-for-循环集合" data-v-5ecb72e8>for 循环集合</a></li><li class="level-3" data-v-5ecb72e8><a href="/blogs/其他/笔记/Scala学习笔记.html#实例-2" class="sidebar-link reco-side-实例-2" data-v-5ecb72e8>实例</a></li><li class="level-2" data-v-5ecb72e8><a href="/blogs/其他/笔记/Scala学习笔记.html#for-循环过滤" class="sidebar-link reco-side-for-循环过滤" data-v-5ecb72e8>for 循环过滤</a></li><li class="level-3" data-v-5ecb72e8><a href="/blogs/其他/笔记/Scala学习笔记.html#实例-3" class="sidebar-link reco-side-实例-3" data-v-5ecb72e8>实例</a></li><li class="level-2" data-v-5ecb72e8><a href="/blogs/其他/笔记/Scala学习笔记.html#for-使用-yield" class="sidebar-link reco-side-for-使用-yield" data-v-5ecb72e8>for 使用 yield</a></li><li class="level-3" data-v-5ecb72e8><a href="/blogs/其他/笔记/Scala学习笔记.html#实例-4" class="sidebar-link reco-side-实例-4" data-v-5ecb72e8>实例</a></li><li class="level-3" data-v-5ecb72e8><a href="/blogs/其他/笔记/Scala学习笔记.html#scala方法与函数" class="sidebar-link reco-side-scala方法与函数" data-v-5ecb72e8>Scala方法与函数</a></li><li class="level-3" data-v-5ecb72e8><a href="/blogs/其他/笔记/Scala学习笔记.html#scala数组" class="sidebar-link reco-side-scala数组" data-v-5ecb72e8>Scala数组</a></li><li class="level-3" data-v-5ecb72e8><a href="/blogs/其他/笔记/Scala学习笔记.html#scala集合" class="sidebar-link reco-side-scala集合" data-v-5ecb72e8>Scala集合</a></li><li class="level-3" data-v-5ecb72e8><a href="/blogs/其他/笔记/Scala学习笔记.html#scala-set" class="sidebar-link reco-side-scala-set" data-v-5ecb72e8>Scala Set</a></li><li class="level-3" data-v-5ecb72e8><a href="/blogs/其他/笔记/Scala学习笔记.html#scala-map" class="sidebar-link reco-side-scala-map" data-v-5ecb72e8>Scala Map</a></li><li class="level-3" data-v-5ecb72e8><a href="/blogs/其他/笔记/Scala学习笔记.html#scala-option" class="sidebar-link reco-side-scala-option" data-v-5ecb72e8>Scala Option</a></li><li class="level-3" data-v-5ecb72e8><a href="/blogs/其他/笔记/Scala学习笔记.html#scala-iterator" class="sidebar-link reco-side-scala-iterator" data-v-5ecb72e8>Scala Iterator</a></li><li class="level-3" data-v-5ecb72e8><a href="/blogs/其他/笔记/Scala学习笔记.html#scala类和对象" class="sidebar-link reco-side-scala类和对象" data-v-5ecb72e8>Scala类和对象</a></li><li class="level-3" data-v-5ecb72e8><a href="/blogs/其他/笔记/Scala学习笔记.html#scala-trait-特征" class="sidebar-link reco-side-scala-trait-特征" data-v-5ecb72e8>Scala Trait(特征)</a></li><li class="level-3" data-v-5ecb72e8><a href="/blogs/其他/笔记/Scala学习笔记.html#scala模式匹配" class="sidebar-link reco-side-scala模式匹配" data-v-5ecb72e8>Scala模式匹配</a></li><li class="level-3" data-v-5ecb72e8><a href="/blogs/其他/笔记/Scala学习笔记.html#scala正则表达式" class="sidebar-link reco-side-scala正则表达式" data-v-5ecb72e8>Scala正则表达式</a></li><li class="level-3" data-v-5ecb72e8><a href="/blogs/其他/笔记/Scala学习笔记.html#scala异常处理" class="sidebar-link reco-side-scala异常处理" data-v-5ecb72e8>Scala异常处理</a></li><li class="level-3" data-v-5ecb72e8><a href="/blogs/其他/笔记/Scala学习笔记.html#scala提取器-extractor" class="sidebar-link reco-side-scala提取器-extractor" data-v-5ecb72e8>Scala提取器（Extractor）</a></li><li class="level-3" data-v-5ecb72e8><a href="/blogs/其他/笔记/Scala学习笔记.html#scala-文件i-o" class="sidebar-link reco-side-scala-文件i-o" data-v-5ecb72e8>Scala 文件I/O</a></li></ul></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div><div data-v-3338c3f8><div class="DetailsOpenFlag" style="right:1rem;bottom:9rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;font-size:14px;font-weight:500;display:none;" data-v-3338c3f8>
 展开

</div></div><!----><div class="Sakura" data-v-248d85d6><canvas id="canvas_sakura" style="z-index:-1;" data-v-248d85d6></canvas></div><!----><!----></div></div>
    <script src="/assets/js/app.b52a54d3.js" defer></script><script src="/assets/js/4.2ab4d284.js" defer></script><script src="/assets/js/1.d5207ac6.js" defer></script><script src="/assets/js/83.402b2fce.js" defer></script><script src="/assets/js/20.23ca62f8.js" defer></script>
    <div id="maps" style="pointer-events:auto;display: none;">
      <div
        style="position: fixed; width: 300px; height: 300px; right: 200px; bottom: 0px;"
      >
      <script type="text/javascript" src="//rf.revolvermaps.com/0/0/6.js?i=5kd8hpv87ho&amp;m=7&amp;c=e63100&amp;cr1=ffffff&amp;f=arial&amp;l=0&amp;bv=90&amp;lx=-420&amp;ly=420&amp;hi=20&amp;he=7&amp;hc=a8ddff&amp;rs=80" async="async"></script>
      </div>
    </div>
  </body>
</html>
